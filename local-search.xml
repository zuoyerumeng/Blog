<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>三维视觉</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/7-%E4%B8%89%E7%BB%B4%E8%A7%86%E8%A7%89/%E4%B8%89%E7%BB%B4%E8%A7%86%E8%A7%89/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/7-%E4%B8%89%E7%BB%B4%E8%A7%86%E8%A7%89/%E4%B8%89%E7%BB%B4%E8%A7%86%E8%A7%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="点云模型"><a href="#点云模型" class="headerlink" title="点云模型"></a><strong>点云模型</strong></h1><p>降维表示Spin Image</p><h1 id="三维重建"><a href="#三维重建" class="headerlink" title="三维重建"></a><strong>三维重建</strong></h1><p>SfM：一个估计相机参数及三维点位置的问题</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>7.三维视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像生成</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/6-%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/6-%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可参考笔记较少，暂时略~</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>6.图像生成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标跟踪</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/5-%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/5-%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>与NLP关系不大、难以结合，暂时不学~</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>5.目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>姿态估计</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/4-%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/4-%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>与NLP关系不大、难以结合，暂时不学~</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>4.姿态估计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像分类</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/3-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/3-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a><strong>评价指标</strong></h1><p>同分类问题的评价指标</p><h1 id="传统机器学习方法"><a href="#传统机器学习方法" class="headerlink" title="传统机器学习方法"></a><strong>传统机器学习方法</strong></h1><p>特征提取（见特征提取部分）→分类算法模型（见ML部分）</p><h1 id="深度学习算法"><a href="#深度学习算法" class="headerlink" title="深度学习算法"></a><strong>深度学习算法</strong></h1><p>VGG16、ResNet、Densent</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>3.图像分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标检测</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/2-%E5%9B%BE%E5%83%8F%EF%BC%88%E7%9B%AE%E6%A0%87%EF%BC%89%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/2-%E5%9B%BE%E5%83%8F%EF%BC%88%E7%9B%AE%E6%A0%87%EF%BC%89%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>评价指标：大体同分类问题的评价指标，除此之外还有速度指标FLOPS</p><h1 id="完全传统方法"><a href="#完全传统方法" class="headerlink" title="完全传统方法"></a>完全传统方法</h1><h2 id="Viola-Jones"><a href="#Viola-Jones" class="headerlink" title="Viola-Jones"></a>Viola-Jones</h2><p>搜索Haar类特征→Adaboost得到每个Haar类特征的分类器，并将其级联</p><h2 id="DPM（Deformable-Parts-Model）"><a href="#DPM（Deformable-Parts-Model）" class="headerlink" title="DPM（Deformable Parts Model）"></a>DPM（Deformable Parts Model）</h2><p>分而治之：推理期间对象各部分单独检测，将可能的排列即为检测结果</p><h1 id="传统机器学习算法"><a href="#传统机器学习算法" class="headerlink" title="传统机器学习算法"></a>传统机器学习算法</h1><p>滑动窗口+分类算法</p><h1 id="深度学习算法"><a href="#深度学习算法" class="headerlink" title="深度学习算法"></a>深度学习算法</h1><h2 id="One-stage（单阶段）"><a href="#One-stage（单阶段）" class="headerlink" title="One-stage（单阶段）"></a>One-stage（单阶段）</h2><h3 id="YOLO（You-only-look-once）-v1-4"><a href="#YOLO（You-only-look-once）-v1-4" class="headerlink" title="YOLO（You only look once） v1~4"></a>YOLO（You only look once） v1~4</h3><ul><li>采用一个单独的 CNN 模型实现 end-to-end 的目标检测</li><li>舍去了候选框提取分支（Proposal阶段），直接将特征提取、候选框回归和分类在同一个无分支的卷积网络中完成</li><li>检测速度较Faster R-CNN有近10倍的提升，处理速度可以达到45fps，使得深度学习目标检测算法开始满足实时要求</li></ul><h3 id="SSD（Single-Shot-Multibox-Detector）"><a href="#SSD（Single-Shot-Multibox-Detector）" class="headerlink" title="SSD（Single Shot Multibox Detector）"></a>SSD（Single Shot Multibox Detector）</h3><ul><li>采用CNN来直接进行检测，而不是像 YOLO 那样在全连接层之后做检测。</li><li>取了不同尺度的特征图来做检测，大尺度特征图（较靠前的特征图）可以用来检测小物体，而小尺度特征图（较靠后的特征图）用来检测大物体。</li><li>同时在速度和准确度上有大幅提升，使得大家看到了实时高精度目标检测的可行性</li></ul><h3 id="RetinaNet"><a href="#RetinaNet" class="headerlink" title="RetinaNet"></a>RetinaNet</h3><p>具体略~</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="Two-stage（双阶段）"><a href="#Two-stage（双阶段）" class="headerlink" title="Two-stage（双阶段）"></a>Two-stage（双阶段）</h2><p>[Fast[er]] R-CNN：略~</p><h3 id="SPP-Net（spatial-pyramid-pooling，空间金字塔池化）"><a href="#SPP-Net（spatial-pyramid-pooling，空间金字塔池化）" class="headerlink" title="SPP-Net（spatial pyramid pooling，空间金字塔池化）"></a>SPP-Net（spatial pyramid pooling，空间金字塔池化）</h3><ul><li><p>在R-CNN的基础上，SPP层加在最后一个卷积层与全连接层之间目的就是为了输出固定长度的特征传给要求固定输入的全连接层</p></li><li><p>SPP-net在region     proposal module之前，只是平移了CNN的卷积层，增加了pooling层，使得网络不依赖于size&#x2F;aspect ratio，减少了计算量。生成候选窗口的算法仍是选择性搜索（SS）。</p></li><li><p>四个模块：</p></li><li><ul><li>卷积神经网络提取特征，在此用的ZF-5的5蹭卷积网络；产生类别无关的候选检测区域集合，大约2000个；</li><li>将候选框区域映射到特征图中；</li><li>然后通过spp将其池化到固定大小；</li><li>通过训练的指定类别的线性SVM分类器以及拟合边框回归。</li></ul></li></ul><h3 id="FPN（特征金字塔网络）"><a href="#FPN（特征金字塔网络）" class="headerlink" title="FPN（特征金字塔网络）"></a>FPN（特征金字塔网络）</h3><ul><li><p>采用自上而下的横向连接架构，在不同的尺度上构建高层次的语义特征。</p></li><li><ul><li>特征金字塔：使用不同层次的金字塔层feature map进行预测</li><li>特征金字塔网络：对最底层的特征进行向上采样，并与该底层特征进行融合，得到高分辨率、强语义的特征（即加强了特征的提取）</li></ul></li><li><p>三种路：</p></li><li><ul><li>resnet特征提取（feature map）：自底向上</li><li>最后一层feature map上采样：自顶向下</li><li>特征融合：横向连接</li></ul></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="R-FCN（基于区域的全卷积神经网络）"><a href="#R-FCN（基于区域的全卷积神经网络）" class="headerlink" title="R-FCN（基于区域的全卷积神经网络）"></a>R-FCN（基于区域的全卷积神经网络）</h3><p>使用位置敏感评分图，编码空间信息以确定准确定位</p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>2.图像（目标）的检测识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像（目标）的检测识别</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/2-%E5%9B%BE%E5%83%8F%EF%BC%88%E7%9B%AE%E6%A0%87%EF%BC%89%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB/%E5%9B%BE%E5%83%8F%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/2-%E5%9B%BE%E5%83%8F%EF%BC%88%E7%9B%AE%E6%A0%87%EF%BC%89%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB/%E5%9B%BE%E5%83%8F%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>评价指标：大体同分类问题的评价指标，除此之外还有速度指标FLOPS</p><h1 id="图像检测"><a href="#图像检测" class="headerlink" title="图像检测"></a>图像检测</h1><ul><li>直线检测、线段检测、轮廓检测、角点检测：具体略~</li><li>基于回归</li></ul><h2 id="box（边框）回归"><a href="#box（边框）回归" class="headerlink" title="box（边框）回归"></a>box（边框）回归</h2><h3 id="CTPN（Connectionist-Text-Proposal-Network，连接文本建议网络）"><a href="#CTPN（Connectionist-Text-Proposal-Network，连接文本建议网络）" class="headerlink" title="CTPN（Connectionist  Text  Proposal Network，连接文本建议网络）"></a>CTPN（Connectionist  Text  Proposal Network，连接文本建议网络）</h3><ul><li>结合CNN与双向LSTM深度网络，能有效的检测出复杂场景的横向分布的文字</li><li>核心思想是将图片按宽度为16像素分成很多个小格（锚点，anchor机制），检测每一个小格中是否包含文本，同时预测文本的高度和宽度。最后将多个检测结果融合，形成最终的文本框。对于倾斜和弯曲的文本检测效果很差。</li></ul><h3 id="EAST（Efficient-and-Accuracy-Scene-Text）"><a href="#EAST（Efficient-and-Accuracy-Scene-Text）" class="headerlink" title="EAST（Efficient and Accuracy Scene Text）"></a>EAST（Efficient and Accuracy Scene Text）</h3><ul><li>先是一个全卷积的网络（分为三部分：特征提取层，特征融合层，输出层）直接产生一个字符或者文本行的预测（可以是旋转的矩形或者不规则四边形），然后通过NMS（Non-Maximum Suppression）算法合并最后的结果。</li><li>Seglink基础上的改进算法，在识别倾斜和弯曲文本的效果上比较好，同样利用开源项目进行了测试</li></ul><h2 id="像素值回归"><a href="#像素值回归" class="headerlink" title="像素值回归"></a>像素值回归</h2><ul><li>CRAFT：可以识别任意角度的文本，而且可以给出图片中每一个像素为文本的置信分。</li><li>SA-Text：略~</li></ul><h1 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h1><ul><li>基于RNN的算法框架：CNN+RNN+CTC（CRNN+CTC）、CNN+Seq2Seq+Attention</li><li>三种解码方法：CTC、Attention、ACE</li><li>Seglink：在CTPN基础上进行改进，利用开源项目测试了一些比较模糊的图片</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>2.图像（目标）的检测识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像分割</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/1-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/1-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h1><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><ul><li><p>Dice score：</p></li><li><ul><li>类似于F1 score：</li></ul></li></ul><p>$$<br>D S C&#x3D;\frac{2|X \cap Y|}{|X|+|Y|}<br>$$</p><ul><li><p>HD95（豪斯多夫距离）：<br>$$<br>\begin{aligned}<br>&amp;h(A, B)&#x3D;\max _{a \in A}\left{\min _{b \in B}|a-b|\right}\<br>&amp;h(A, B)&#x3D;\max _{b \in B}\left{\min _{a \in A}|b-a|\right}<br>\end{aligned}<br>$$</p></li><li><p>RVE（体积相关误差）：<br>$$<br>R V E\left(R_a, R_b\right)&#x3D;\frac{a b s\left(\left|R_a\right|-\left|R_b\right|\right)}{\left|R_b\right|}<br>$$</p></li><li><p>像素准确率：类似于一般的准确率</p></li></ul><h2 id="算法模型"><a href="#算法模型" class="headerlink" title="算法模型"></a>算法模型</h2><h3 id="传统机器学习算法"><a href="#传统机器学习算法" class="headerlink" title="传统机器学习算法"></a>传统机器学习算法</h3><ul><li><p>特征提取→Graph-cut（Grabcut）</p></li><li><p>基于阈值、区域（四叉树分解法，区域分裂合并；分水岭算法）、边缘检测（并行微分算子法，见滤波中的边缘检测部分）、遗传算法、主动轮廓模型</p></li></ul><h3 id="深度学习算法"><a href="#深度学习算法" class="headerlink" title="深度学习算法"></a>深度学习算法</h3><p>VGG-Net、ResNet、[Faster]R-CNN：略~</p><h4 id="SegNet"><a href="#SegNet" class="headerlink" title="SegNet"></a>SegNet</h4><ul><li><p>Encoder：</p></li><li><ul><li>是一个沿用VGG16的网络模型，主要对物体信息进行归类与分析。</li><li>主要由卷基层，池化层和BatchNormalization层组成。卷基层负责获取图像局域特征，池化层对图像进行下采样并且将尺度不变特征传送到下一层，而BN主要对训练图像的分布归一化，加速学习。</li></ul></li><li><p>Decoder：</p></li><li><ul><li>将解析后的信息对应成最终的图像形式，即每个像素都用对应其物体信息的颜色（或者是label）来表示。</li><li>Decoder对缩小后的特征图像进行上采样，然后对上采样后的图像进行卷积处理，目的是完善物体的几何形状，弥补Encoder当中池化层将物体缩小造成的细节损失。</li><li>池化层运用了pooling indices技术，保存池化点的来源信息，减少逐层累计的误差。</li></ul></li></ul><h4 id="U-Net"><a href="#U-Net" class="headerlink" title="U-Net[++]"></a>U-Net[++]</h4><ul><li>FCN的一种变体，采用encoder-decoder的U形（即对称）结构，U的左边负责特征的提取，右边负责特征的还原</li><li>全卷积网络（即网络中没有全连接操作）</li><li>速度很快</li></ul><h4 id="DeepLab-V1-3"><a href="#DeepLab-V1-3" class="headerlink" title="DeepLab V1~3[+]"></a>DeepLab V1~3[+]</h4><ul><li>v1：空洞卷积（Atros Convolution，往卷积操作中加入“空洞”，即值为0的点来增加感受野，即卷积神经网络每一层输出的特征图（feature map）上的像素点映射回输入图像上的区域大小）和基于全连接条件随机场（Fully Connected CRF）</li><li>v2：空洞空间金字塔池化（Atros Spatial Pyramid Pooling，ASPP）</li><li>v3：对ASPP进行了进一步的优化，如BN（Batch     Normalization，批归一化，加快了模型的收敛速度）操作、</li></ul><p>Multi-Grid策略（在一个block中连续使用多个不同扩张率的空洞卷积，为了解决空洞卷积可能会产生的gridding问题，即在高层使用的扩张率变大时，它对输入的采样会变得很稀疏，进而导致丢失一些局部信息）</p><ul><li>v3+：仿照U-Net的结构添加了一个向上采样的解码器模块，用来优化边缘的精度</li></ul><h4 id="RefineNet"><a href="#RefineNet" class="headerlink" title="RefineNet"></a>RefineNet</h4><ul><li><p>一种多路径强化网络。RefineNet的显式的利用了下采样过程的所有信息，使用远程残差连接来实现高分辨率的预测。此时，浅层的完善特征可以直接的用于强化高级的语义特征。</p></li><li><p>通过使用带残差连接的同态映射构建所有组件，梯度能够在短距离和长距离传播，从而实现端到端的训练；</p></li><li><p>提出了链式残差池化模块，从较大的图像区域俘获背景上下文。使用多个窗口尺寸获得有效的池化特征，并使用残差连接和学习到的权重融合到一起。</p></li><li><p>三个核心模块：</p></li><li><ul><li>残差卷积模块RCU（Residual Conv Unit）：原始ResNet中卷积单元的简化版本</li></ul></li><li><ul><li>多分辨率融合模块（Multi-Resolution fuse）：将所有路径上的输入通过这个模块融合到高分辨率特征图上</li><li>链式残差池化模块（Chained Residual Pooling）：为了针对大的图像区域捕获其上下文背景信息</li></ul></li></ul><h4 id="HRNet"><a href="#HRNet" class="headerlink" title="HRNet"></a>HRNet</h4><p>逐个像素分类，具体略~</p><h1 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h1><ul><li><ul><li>把某类别的区分出来</li><li>常用算法模型：见共性部分</li></ul></li></ul><h1 id="实例分割"><a href="#实例分割" class="headerlink" title="实例分割"></a>实例分割</h1><ul><li><ul><li>把某类别的不同实例区分出来</li><li>常用算法模型（具体略~）：Mask R-CNN、PANet、SOLO</li></ul></li></ul><h1 id="全景分割"><a href="#全景分割" class="headerlink" title="全景分割"></a>全景分割</h1><ul><li><ul><li>把所有类别的所有实例都区分出来</li><li>常用算法模型（具体略~）：Panoptic FCN、UPSNet</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>1.图像分割</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征提取</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>共性：边缘、角、区域</li><li>主要有两种方法：传统图像特征提取方法和深度学习方法。</li></ul><h1 id="特征提取子"><a href="#特征提取子" class="headerlink" title="特征提取子"></a>特征提取子</h1><h2 id="SIFT（Scale-invarialt-feature-transform，尺度不变特征变换）"><a href="#SIFT（Scale-invarialt-feature-transform，尺度不变特征变换）" class="headerlink" title="SIFT（Scale-invarialt feature transform，尺度不变特征变换）"></a>SIFT（Scale-invarialt feature transform，尺度不变特征变换）</h2><p>构建DOG尺度空间、关键点搜索和定位、方向赋值、 关键点描述子的生成</p><h2 id="HOG-Histogram-of-Oriented-Gradient，方向梯度直方图"><a href="#HOG-Histogram-of-Oriented-Gradient，方向梯度直方图" class="headerlink" title="HOG(Histogram of Oriented Gradient，方向梯度直方图)"></a>HOG(Histogram of Oriented Gradient，方向梯度直方图)</h2><ol><li>灰度化；</li><li>采用Gamma校正法对输入图像进行颜色空间的标准化（归一化），目的是调节图像的对比度，降低图像局部的阴影和光照变化所造成的影响，同时可以抑制噪音的干扰；</li><li>计算图像每个像素的梯度（包括大小和方向），主要是为了捕获轮廓信息，同时进一步弱化光照的干扰；</li><li>将图像划分成小cells（例如66像素&#x2F;cell）；</li><li>统计每个cell的梯度直方图（不同梯度的个数），即可形成每个cell的descriptor；</li><li>将每几个cell组成一个block（例如33个cell&#x2F;block），一个block内所有cell的特征descriptor串联起来便得到该block的HOG特征descriptor。</li><li>将图像image内的所有block的HOG特征descriptor串联起来就可以得到该image（你要检测的目标）的HOG特征descriptor了。这个就是最终的可供分类使用的特征向量了。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>SURF：把SIFT中的某些运算作了简化</li><li>ORB：运行时间远优于SIFT与SURF，可用于实时性特征检测。方向FAST特征点检测→BRIEF特征描述</li><li>LBP(Local Binary Pattern，局部二值模式)</li><li>Haar-like：使用3种类型4种形式的特征：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。</li><li>Harris：一种角点特征描述子，对应于物体的拐角</li></ul><h1 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h1><p>降维：主成分分析、奇异值分解、线性判别分析；</p><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>0-2基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>频率域增强</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E9%A2%91%E7%8E%87%E5%9F%9F%E5%A2%9E%E5%BC%BA/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E9%A2%91%E7%8E%87%E5%9F%9F%E5%A2%9E%E5%BC%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="平滑"><a href="#平滑" class="headerlink" title="平滑"></a><strong>平滑</strong></h1><p>理想高通滤波器、Butterworth低通滤波器、指数低通滤波器、梯形低通滤波器</p><p>Butterworth：</p><p> <img src="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E9%A2%91%E7%8E%87%E5%9F%9F%E5%A2%9E%E5%BC%BA/1692618708337.jpg" alt="1692618708337"></p><h1 id="锐化"><a href="#锐化" class="headerlink" title="锐化"></a><strong>锐化</strong></h1><p>同上，其中Butterworth：</p><p><img src="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E9%A2%91%E7%8E%87%E5%9F%9F%E5%A2%9E%E5%BC%BA/1692618721614.jpg" alt="1692618721614"></p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>0-2基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滤波</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E6%BB%A4%E6%B3%A2/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E6%BB%A4%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>含降噪、模糊&#x2F;平滑、边缘检测</p></li><li><p>本质为空间域的平滑、锐化等操作</p></li></ul><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E6%BB%A4%E6%B3%A2/1692618507096.jpg" alt="1692618507096"></p><p>高通：外白内黑，重视高频（空间域、频域）区域，去除低频区域；低通：外黑内白，提取低频部分。</p><h1 id="低通-x2F-均值滤波"><a href="#低通-x2F-均值滤波" class="headerlink" title="低通&#x2F;均值滤波"></a>低通&#x2F;均值滤波</h1><p>一般的均值滤波不能很好地保留图像细节</p><h2 id="模糊-x2F-平滑"><a href="#模糊-x2F-平滑" class="headerlink" title="模糊&#x2F;平滑"></a>模糊&#x2F;平滑</h2><ul><li><p>高斯滤波&#x2F;模糊：随着距离模板中心的增大而系数减少</p></li><li><p>方框&#x2F;盒子滤波：比均值滤波多一个参数。此参数为normalize，当 normalize&#x3D;True时，与均值滤波结果相同，normalize&#x3D;False，表示对加和后的结果不进行平均操作，大于255的使用255表示。</p></li><li><p>双边滤波：</p></li><li><ul><li>比高斯滤波多了一种掩膜，两种掩膜都是套用高斯分布公式得到的</li><li>是一种非线性的滤波方法，是结合图像的空间邻近度和像素值相似度的一种折中处理</li></ul></li><li><p>中值滤波：是一种非线性数字滤波器技术，是处理椒盐噪声的常用降噪算法。</p></li></ul><h2 id="降-x2F-去噪"><a href="#降-x2F-去噪" class="headerlink" title="降&#x2F;去噪"></a>降&#x2F;去噪</h2><p>同上~！</p><h1 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a><strong>高通滤波</strong></h1><p>边缘检测&#x2F;锐化：</p><ul><li><p>Sobel算子：一阶，对灰度渐变和噪声较多的图像处理效果较好，但是Sobel算子对边缘定位不是很准确</p></li><li><p>Roberts算子：一阶，检测垂直边缘的效果好于斜向边缘，定位精度高，对噪声敏感,无法抑制噪声的影响。</p></li><li><p>Prewitt算子：一阶，利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用。两个方向模板一个检测水平边缘，一个检测垂直边缘。</p></li><li><p>Laplacian算子：</p></li><li><ul><li><p>二阶，对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区</p></li><li><p>$$<br>\nabla^2 f&#x3D;\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2}<br>$$</p></li></ul></li><li><p>Canny算子：</p></li><li><ul><li>最好的边缘检测算子（滤波类）</li><li>去噪→梯度计算→非极大值抑制（NMS）→迟滞阈值化</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>0-2基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像增强</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>点运算：</p><ul><li>灰度变换增强：线性灰度变换、分段线性灰度变换、非线性灰度变换</li><li>直方图增强：直方图统计、直方图均衡化</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>0-2基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图形变换</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-2%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><ul><li>几何变换：图像平移、旋转、镜像、转置；</li><li>尺度变换：图像缩放、插值算法（最近邻插值、线性插值、双三次插值）；</li><li>仿射变换</li><li>透视变换</li><li>空间域与频域间变换：由于图像阵列很大，直接在空间域中进行处理，涉及计算量很大。因此，有时候需要将空间域变换到频域进行处理。例如：傅立叶变换、沃尔什变换、离散余弦变换等间接处理技术，将空间域的处理转换为频域处理，不仅可减少计算量，而且可获得更有效的处理（如傅立叶变换可在频域中进行数字滤波处理）。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>0-2基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习（DL）</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-1%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-1%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GAN（生成对抗网络）"><a href="#GAN（生成对抗网络）" class="headerlink" title="GAN（生成对抗网络）"></a>GAN（生成对抗网络）</h1><p>生成器和鉴别器“零和博弈”——相互收益&#x2F;损失直到达到最优化的平衡</p><h1 id="Mask-Fast-er-R-CNN"><a href="#Mask-Fast-er-R-CNN" class="headerlink" title="[Mask][Fast[er]] R-CNN"></a>[Mask][Fast[er]] R-CNN</h1><ul><li><p>RPN (Region Proposal Network，区域生成网络)：用于生成候选区域(Region Proposal)，提升检测框的生成速度</p></li><li><p>R-CNN：</p></li><li><ul><li>基于Region的CNN</li><li>候选区域生成→CNN特征提取→SVM类别判断→位置精修</li><li>R-CNN的主要性能瓶颈在于需要对每个提议区域独立抽取特征。由于这些区域通常有大量重叠，独立的特征抽取会导致大量的重复计算。Fast R-CNN对R-CNN的一个主要改进在于只对整个图像做卷积神经网络的前向计算。</li></ul></li><li><p>Fast R-CNN：</p></li><li><ul><li>相比rcnn的不同处：在得到每个候选区域的feature map后，通过rol pooling 层来进行上采样操作对尺寸进行调整以便时输入模型最后使用的loss函数为multi-task loss，然后是把回归操作加入到cnn权重更新的过程中去。</li><li>step1: 同样是寻找一个在imagenet上训练过的预训练cnn模型(VGG16)</li></ul></li></ul><p>step2: 与rcnn一样，通过selective search在图片中提取2000个候选区域</p><p>step3: 将一整个图片都输入cnn模型中，提取到图片的整体特征(共享卷积特征)</p><p>step4: 把候选区域映射到上一步cnn模型提取到的feature map里</p><p>step5: 采用rol pooling层对每个候选区域的特征进行上采样,从而得到固定大小的feature map</p><p>step6: 根据softmax loss和smooth l1 loss对候选区域的特征进行分类和回归调整的过程，</p><p>回归操作是对于框调整所使用的bou b reg来训练。</p><ul><li><p>Faster R-CNN：</p></li><li><ul><li>最大的亮点之处是faster-rcnn把获取feature      map，候选区域选取，回归和分类等操作全部融合在一个深层网络当中，效率较前两种提升了很多。</li><li>RPN经过训练后直接产生Region Proposal，无需单独产生Region Proposal。</li><li>RPN后接ROI Pooling和分类层、回归层，同Fast R-CNN</li></ul></li><li><p>Mask R-CNN：略~</p></li><li><p>在Faster R-CNN基础上进行了拓展，通过增加一个分支（应用于RoI，即感兴趣的区域上的全连接网络）来并行进行像素级目标分割</p></li><li><ul><li>最大的亮点之处是faster-rcnn把获取feature      map，候选区域选取，回归和分类等操作全部融合在一个深层网络当中，效率较前两种提升了很多。</li><li>RPN经过训练后直接产生Region Proposal，无需单独产生Region Proposal。</li><li>RPN后接ROI Pooling和分类层、回归层，同Fast R-CNN</li></ul></li></ul><h1 id="Alexnet"><a href="#Alexnet" class="headerlink" title="Alexnet"></a>Alexnet</h1><ul><li>1个输入层、5个卷积层、2个全连接层</li><li>Dropout</li><li>重叠池化（使用最大池化层）</li></ul><h1 id="Z-F-Net"><a href="#Z-F-Net" class="headerlink" title="Z-F Net"></a>Z-F Net</h1><p>微调的AlexNet，反卷积&amp;反池化</p><h1 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h1><ul><li>相比AlexNet的一个改进是使用了3个3x3卷积核来代替7x7卷积核，使用了2个3x3卷积核来代替55卷积核，这样做的主要目的是在保证具有相同感知野的条件下，提升了网络的深度，在一定程度上提升了神经网络的效果。</li><li>VGGNet的结构非常简洁，整个网络都使用了同样大小的卷积核尺寸（3x3）和最大池化尺寸（2x2）。</li></ul><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Inception-x2F-GoogleNet-V1-4-ResNet"><a href="#Inception-x2F-GoogleNet-V1-4-ResNet" class="headerlink" title="Inception&#x2F;GoogleNet V1~4 [-ResNet]"></a>Inception&#x2F;GoogleNet V1~4 [-ResNet]</h1><ul><li>Inception模块的核心思想就是将不同的卷积层通过并联的方式结合在一起，经过不同卷积层处理的结果矩阵在深度这个维度拼接起来，形成一个更深的矩阵。Inception模块可以反复叠堆形成更大的网络，它可以对网络的深度和宽度进行高效的扩充，在提升深度学习网络准确率的同时防止过拟合现象的发生。</li><li>一层block就包含1x1卷积，3x3卷积，5x5卷积，3x3池化(使用这样的尺寸不是必需的，可以根据需要进行调整)。这样，网络中每一层都能学习到“稀疏”（3x3、5x5）或“不稀疏”（1x1）的特征，既增加了网络的宽度，也增加了网络对尺度的适应性；</li><li>通过deep concat在每个block后合成特征，获得非线性属性。</li><li>v2&amp;3：将 5×5 的卷积分解为两个 3×3 的卷积等</li><li>v4：池化的顺次连接（网络的前几层）替换为stem模块（具体略），来获得更深的网络结构。</li><li>将Inception     架构和残差连接(Residual)结合起来，显著加速 Inception 的训练，有效解决梯度消失&#x2F;爆炸的网络结构</li></ul><h2 id="FCN（全卷积网络）"><a href="#FCN（全卷积网络）" class="headerlink" title="FCN（全卷积网络）"></a>FCN（全卷积网络）</h2><ul><li>把CNN最后的全连接层换成卷积层，采用反卷积层对最后一个卷积层的feature map进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素分类</li><li>跳层：结合跨越多层的结果</li></ul><h1 id="DenseNet"><a href="#DenseNet" class="headerlink" title="DenseNet"></a>DenseNet</h1><ul><li>池化层、增长率、瓶颈层、压缩</li><li>通道合并</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>0-1基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多模态</title>
    <link href="/2023/08/21/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%A4%9A%E6%A8%A1%E6%80%81/%E5%A4%9A%E6%A8%A1%E6%80%81/"/>
    <url>/2023/08/21/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%A4%9A%E6%A8%A1%E6%80%81/%E5%A4%9A%E6%A8%A1%E6%80%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><ul><li><ul><li>本质：[图像&#x2F;视频]←→[文字←→语音]的排列组合</li><li>其他分支：多模态检索→表示学习→融合→生成→交互</li></ul></li></ul><h1 id="图像描述（自动字幕生成、你画我猜）"><a href="#图像描述（自动字幕生成、你画我猜）" class="headerlink" title="图像描述（自动字幕生成、你画我猜）"></a>图像描述（自动字幕生成、你画我猜）</h1><p>CNN&#x2F;Faster R-CNN+[双层]LSTM[+Attention]、Transformer+LSTM、GAN</p><h1 id="VQA（视觉问答）-amp-视觉对话"><a href="#VQA（视觉问答）-amp-视觉对话" class="headerlink" title="VQA（视觉问答）&amp;视觉对话"></a>VQA（视觉问答）&amp;视觉对话</h1><p>略~</p><h1 id="图像生成（你说我画）"><a href="#图像生成（你说我画）" class="headerlink" title="图像生成（你说我画）"></a>图像生成（你说我画）</h1><p>可参考笔记较少，暂时略~</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>12.多模态</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习（ML）</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-1%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-1%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同NLP中机器学习部分：<a href="https://www.zuoyerumeng.site/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E9%99%A4%E5%A4%96%EF%BC%89/">机器学习（ML）</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>0-1基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像特征参数</title>
    <link href="/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-1%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E5%8F%82%E6%95%B0/"/>
    <url>/2023/08/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%EF%BC%88CV%EF%BC%89/0-1%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>分为四类：直观性特征、灰度统计特征、变换系数特征与代数特征。 </p></li><li><ol><li>几何特征（位置与方向、周长、面积、长轴与短轴、距离(欧式距离、街区距离、棋盘距离)）；</li><li>形状特征（几何形态分析（Blob分析）：矩形度、圆形度、不变矩、偏心率、多边形描述、曲线描述）；</li><li>幅值特征（矩、投影）；</li><li>直方图特征（统计特征）：均值、方差、能量、熵、L1范数、L2范数等；直方图特征方法计算简单、具有平移和旋转不变性、对颜色像素的精确空间分布不敏感等，在表面检测、缺陷识别有不少应用。</li><li>颜色特征（颜色直方图、颜色矩）</li><li>局部二值模式( LBP)特征：LBP对诸如光照变化等造成的图像灰度变化具有较强的鲁棒性，在表面缺陷检测、指纹识别、光学字符识别、人脸识别及车牌识别等领域有所应用。由于LBP 计算简单，也可以用于实时检测。</li><li>边缘</li><li>关键点</li><li>纹理特征</li></ol></li><li></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机视觉（CV）</category>
      
      <category>0-1基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉（CV）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文投稿&amp;发表</title>
    <link href="/2023/08/17/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E5%8F%91%E8%A1%A8/"/>
    <url>/2023/08/17/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E6%8A%95%E7%A8%BF%E5%8F%91%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>目标（优先顺序为从上到下）：</p><ul><li><p>评价指标：</p><ul><li>共性：地域级别（国家级&#x2F;省级&#x2F;…）</li><li>会议：<ul><li>h5指数</li><li>CCF会议等级</li></ul></li><li>期刊：<ul><li>影响因子&gt;2、CiteScore、h-指数&gt;5、SJR（SCImago期刊排名）、特征因子（Eigenfactor）&gt;1</li><li>是否为核心期刊（方法：核心期刊查询官网（上交）→知网查看具体信息→百度百科）→知网是否收录</li><li>SCI&#x2F;中科院几区</li></ul></li></ul></li><li><p>发表载体：会议&gt;期刊（AI领域）</p></li><li><p>语言：英文&gt;中文</p></li><li><p>（期刊：）出刊频率：若无刚需则频率越低越好，期刊有[半]年&#x2F;季&#x2F;[半]月&#x2F;…刊，会议一般为年会</p></li><li><p>领域专一性：NLP→AI→CS</p></li><li><p>审稿速度：看有无刚需，反正都越快越好~</p></li><li><p>价格：不能太离谱</p></li><li><p>（会议：）举办时间，看有无刚需、最近投稿是否合适</p></li><li><p>会议&#x2F;期刊检索顺序：会议&#x2F;期刊→英文&#x2F;中文→领域→查看其他目标中的考虑因素</p></li><li><p>国内核心期刊的四类（知网能查到前三个，第四个上科信所查）：北核（中文核心）、南核（C刊C扩）、CSCD、科技核心（统计源）</p></li><li><p>心仪NLP会议：NLPCC、CCL（Chinese Computational Linguistics Conference）</p></li><li><p>心仪NLP英文期刊：Journal of Logic, Language and Information、Natural Language Engineering</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读研</category>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文写作</title>
    <link href="/2023/08/17/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"/>
    <url>/2023/08/17/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="图表-amp-公式"><a href="#图表-amp-公式" class="headerlink" title="图表&amp;公式"></a>图表&amp;公式</h1><ul><li>图片用Fig（而不是Graph！）命名</li></ul><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul><li>研究背景→研究问题→研究方法→研究结论→论文结构</li><li>150~200字</li><li>过去式</li></ul><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li>研究背景简介10%（大背景5%&amp;小领域5%）→前人成果&amp;不足+研究动机&amp;目标（25%）→创新、意义&amp;优势（20%）→方法&amp;结果（25%）[→研究贡献（15%）→小结（5%）]</li><li>现在时</li></ul><h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><ul><li>前人成果（大类→小类，都按总分顺序）的解决点、优势&amp;不足，体现自己的创新&amp;价值</li></ul><h1 id="Foundamental"><a href="#Foundamental" class="headerlink" title="Foundamental"></a>Foundamental</h1><ul><li>三个层次：<br>- 从整体层面看到的模型效果<br>- 对模型涉及的数学原理的证明和解释<br>- 对模型每一个部分应用数学原理的具体结构实现。这一部分的灵活程度较大。</li><li>定义、理论与证明</li><li>数学证明部分：不要使用符号形式的因果关系谓词，而要把抽象的证明过程写做科研工作者可读的语言，比如使用hence等。</li><li>涉及模型的部分，要使用图示的方法阐述模型工作机理，尽量使得读者能够在图中获取到数据传递的全部信息。如果认为读者理解还有困难，需要使用一个例子描述，这个例子可以是写在所有理论知识之前的motivating example，也可以是是写在特定理论知识之后为了解释的例子illustrative example。</li></ul><h1 id="Materials-and-Method"><a href="#Materials-and-Method" class="headerlink" title="[Materials and ]Method"></a>[Materials and ]Method</h1><ul><li>前人用的A实现了α，我用的是A+B实现的α</li><li>前人用的A+B实现了α，我用的是A+C实现的α</li><li>前人用的A实现的α，我用A实现了β</li><li>对于α这个问题，前人有用A解决的，有用B解决的，有用C解决的，但是还没有很好的方法比较他们的优劣。我提出了一个度量指标，可以定量的比较A、B、C。</li><li>前人用A实现了α转化为β，我提出了个B可以使β转化α</li><li>前人用A、B、C只解决了α，是因为在β这个问题上面没有合适的数据集，我给β做了个新的数据集，经过调参和优化A、B、C也可以在β问题上面进行应用。</li><li>前人用A实现了α，另一个前人用B实现了β，我研究出一种方法，能够把A和B联合起来成为A+B的方法，这个方法能够解决α+β的大问题。</li></ul><h1 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h1><ul><li>设备平台（CPU&#x2F;GPU+服务器&#x2F;虚拟机&#x2F;本地主机+OS）</li><li>数据集、初始参数的选择</li><li>训练了多少个epoch，训练过程的损失值的变化等</li><li>实验部分需要大量的图表来展示自己的工作量和工作成果。<ul><li>定量实验：使用学界公认的一些定量指标，选取几个较为人常知的基准模型，通过实验比较这几个模型和你的模型的指标数，显示出自己做的工作有一定的提高。</li><li>消融实验：控制变量法<ul><li>英文时态：在陈述你的实验操作和看到的结果和表面现象时用过去时态，陈述不以人的意志为转移的规律、结论性的内容和图表内容解释一般使用现在时。</li></ul></li></ul></li></ul><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p>通常直接放在上一块Experiments里面~</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><ul><li>结论&amp;与前人结果的对比→创新性→优缺点（仍需解决&amp;改进的地方、与预期不一致的地方）→展望（延伸拓展的研究方向&amp;建议）</li><li>优点：鲁棒性、适应性（可转移性）、合理性、可行性</li><li>缺点：不稳定性、局限性、理想化（作了…假设）、数据少&#x2F;质量不够好</li></ul><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><ul><li>研究背景&amp;结果→与前人研究的比较→优缺点</li><li>英文时态：采用过去时态总结研究成果，采用现在时态表达研究结果的意义和对研究结果进行讨论和展望。</li></ul><h1 id="Acknowledgements"><a href="#Acknowledgements" class="headerlink" title="Acknowledgements"></a>Acknowledgements</h1><p>致谢，略~</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>略~</p><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><p>略~</p>]]></content>
    
    
    <categories>
      
      <category>读研</category>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文绘图</title>
    <link href="/2023/08/17/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%BB%98%E5%9B%BE/"/>
    <url>/2023/08/17/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E7%BB%98%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图表绘制：</p><ul><li><p>流程图：亿图图示（→PPT的SmartArt→Visio）</p></li><li><p>可供选择的图表类型：雷达图（替代饼状图）、环形图、散点图、气泡图、瀑布图</p></li></ul><p>数据可视化视图（除矩阵热力图、三维散点图）：FineBi&#x2F;Origin&#x2F;EXCEL（大数据的各种图）（→SPSS（大数据的基本图）→亿图图示（数据极少的各种图））</p><ul><li><p>自由发挥的关系图&#x2F;（偏艺术）图&#x2F;图表上色（&#x2F;示意图）：AI</p></li><li><p>（相关系数）矩阵热力图：（SPSSPro→SPSSAu→）Origin→Finebi→EXCEL+PPT&#x2F;OneNote</p></li><li><p>坐标曲线图：EXCEL（由点拟合二维曲线）→MATLAB（由点拟合三维曲线）→Origin（各种二&#x2F;三维曲线）（→Geogebra（各种二&#x2F;三维曲线）→**几何画板（二维f(x)））</p></li><li><p>词云图：Wordart（可以自定义形状）（→SPSSAu→FineBi）</p></li><li><p>三维散点图：Origin</p></li><li><p>地图：FineBi（热力图）→SPSS&#x2F;BDS&#x2F;EXCEL（三维）地图（色阶图）→EXCEL-Bing（饼图）（→亿景无忧地图（热力图））</p></li><li><p>*网络图：Gephi（大数据）→Graph Editor&#x2F;Graph（数据较少）</p></li><li><p>*物理示意图：亿图图示（简单图）→AI&#x2F;Axglyph（各种图）（精确图：AutoCAD）</p></li><li><p>等高线图：Origin</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读研</category>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对话系统（包括问答系统）</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F&amp;%E5%AF%B9%E8%AF%9D%EF%BC%88%E9%97%AE%E7%AD%94%EF%BC%89%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8C%85%E6%8B%AC%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F%EF%BC%89/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F&amp;%E5%AF%B9%E8%AF%9D%EF%BC%88%E9%97%AE%E7%AD%94%EF%BC%89%E7%B3%BB%E7%BB%9F/%E5%AF%B9%E8%AF%9D%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8C%85%E6%8B%AC%E9%97%AE%E7%AD%94%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h1><p>分为单轮、多轮对话两种</p><h2 id="任务型"><a href="#任务型" class="headerlink" title="任务型"></a>任务型</h2><p>包括问答型</p><ul><li>专家系统：特定领域</li><li>检索式：信息抽取→信息检索</li><li>社区问答：信息检索→答案抽取</li><li>知识库：语义分析→信息抽取→向量建模→表示学习</li></ul><h2 id="闲聊型"><a href="#闲聊型" class="headerlink" title="闲聊型"></a>闲聊型</h2><p>略～</p><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>MAP、MRR、分类问题的评价指标、机器翻译评价指标</p><h1 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h1><ul><li>预处理→召回→排序→决策</li><li>下面的DST、PL模块有时又合并称为DM（对话管理）模块，一般为基于统计、有限状态机（FSM）、神经网络</li></ul><h2 id="NLU（自然语言理解）"><a href="#NLU（自然语言理解）" class="headerlink" title="NLU（自然语言理解）"></a>NLU（自然语言理解）</h2><p>同意图分析、MRC</p><h2 id="DST（对话状态追踪）"><a href="#DST（对话状态追踪）" class="headerlink" title="DST（对话状态追踪）"></a>DST（对话状态追踪）</h2><p>根据整个对话历史记录跟踪用户的目标和相关细节，给Policy Learning模块提供输入</p><ul><li>基于人工规则：如有限状态机（Finite State Machine， FSM）需要人工预先定义好所有的状态和状态转移的条件， 使用分数或概率最高的NLU 模块解析结果进行状态更新。目前，大多数商业应用中的对话系统都使用基于人工规则的状态更新方法来选择最有可能的结果。该方法不需要训练集，且很容易将领域的先验知识编码到规则中，与其对应的是其相关参数需要人工制定且无法自学习， ASR 和 NLU 模块的识别错误没有机会得以纠正。这种限制促进了生成式模型和判别式模型的发展。</li><li>生成式模型：从训练数据中学习相关联合概率密度分布，计算出所有对话状态的条件概率分布作为预测模型。统计学学习算法将对话过程映射为一个统计模型，并引入强化学习算法来计算对话状态的条件概率分布，例如贝叶斯网络、部分可观测马尔可夫模型（POMDP）等。虽然生成式模型的效果优于基于人工规则的方法，且该方法可以自动进行数据训练，减少了人工成本。但是生成式模型无法从 ASR、 NLU 等模块     挖掘大量潜在信息特征，也无法精确建模特征之间的依赖关系。此外，生成式模型进行了不必要的独立假设，在实际应用中假设往往过于理想。</li><li>判别式模型：展现出更为有利的优势，它把 DST 当作分类任务，结合深度学习等方法进行自动特征提取，从而对对话状态进行精准建模。与生成式模型相比，判别式模型善于从 ASR、NLU 等模块提取重要特征，直接学习后验分布从而对模型进行化。</li></ul><h2 id="PL（策略学习）"><a href="#PL（策略学习）" class="headerlink" title="PL（策略学习）"></a>PL（策略学习）</h2><ul><li>以DST的输出作为输入，控制系统接下来的action。</li><li>适合强化学习</li><li>常见的对话策略：基于规则、规划、概率等</li></ul><h2 id="NLG"><a href="#NLG" class="headerlink" title="NLG"></a>NLG</h2><p>同文本生成分区~</p><h1 id="原理-amp-方法"><a href="#原理-amp-方法" class="headerlink" title="原理&amp;方法"></a>原理&amp;方法</h1><ul><li>一般为信息检索+信息抽取，同⑧分区~</li><li>具体模型：CNN、RNN、GAN、KG等</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>11.推荐系统&amp;对话（问答）系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐系统</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F&amp;%E5%AF%B9%E8%AF%9D%EF%BC%88%E9%97%AE%E7%AD%94%EF%BC%89%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F&amp;%E5%AF%B9%E8%AF%9D%EF%BC%88%E9%97%AE%E7%AD%94%EF%BC%89%E7%B3%BB%E7%BB%9F/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><ul><li>流量：CTR（PV、UV、曝光等的点击率）、CVR（转化率）</li><li>满意度：留存率、停留时间长、播放完成率</li></ul><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul><li>分类&amp;回归问题的评价指标</li><li>MAP：Top-N的平均准确率</li><li>MRR：平均倒数排名</li><li>覆盖率：表示系统能够推荐多少不同的物品</li><li>NDCG：<ul><li>归一化折损累计增益</li></ul></li></ul><h1 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h1><p>物料层→召回层→排序层（粗排→精排→重排）</p><h1 id="原理-amp-方法"><a href="#原理-amp-方法" class="headerlink" title="原理&amp;方法"></a>原理&amp;方法</h1><ul><li>冷启动（对于新用户、物品的推荐）：<ul><li>提供热门及多样性内容推荐。即使用统计的方法将最热门的物品进行推荐，越热门且品类丰富的内容被点击的可能性越大；</li><li>利用新用户基本信息关联到相关内容（利用领域、职位、工作年龄、性别和所在地等信息给用户推荐感兴趣或者相关的内容，如年龄-关联电影表、收入-关联商品类型表，性别-文章关联表等等）；</li><li>利用新物品的内容关联到相似物品，并对应相关用户。</li></ul></li><li>SVD（奇异值分解）：降维，从稀疏的用户偏好矩阵中提取有效信息</li></ul><h2 id="基于标签"><a href="#基于标签" class="headerlink" title="基于标签"></a>基于标签</h2><ul><li>统计每个用户最常用的标签；</li><li>对于每个标签，统计被打过这个标签次数最多的内容；</li><li>把用户的常用标签出现次数最多的内容推荐给这个用户。</li></ul><h2 id="基于内容"><a href="#基于内容" class="headerlink" title="基于内容"></a>基于内容</h2><ul><li>计算文本相似度、词权重（TF-IDF等）→词聚类</li><li>一般流程：<ul><li>给出物品表示：为每个物品抽取出一些特征来表示此物品，常用TF-IDF；</li><li>学习用户偏好：利用一个用户过去喜欢（及不喜欢）的物品的特征数据，来学习出此用户偏好，常用最近邻模型；</li><li>生成推荐列表：根据候选物品表示和用户偏好，为该用户生成其最可能感兴趣的       n 个物品。</li></ul></li><li>缺点：无法给用户推荐新类型物品、冷启动</li></ul><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="基于关联规则"><a href="#基于关联规则" class="headerlink" title="基于关联规则"></a>基于关联规则</h2><p>略~</p><h2 id="协同过滤算法（CF）"><a href="#协同过滤算法（CF）" class="headerlink" title="协同过滤算法（CF）"></a>协同过滤算法（CF）</h2><ul><li>缺点：</li></ul><p>1、依赖于准确的用户评分；</p><p>2、在计算的过程中，那些大热的物品会有更大的几率被推荐给用户；</p><p>3、冷启动问题。当有一名新用户或者新物品进入系统时，推荐将无从依据；</p><p>4、在一些item生存周期短（如新闻、广告）的系统中，由于更新速度快，大量item不会有用户评分，造成评分矩阵稀疏，不利于这些内容的推荐。</p><ul><li>UsrCF（基于用户的CF）：<ul><li>分析各个用户对item的评价（通过浏览记录、购买记录等）；</li><li>依据用户对item的评价计算得出所有用户之间的相似度；</li><li>选出与当前用户最相似的N个用户；</li><li>将这N个用户评价最高并且当前用户又没有浏览过的item推荐给当前用户。</li></ul></li><li>ItemCF（基于物品的CF）：<ul><li>类似于基于用户的 CF，将用户改为物品即可：</li><li>分析各个用户对item的浏览记录。</li><li>依据浏览记录分析得出所有item之间的相似度</li><li>对于当前用户评价高的item，找出与之相似度最高的N个item</li><li>将这N个item推荐给用户。</li></ul></li></ul><h2 id="基于知识推荐"><a href="#基于知识推荐" class="headerlink" title="基于知识推荐"></a>基于知识推荐</h2><p>两种基本类型是：基于约束的推荐和基于实例的推荐。</p><h2 id="基于图"><a href="#基于图" class="headerlink" title="基于图"></a>基于图</h2><ul><li>Deep Walk：图游走算法，在图中随机游走生成节点序列，再对这些序列用Word2Vec得到节点Embedding，用Embedding计算相似度，比如余弦相似度，将相似度排序后做推荐</li><li>Node2Vec：与Deep Walk的区别是多了控制游走方向的参数，可以控制模型优先宽度还是深度，即深度优先遍历（DFS）和宽度优先遍历（BFS）</li></ul><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="基于机器学习-amp-深度学习"><a href="#基于机器学习-amp-深度学习" class="headerlink" title="基于机器学习&amp;深度学习"></a>基于机器学习&amp;深度学习</h2><ul><li>回归类模型等，可结合MLP（多层感知机），使向量经过多次线性投影和非线性激活来增加拟合度</li><li>CNN、RNN、DeepFM&amp;A&#x2F;NFM、Wide&amp;Deep（LR逻辑回归+MLP）、GCN（图卷积网络）</li><li>DI[E]N&amp;DSIN（Deep [Session]      Interest      [Evolution] Network）：建立DIN网络，引入了一个attention机制来为给定目标item激活局部的历史行为</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>11.推荐系统&amp;对话（问答）系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地大语言模型（LLM）搭建</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89/%E6%9C%AC%E5%9C%B0%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89/%E6%9C%AC%E5%9C%B0%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h1><h2 id="内存计算"><a href="#内存计算" class="headerlink" title="内存计算"></a>内存计算</h2><p>模型数据规模NBillion，量化为int&#x2F;floatM：需内存（GPU显存、CPU内存视为一样）NM&#x2F;8GB</p><p>13B：GPU，CPU-int8（结合官方约15G）</p><p>7B：GPU-int4（官方最高5.5G，一般3G）,CPU-int8（7G）</p><h2 id="安装NVIDIA驱动"><a href="#安装NVIDIA驱动" class="headerlink" title="安装NVIDIA驱动"></a>安装NVIDIA驱动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get purge nvidia-* <span class="hljs-comment">#卸载现有NVIDIA版本</span><br>lsmod | grep nouveau <span class="hljs-comment">#检验自带驱动是否被成功禁用</span><br>ubuntu-drivers devices <span class="hljs-comment">#查看支持的驱动版本</span><br>sudo apt install nvidia-driver-525 <span class="hljs-comment">#安装相应版本</span><br>nvidia-smi <span class="hljs-comment">#测试</span><br></code></pre></td></tr></table></figure><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><ul><li>上官网，按照操作系统和版本，运行相应提供的命令行即可~（建议用local的runfile版本）</li><li>安装时去除勾选驱动driver的“X”</li></ul><h1 id="模型下载-amp-训练"><a href="#模型下载-amp-训练" class="headerlink" title="模型下载&amp;训练"></a>模型下载&amp;训练</h1><p>根据所给教程命令即可~</p><h1 id="指令-amp-参数微调"><a href="#指令-amp-参数微调" class="headerlink" title="指令&amp;参数微调"></a>指令&amp;参数微调</h1><ul><li><p>Fine-tuning：先在大规模语料上进行预训练，然后再在某个下游任务上进行微调，如BERT、T5；</p></li><li><p>PEFT （Parameter-Efficient     Fine-Tuning，参数高效性微调方法）：</p></li><li><ul><li><p>三种技术：</p></li><li><ul><li>蒸馏(distillation)：训练一个较小的模型来模仿一个较大的预训练模型的行为。预训练模型生成“教师”预测结果，然后用于训练较小的“学生”模型。通过这样做，学生模型可以从较大模型的知识中学习，而无需存储所有参数。</li><li>适配器训练(adapter training)：适配器是添加到预训练模型中的小型神经网络，用于特定任务的微调。这些适配器只占原始模型大小的一小部分，这使得训练更快，内存需求更低。适配器可以针对多种任务进行训练，然后插入到预训练模型中以执行新任务。</li><li>渐进收缩(progressive shrinking)：在fine-tuning期间逐渐减小预训练模型的大小。从一个大模型开始，逐渐减少参数的数量，直到达到所需的性能。这种方法可以产生比从头开始训练的模型性能更好的小型模型。</li></ul></li></ul></li><li><ul><li><p>PEFT库包含的四种方法：</p></li><li><ul><li><p>[Ada]LoRA（Low-Rank Adaptation of Large Language Models，大语言模型的低阶适应）：冻结（Freeze方法，对原始模型部分参数进行冻结操作，仅训练部分参数，以达到在单卡或不进行TP或PP操作，就可以对大模型进行训练）了预训练模型的参数，并在每一层decoder中加入dropout+Linear+Conv1d额外的参数。LoRA速度更快，并且使用更少内存。</p></li><li><p>P-Tuning：类似LoRA，依然是冻结LLM参数，利用多层感知机和LSTM对prompt进行编码，编码之后与其他向量进行拼接之后正常输入LLM。</p></li><li><p>Prompt Tuning：</p></li><li><ul><li>先选择某个通用的大规模预训练模型，然后为具体的任务生成一个prompt模板以适应大模型进行微调，如GPT-3</li><li>固定预训练参数，为每一个任务额外添加一个或多个embedding，之后拼接query正常输入LLM，并只训练这些embedding。</li></ul></li><li><p>Prefix Tuning：类似Prompt Tuning，还是固定预训练参数，但除为每一个任务额外添加一个或多个embedding之外，利用多层感知编码prefix，注意多层感知机就是prefix的编码器，不再像prompt tuning继续输入LLM</p></li></ul></li></ul></li><li><p>Instruction-tuning：仍然在预训练语言模型的基础上，先在多个已知任务上进行微调（通过自然语言的形式），然后再推理某个新任务上进行zero-shot。</p></li><li><ol><li>监督学习</li><li>奖励模型（KL惩罚）</li><li>微调</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>10.大语言模型（LLM）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现有LLM整理</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89/%E7%8E%B0%E6%9C%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89%E6%95%B4%E7%90%86/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89/%E7%8E%B0%E6%9C%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="性能测评"><a href="#性能测评" class="headerlink" title="性能测评"></a>性能测评</h1><p>下图综合能力得分为分类能力、信息抽取能力、阅读理解能力三者得分的平均值。</p><p><img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89/%E7%8E%B0%E6%9C%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89%E6%95%B4%E7%90%86/1692194181839.jpg" alt="1692194181839"></p><ul><li><p>GPT（Generative Pre-Trained Transformer）：改进的Transformer</p></li><li><p>BERT（Bidirectional Encoder Representation from Transformers，双向Transformer的、预训练的Encoder）</p></li><li><p>T5（Text-to-Text Transfer Transformer）</p></li></ul><h1 id="开源榜单"><a href="#开源榜单" class="headerlink" title="开源榜单"></a>开源榜单</h1><ul><li><p>国内：BELLE-Llama2-13B、ChatGLM[2]-6&#x2F;130B、Baichuan-7&#x2F;13B、Chinese-LLaMA-Alpaca、[、MOSS]</p></li><li><p>国外：Vicuna</p></li></ul><h1 id="模型基础"><a href="#模型基础" class="headerlink" title="模型基础"></a>模型基础</h1><p>OPT、BLOOM、LLaMA、GLM（中文友好）</p><h1 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h1><p><img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89/%E7%8E%B0%E6%9C%89%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88LLM%EF%BC%89%E6%95%B4%E7%90%86/1692194208959.jpg" alt="1692194208959"></p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>10.大语言模型（LLM）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文本生成</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90/%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90/%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>同机器翻译的评价指标</p><h1 id="原理-amp-方法"><a href="#原理-amp-方法" class="headerlink" title="原理&amp;方法"></a>原理&amp;方法</h1><h2 id="规则模板"><a href="#规则模板" class="headerlink" title="规则模板"></a>规则模板</h2><ul><li><ul><li>需要人为设定规则模板，对用户输入进行回复。</li><li>优点：实现简单，无需大量标注数据；回复效果可控、稳定。</li><li>不足：如果需要回复大量问题，则需要人工设定大量模板，人力工作量大；使用规则模板生成的回复较为单一，多样性低。</li><li>常用方法：AIML语言</li></ul></li><li><ul><li></li></ul></li></ul><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><ul><li><p>Markov：</p></li><li><ul><li>通常使用统计语言模型对句子进行建模。语言模型将句子视为序列字符串，对句子中单词的概率分布进行建模。</li></ul></li><li><ol><li>将语料集中单句样本进行tri-gram划分；</li><li>构建词典，以前两个词作为key，后一个单词作为value，统计相同的key可接的value值，并将value依据降序排序；</li><li>设定起始词，采用贪心策略，根据起始词自动依据key选择出现概率最大的value作为当前的输出。</li></ol></li><li></li></ul><h2 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h2><ul><li><ul><li><p>Encoder-Decoder结构，常用Transformer、[char-]RNN、LSTM、VAE</p></li><li><ul><li>VAE：与GAN齐名的无监督学习复杂分布的方法。与GAN类似，它基于一个数学事实：对于一个目标概率分布，给定任何一种概率分布，总存在一个可微的可测函数，将其映射到另一种概率分布，使得这种概率分布与目标的概率分布任意的接近。换句话说，两种方法的目标都是假设服从某些常见的变换，进而得到从隐变量z生成目标数据x的模型，实现分布之间的变换，只是在实现方法有所不同（运用了KL散度等）。</li></ul></li><li><p>优点：无需规则，能自动从已有对话文本中学习如何生成文本。</p></li><li><p>不足：生成效果不可控，训练好的模型更像是一个“黑盒”，也无法干预模型的生成效果；倾向生成万能回复，如“好的”、“哈哈”等，所以多样性与相关性低。</p></li><li><p>训练模型：</p></li><li><ol><li>将训练数据整理成（segment，next_char）的组合</li><li>用 one-hot 将字符编码，segment 编码成 lv 的向量，next_char 编码成 v1 的向量，l 是输入长度，v 是字符总个数</li><li>构建一个网络，输入是 lv 的矩阵，然后通过 RNN 或者 LSTM 捕捉文本特征，然后将最后的特征进行全连接层进行转换，全连接层用 Softmax 作为激活函数，最后输出一个 v1 的概率分布，下一个字符的选择方式可以看上面的内容。</li></ol></li><li><p>生成文本：</p></li><li><ul><li>一般在已经训练好模型的情况下，我们要输入字符串当作种子输入，让其作为我们接下来要生成文本的开头，然后不断重复下面的过程：</li></ul></li><li><ol><li>把输入使用       one-hot 向量表示，然后输入到模型中     </li><li>在神经网络输出的概率分布中选取一个字符，作为预测的下一个字符</li><li>将预测的字符拼接到之前的文本后，选取新的输入文本</li></ol></li></ul></li></ul><h2 id="检索模型"><a href="#检索模型" class="headerlink" title="检索模型"></a>检索模型</h2><p>利用文本检索与排序技术从问答库中挑选合适的回复。</p><ul><li>优点：由于数据来源于已经生成好的回复，或是从已抓取的数据得到的回复，所以语句通顺性高，万能回复少；</li><li>不足：不能生成新的回复文本，只能从问答库中得到文本进行回复；当检索或排序时，可能只停留在表面的语义相关性，难以捕捉真实含义。</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>09.文本生成</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息抽取</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>关键词&#x2F;句提取<ul><li>关键词：TF-IDF、TextRank（PageRank在文本中的应用）</li><li>关键句：BM25（TF-IDF的改进，从单个词语变成query的词语串）、TextRank</li></ul></li></ul><h1 id="实体抽取"><a href="#实体抽取" class="headerlink" title="实体抽取"></a><strong>实体抽取</strong></h1><p>就是NER（命名实体识别）！</p><h1 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a><strong>关系抽取</strong></h1><ul><li>人工构造语法和语义规则、统计机器学习、以及面向开放域的关系抽取技术等</li><li>方法：<ul><li>人工构造语法和语义规则（模式匹配）</li><li>统计机器学习方法</li><li>基于特征向量或核函数的有监督学习方法</li><li>研究重点转向半监督和无监督：<ol><li>Bootstrapping</li><li>Distant supervision</li><li>Unsupervised        learning from the web</li></ol></li><li>开始研究面向开放域的信息抽取方法</li><li>将面向开放域的信息抽取方法和面向封闭领域的传统方法结合</li></ul></li></ul><h1 id="属性抽取"><a href="#属性抽取" class="headerlink" title="属性抽取"></a><strong>属性抽取</strong></h1><ul><li>目标是从不同信息源中采集特定实体的属性信息，例如针对某个公众人物，可以从网络公开信息中得到其昵称、生日、国籍、教育背景等信息。</li><li>方法：<ul><li>将实体的属性视作实体与属性值之间的一种名词性关系，将属性抽取任务转化为关系抽取任务。</li><li>基于规则和启发式算法，抽取结构化数据</li><li>基于百科类网站的半结构化数据，通过自动抽取生成训练语料，用于训练实体属性标注模型，然后将其应用于对非结构化数据的实体属性抽取。</li><li>采用数据挖掘的方法直接从文本中挖掘实体属性和属性值之间的关系模式，据此实现对属性名和属性值在文本中的定位。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>07.信息抽取&amp;检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息检索</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>同分类问题~</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul><li><p>倒排索引：如果事先通过非线性扫描方式，给文档建立文档关联矩阵（词项与文档的共现矩阵），当碰到更大数据集时，占用空间会非常的大，矩阵也非常系数，此时，就需要倒排索引。倒排索引用来缩小计算搜索的范围。倒排索引针对每一个词项，存储所有包含这个词项的文档的列表，文档列表由文档的序列号docID来组成。应当使用可变长度的记录列表（动态数组或者链表），并且，每一个文档列表按照docID排列。倒排索引就是利用词项（key）与该词项对应的文档列表（value）来构建词项字典。（排序时先按照词项排序，每个词项再按照docID排序）</p></li><li><ul><li><p>空间优化方法-Variable Byte Compression：略~</p></li><li><p>搜索算法-WAND（Weak and）：</p></li><li><ul><li>用最大堆存储</li></ul></li><li><ol><li>将query进行分词q i q_iqi</li><li>得到每个q i q_iqi的Max contribution</li><li>得到每个q i q_iqi的倒排索引</li><li>利用指针遍历Doc，计算query对Doc的最大贡献，如果最大贡献比存下来的都小，则抛弃，否则，计算query与Doc的相似度，然后入堆（仍然有可能比最小值还小）</li></ol></li></ul></li></ul><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="基于-语法-规则"><a href="#基于-语法-规则" class="headerlink" title="基于[语法]规则"></a>基于[语法]规则</h2><p>略~</p><h2 id="基于神经网络"><a href="#基于神经网络" class="headerlink" title="基于神经网络"></a>基于神经网络</h2><p>略~</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>07.信息抽取&amp;检索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识更新</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a><strong>内容</strong></h1><p>从逻辑上看，知识库的更新包括概念层的更新和数据层的更新。</p><ul><li>数据层更新：主要是新增或更新实体、关系和属性值，对数据层进行更新需要考虑数据源的可靠性、数据的一致性（是否存在矛盾或冗余等问题）等多方面因素。</li><li>模式层更新：指新增数据后获得了新的模式，需要自动将新的模式添加到知识库的模式层中。对于概念层的更新，需要借助专业团队进行人工审核。</li></ul><h1 id="方式"><a href="#方式" class="headerlink" title="方式"></a><strong>方式</strong></h1><p>知识图谱的内容更新有２种方式：数据驱动下的全面更新和增量更新。</p><ul><li>全面更新：指以更新后的全部数据为输入，从零开始构建知识图谱。这种方式比较简单，但资源消耗大，而且需要耗费大量人力资源进行系统维护。</li><li>增量更新：指以当前新增数据为输入，向现有知识图谱中添加新增知识。这种方式资源消耗小，但目前仍需要大量人工干预（定义规则等），因此实施起来十分困难。</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>08.知识图谱（KG）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识加工/计算</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%8A%A0%E5%B7%A5/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%8A%A0%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>所解决的问题：通过信息抽取，可以从原始语料中提取出实体、关系与属性等知识要素。再经过知识融合，可以消除实体指称项与实体对象之间的歧义，得到一系列基本的事实表达。然而，事实本身并不等于知识，要想最终获得结构化、网络化的知识体系，还需要经历知识加工的过程。</p><h1 id="本体构建"><a href="#本体构建" class="headerlink" title="本体构建"></a><strong>本体构建</strong></h1><ul><li><p>在知识图谱中，本体位于模式层，用于描述概念层次体系，是知识库中知识的概念模板。</p></li><li><p>本体构建的方法有：</p></li><li><ul><li><p>手动构建：采用人工编辑的方式手动构建（借助本体编辑软件）</p></li><li><p>自动构建：采用计算机辅助，以数据驱动的方式自动构建，然后采用算法评估和人工审核相结合的方式加以修正和确认。自动化本体构建过程包含3个阶段：实体并列关系相似度计算、实体上下位关系抽取以及本体的生成。</p></li><li><ul><li>实体并列关系相似度：用于考察任意给定的2个实体在多大程度上属于同一概念分类的指标测度，相似度越高，表明这2个实体越有可能属于同一语义类别。所谓并列关系，是相对于纵向的概念隶属关系而言的，例如“中国”和“美国”作为国家名称的实体，具有较高的并列关系相似度；而“美国”和“手机”这2个实体，属于同一语义类别的可能性较低，因此具有较低的并列关系相似度。</li><li>实体上下位关系抽取：用于确定概念之间的隶属（IsA）关系，这种关系也称为上下位关系，例如，词组（导弹，武器）构成上下位关系，其中的“导弹”为下位词，“武器”为上位词。</li><li>本体生成：主要任务是对各层次得到的概念进行聚类，并对其进行语义类的标定（为该类中的实体指定1个或多个公共上位词）</li></ul></li></ul></li></ul><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a><strong>知识推理</strong></h1><p>从知识库中已有的实体关系数据出发，经过计算机推理，建立实体间的新关联，从而拓展和丰富知识网络。</p><p>（1）基于符号逻辑的推理——本体推理</p><ul><li>一阶谓词逻辑：建立在命题的基础上，在一阶谓词逻辑中，命题被分解为个体（individuals）和谓词（predication）两部分。例如对于人际关系可以采用一阶谓词逻辑进行推理，方法是将关系视为谓词，将人物视为变元，采用逻辑运算符号表达人际关系，然后设定关系推理的逻辑和约束条件，就可以实现简单关系的逻辑推理。</li><li>描述逻辑：是一阶谓词逻辑的子集，基于描述逻辑的知识库一般包含TBox（terminology box）与ABox（assertion box），其中，TBox是用于描述概念之间和关系之间的关系的公理集合，ABox是描述具体事实的公理集合。借助这2个工具，可以将基于描述逻辑的推理最终归结为ABox的一致性检验问题，从而简化并最终实现关系推理。</li><li>基于规则：例如利用专门的规则语言（如semantic web rule language, SWRL）对本体模型添加自定义规则进行功能拓展。</li></ul><p>（2）基于表运算（Tableaux）及改进的⽅法： FaCT++、 Racer、 Pellet Hermit等</p><p>（3）基于Datalog转换的⽅法如KAON、 RDFox等</p><p>（4）基于产⽣式规则的算法（如rete）： Jena 、 Sesame、 OWLIM等</p><p>（5）基于图结构和统计规则挖掘的推理：神经网络模型或PathRanking算法等</p><p>（6）基于路径排序学习⽅法(PRA， Path ranking Algorithm)</p><p>（7）基于关联规则挖掘⽅法(AMIE)</p><p>（8）基于知识图谱表示学习的关系推理：</p><ul><li>将实体和关系都表示为向量</li><li>通过向量之间的计算代替图的遍历和搜索来预测三元组的存在，由于向量的表示已经包含了实体原有的语义信息，计算含有⼀定的推理能⼒。</li><li>可应⽤于链接预测，基于路径的多度查询等</li></ul><p>（9）基于概率逻辑的方法</p><ul><li>概率逻辑学习有时也叫Relational Machine Learning (RML)，关注关系的不确定性和复杂性。</li><li>通常使用Bayesian networks or Markov networks</li></ul><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1><h1 id="质量评估"><a href="#质量评估" class="headerlink" title="质量评估"></a><strong>质量评估</strong></h1><ul><li>受现有技术水平的限制，采用开放域信息抽取技术得到的知识元素有可能存在错误（如实体识别错误、关系抽取错误等），经过知识推理得到的知识的质量同样也是没有保障的，因此在将其加入知识库之前，需要有一个质量评估的过程。</li><li>随着开放关联数据项目的推进，各子项目所产生的知识库产品间的质量差异也在增大，数据间的冲突日益增多，如何对其质量进行评估，对于全局知识图谱的构建起着重要的作用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>08.知识图谱（KG）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识融合</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E8%9E%8D%E5%90%88/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E8%9E%8D%E5%90%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>目标：通过信息抽取，实现了从非结构化和半结构化数据中获取实体、关系以及实体属性信息的目标，然而，这些结果中可能包含大量的冗余和错误信息，数据之间的关系也是扁平化的，缺乏层次性和逻辑性，因此有必要对其进行清理和整合。通过知识融合，可以消除概念的歧义，剔除冗余和错误概念，从而确保知识的质量。</p><h1 id="实体链接"><a href="#实体链接" class="headerlink" title="实体链接"></a><strong>实体链接</strong></h1><ul><li>指对于从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作。基本思想是首先根据给定的实体指称项，从知识库中选出一组候选实体对象，然后通过相似度计算将指称项链接到正确的实体对象。<ul><li>实体消歧：专门用于解决同名实体产生歧义问题的技术。<ul><li>分为基于词典、有&#x2F;无&#x2F;半监督</li></ul></li><li>共指消解：用于解决多个指称项（包括代词）对应于同一实体对象的问题。<ul><li>包括模式匹配、宾语冲突消解</li></ul></li></ul></li><li>一般流程：</li><li>从文本中通过实体抽取得到实体指称项</li><li>进行实体消歧和共指消解，判断知识库中的同名实体与之是否代表不同的含义以及知识库中是否存在其他命名实体与之表示相同的含义</li><li>在确认知识库中对应的正确实体对象之后，将该实体指称项链接到知识库中对应实体。</li></ul><h1 id="知识合并"><a href="#知识合并" class="headerlink" title="知识合并"></a><strong>知识合并</strong></h1><p>从第三方知识库产品或已有结构化数据获取知识输入。</p><ul><li>合并外部知识库：将外部知识库融合到本地知识库需要处理２个层面的问题：<ul><li>数据层融合，包括实体的指称、属性、关系以及所属类别等，主要的问题是如何避免实例以及关系的冲突问题，造成不必要的冗余</li><li>模式层融合，将新得到的本体融入已有的本体库中。</li></ul></li><li>合并关系数据库：可以采用资源描述框架（RDF）作为数据模型，业界和学术界将这一数 据转换过程称为RDB2RDF，其实质就是将关系数据库的数据换成RDF的三元组数据。</li><li>其他：除了关系型数据库之外，还有许多以半结构化方式存储（如XML,CSV,JSON等格式）的历史数据也是高质量的知识来源，同样可以采用RDF数据模型将其合并到知识图谱当中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>08.知识图谱（KG）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识表示</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>将现实世界中的各类知识表达成计算机可存储和计算的结构。</p></li><li><p>知识表示与建模：</p><ul><li><p>谓词逻辑表示法</p></li><li><p>框架表示法</p></li><li><p>基于语义网络的表示法</p></li><li><p>基于语义网的表示法</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>08.知识图谱（KG）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息抽取</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同信息抽取&amp;信息检索里的信息抽取部分：<a href="https://www.zuoyerumeng.site/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96">信息抽取</a></p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>08.知识图谱（KG）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识存储</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%AD%98%E5%82%A8/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%EF%BC%88KG%EF%BC%89/%E7%9F%A5%E8%AF%86%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>三元组：实体-关系-实体</li><li>Neo4j：一个高性能的NoSQL图形数据库，它将结构化数据存储在网络上而不是表中。</li><li>存储结构的两层：<ul><li>数据层：存储具体的数据</li><li>模式层：存储经过提炼的知识，通过本体库管理</li></ul></li><li>构建方式：<ul><li>自顶向下构建：指借助百科类网站等结构化数据源，从高质量数据中提取本体和模式信息，加入到知识库中。</li><li>自底向上构建：指借助一定的技术手段，从公开采集的数据中提取出资源模式，选择其中置信度较高的新模式，经人工审核之后，加入到知识库中。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>08.知识图谱（KG）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动摘要</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81/%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81/%E8%87%AA%E5%8A%A8%E6%91%98%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于结构"><a href="#基于结构" class="headerlink" title="基于结构"></a>基于结构</h1><p>类似于语法，略~</p><h1 id="基于统计"><a href="#基于统计" class="headerlink" title="基于统计"></a>基于统计</h1><p>略~</p><h1 id="基于阅读理解"><a href="#基于阅读理解" class="headerlink" title="基于阅读理解"></a>基于阅读理解</h1><p>结合语义分析，根据语义描述自动生成摘要</p><h1 id="基于信息抽取"><a href="#基于信息抽取" class="headerlink" title="基于信息抽取"></a>基于信息抽取</h1><p>完全依赖于领域知识</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>06.自动摘要</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读理解（MRC）</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%EF%BC%88MRC%EF%BC%89/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%EF%BC%88MRC%EF%BC%89/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%EF%BC%88MRC%EF%BC%89/%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3%EF%BC%88MRC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>评价指标：同分类问题~</li><li>任务：多项选择、完形填空、跨度提取（任务型填空）、自由问答</li><li>模块&amp;流程：Embedding、特征提取（RNN、CNN、Transformer）、上下文问题交互（单&#x2F;多向Attention机制、单&#x2F;多跳互动）、答案预测</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>05.阅读理解（MRC）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文本聚类</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%B8%8E%E8%81%9A%E7%B1%BB/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%B8%8E%E8%81%9A%E7%B1%BB/%E6%96%87%E6%9C%AC%E8%81%9A%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>本质上属于聚类问题</li></ul><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>同一般机器学习聚类问题的评价指标：</p><ul><li>外部指标：Jaccard系数、FM指数、[调整]Rand指数&#x2F;兰德系数、F值、调整&#x2F;标准互信息分数</li><li>内部指标：紧密度、戴维森堡丁指数、邓恩指数、轮廓系数</li></ul><h1 id="原理-amp-方法"><a href="#原理-amp-方法" class="headerlink" title="原理&amp;方法"></a>原理&amp;方法</h1><h2 id="基于ML（除DL）"><a href="#基于ML（除DL）" class="headerlink" title="基于ML（除DL）"></a>基于ML（除DL）</h2><p>K-Means聚类（基于划分）、DBSCANS&amp;密度聚类、层次聚类（凝聚式、分裂式）、神经网络、模糊聚类</p><h2 id="基于DL"><a href="#基于DL" class="headerlink" title="基于DL"></a>基于DL</h2><ul><li>常用模型：神经网络（前馈、反向&#x2F;BP）、TextCNN、TextRNN、Bi-LSTM和BERT</li><li>流程：文本相似度计算→聚类</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>04.文本分类&amp;聚类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文本分类（包括情感分析、意图分析）</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%B8%8E%E8%81%9A%E7%B1%BB/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%EF%BC%88%E5%8C%85%E6%8B%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%E3%80%81%E6%84%8F%E5%9B%BE%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%B8%8E%E8%81%9A%E7%B1%BB/%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%EF%BC%88%E5%8C%85%E6%8B%AC%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%E3%80%81%E6%84%8F%E5%9B%BE%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>本质上属于分类问题</li></ul><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>同一般机器学习分类问题的评价指标~</p><h1 id="原理-amp-方法"><a href="#原理-amp-方法" class="headerlink" title="原理&amp;方法"></a>原理&amp;方法</h1><p>对于具体的情感分析任务而言，还可以基于情感词典</p><h2 id="基于ML（除DL）"><a href="#基于ML（除DL）" class="headerlink" title="基于ML（除DL）"></a>基于ML（除DL）</h2><p>即基础理论分区-ML分页中的分类问题常见模型算法：</p><ul><li>传统算法：逻辑回归（0-1分类问题）、KNN（K邻近）、决策树、多层感知器、朴素贝叶斯（包括伯努利贝叶斯、高斯贝叶斯和多项式贝叶斯）、支持向量机SVM</li><li>集成学习算法：随机森林、AdaBoost、lightGBM、XGBoost、GBDT（梯度提升树）、CatBoost、ExtraTrees</li></ul><h2 id="基于DL"><a href="#基于DL" class="headerlink" title="基于DL"></a>基于DL</h2><p>神经网络（前馈、反向&#x2F;BP）、TextCNN、TextRNN、Bi-LSTM和BERT</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>04.文本分类&amp;聚类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文本纠错</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%96%87%E6%9C%AC%E7%BA%A0%E9%94%99/%E6%96%87%E6%9C%AC%E7%BA%A0%E9%94%99/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%96%87%E6%9C%AC%E7%BA%A0%E9%94%99/%E6%96%87%E6%9C%AC%E7%BA%A0%E9%94%99/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>在错误识别子任务中，常用的评测指标有：</p><ul><li>FAR（错误识别率）：没有笔误却被识别为有笔误的句子数&#x2F;没有笔误的句子总数</li><li>DA（识别精准率）：正确识别是否有笔误的句子数（不管有没有笔误）&#x2F;句子总数</li><li>DP（识别准确率）：识别有笔误的句子中正确的个数&#x2F;识别有笔误的句子总数</li><li>DR（识别找回率）：识别有笔误的句子中正确的个数&#x2F;有笔误的句子总数</li><li>DF1（识别F1值）：2 * DP * DR&#x2F; (DP + DR)</li><li>ELA（错误位置精准率）：位置识别正确的句子（不管有没有笔误）&#x2F;句子总数</li><li>ELP（错误位置准确率）：正确识别出笔误所在位置的句子&#x2F;识别有笔误的句子总数</li><li>ELR（错误位置召回率）：正确识别出笔误所在位置的句子&#x2F;有笔误的句子总数</li><li>ELF1（错误位置准确率）：2ELPELR &#x2F; (ELP+ELR) 在错误纠正任务中，常用的评测指标为：</li><li>LA位置精确率：识别出笔误位置的句子／总的句子</li><li>CA修改精确率：修改正确的句子／句子总数</li><li>CP修改准确率：修改正确的句子／修改过的句子</li></ul><h1 id="原理-amp-方法"><a href="#原理-amp-方法" class="headerlink" title="原理&amp;方法"></a>原理&amp;方法</h1><h2 id="基于规则"><a href="#基于规则" class="headerlink" title="基于规则"></a>基于规则</h2><ul><li><p>主要解决谐音字和形近字错误导致的文本纠错，具体处理流程：</p></li><li><ol><li>通过信息熵的方式进行新词发现，具体实现方法可以查阅<a href="https://zhuanlan.zhihu.com/p/583508749">【新词发现】</a>；</li><li>查找新词的困惑集，构建候选集；</li><li>运用N-Gram模型进行排序。</li></ol></li></ul><h2 id="基于深度学习"><a href="#基于深度学习" class="headerlink" title="基于深度学习"></a>基于深度学习</h2><ul><li><p>soft-masked bert模型<br>Spelling Error Correction with Soft-Masked BERT<br>1. Detection Network：负责预测句子中每个字错误的概率<br>2. Correct Network：负责将错字纠正成正确的字。<br>3. Soft Masking：Detection Network和Correction Network之间的桥梁，负责根据Detection Network的输出对原始句子embedding进行mask。</p></li><li><p>PLOME模型<br>PLOME: Pre-training with Misspelled Knowledge for Chinese Spelling Correction<br>• 专门针对中文文本纠错任务构建的预训练语言模型。创新点主要在于以下三点：<br>1. 在训练预训练语言模型时，采用基于语义混淆集的MASK策略。MASK策略主要是基于以下4种：字音混淆词替换(Phonic Masking)、字形混淆词替换(Shape Masking)、Random Masking(随机替换)、Unchanging(原词不变)。<br>2. 将拼音和笔画作为预训练语言模型以及模型微调的输入<br>3. 将字符预测任务和拼音预测任务作为预训练语言模型以及模型微调的训练目标。</p></li><li><p>Dynamic Connected Networks for Chinese Spelling Check<br>传统的纠错模型存在的问题：<br>1. BERT是一种非自回归模型，其认为各个字符之间的独立无关的，这样在进行文本纠错的时候，容易导致不连贯问题；<br>2. 认为CRF也可以构建输出的依赖，但是并不能应用于语言模型或CSC问题，其认为CSC更需要获得上下文信息，而不是更复杂的label与字符之间的关系。<br>基于上述问题，构建DCN模型：<br>1. 提出一个新的端到端的动态连接网络（DCN），可以避免非自回归模型下的CSC问题；<br>2. 提出简单有效的pinyin增强的候选生成器，将语音信息融入到候选生成中<br>Correcting Chinese Spelling Errors with Phonetic Pre-training<br>主要研究汉语拼写改正（CSC）。与字母语言不同，如果没有输入系统：例如汉语拼音（基于发音的输入方法）或自动语音识别（ASR）的帮助，汉字就不能被输入。因此，类似发音的字符打字经常出现在中文文本中。据Liuet ai(2010)称，网上83%的中文拼写错误来自拼音错误。</p></li><li><p>FastCorrect:<br>• Fast Error Correction with Edit Alignment for Automatic Speech Recognition<br>• FastCorrect是微软研究院开发的一个纠错模型，该模型在纠错类型上涵盖的范围更广，可以实现错别字纠错、漏字纠错、语法错误纠错等等。传统的采用GPT模型的自回归预测，处理效率太慢，采用bert模型的预训练模式进行MUSK位置预测，不能解决漏字的问题。该模型的基础模型为transformer，采用encoder-decoder模式进行预测。</p></li></ul><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><p>paddlenlp Taskflow一键预测、pycorrector</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>03.文本纠错</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器翻译</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><ul><li><ul><li><p>BLEU：基于精确率，如果机器翻译系统产生的结果和专业的人工翻译越接近，那么这个系统越好。</p></li><li><ul><li>ScareBLEU：使用相同的tokenize</li></ul></li><li><p>ROUGE[-N&#x2F;L&#x2F;W&#x2F;S]：基于召回率，N指的是N-gram，L指的是最长公共子序列，W为L的改进版，S允许Skip跳词</p></li><li><p>NIST：引入了每个n-gram的信息量(information) 的概念。</p></li><li><p>METEOR：兼顾准确率&amp;召回率，不使用高阶n-gram</p></li><li><p>TER：基于距离，看翻译结果经过多少次编辑操作能转化到标准答案，目的还是要使得评估标准更贴近人的判断。</p></li><li><p>chrF：是一种比较新的评估指标，主要是为了从字符级别对译文质量进行评估。</p></li><li><p>CIDEr：图像标注</p></li><li><p>SPICE：图像捕获</p></li></ul></li></ul><h1 id="原理＆方法"><a href="#原理＆方法" class="headerlink" title="原理＆方法"></a>原理＆方法</h1><h2 id="基于规则"><a href="#基于规则" class="headerlink" title="基于规则"></a>基于规则</h2><h3 id="直接式翻译"><a href="#直接式翻译" class="headerlink" title="直接式翻译"></a>直接式翻译</h3><p>进行词汇的更换</p><h3 id="转换式翻译"><a href="#转换式翻译" class="headerlink" title="转换式翻译"></a>转换式翻译</h3><ol><li>通过句法分析得到某种内部的结果化表达</li><li>变换句型</li><li>目标语言的形态生成</li></ol><h3 id="基于句法"><a href="#基于句法" class="headerlink" title="基于句法"></a>基于句法</h3><ul><li>每个句子可以用句法树描述结构，进而使用句子的层次结构信息进行建模</li><li>相比线性结构，树结构更容易处理大片段之间的关系，线性结构距离远的单词可能树结构中很近</li></ul><h3 id="基于层次短语"><a href="#基于层次短语" class="headerlink" title="基于层次短语"></a>基于层次短语</h3><ul><li><p>层次短语模型是一种基于翻译文法的模型，它把翻译问题转化为语言分析问题</p></li><li><p>使用短语和翻译模板进行双语同步生成</p></li><li><p>互译的句对可以被双语的层次结构同步生成出来</p></li><li><p>优点</p></li><li><ul><li>树结构可以作为对序列结构的一种补充，在句子中距离较远的两个单词，在树结构中可以很近</li><li>短语模型简单且灵活，同时，由于同步翻译文法可以对句子的层次结构进行表示，因此也能够处理一些较长距离的调序问题</li></ul></li><li><p>缺点</p></li><li><ul><li>层次短语规则没有语言学句法标记，很多规则并不符合语言学认知</li><li>层次短语系统中有大量的工程化约束条件</li><li>层次短语模型并不是一种“精细”的句法模型，当翻译需要复杂的结构信息时很困难</li><li>随着短语长度变长，短语在数据中会变得越来越低频，相关的统计特征也会越来越不可靠</li><li>基于短语的机翻系统仅使用了局部信息，短语内可以很好调序，但是短语间可能无法正确调序</li></ul></li></ul><h2 id="基于统计方法"><a href="#基于统计方法" class="headerlink" title="基于统计方法"></a>基于统计方法</h2><h3 id="基于扭曲度和繁衍率"><a href="#基于扭曲度和繁衍率" class="headerlink" title="基于扭曲度和繁衍率"></a>基于扭曲度和繁衍率</h3><p>下面IBM-1~5模型都基于词对齐假设（一个源单词最多只能对齐到一个目标单词），但汉译等英并不满足这一假设，解决方法：反向训练后，合并源语言单词，然后再正向训练。</p><h3 id="基于扭曲度"><a href="#基于扭曲度" class="headerlink" title="基于扭曲度"></a>基于扭曲度</h3><p>​• 扭曲度：相对顺序翻译产生的位置偏移，即目标语言词序相对源语言的扭曲程度<br>​• 模型：IBM-1、IBM-2<br>基于繁衍率<br>​• 繁衍率：每个目标语言单词生成源语言单词的个数<br>​• 模型：IBM-3~5</p><h3 id="统计机器翻译系统"><a href="#统计机器翻译系统" class="headerlink" title="统计机器翻译系统"></a>统计机器翻译系统</h3><p>略~</p><h3 id="贝叶斯规则"><a href="#贝叶斯规则" class="headerlink" title="贝叶斯规则"></a>贝叶斯规则</h3><p>略~</p><h2 id="基于神经网络"><a href="#基于神经网络" class="headerlink" title="基于神经网络"></a>基于神经网络</h2><ul><li><ul><li><p>Transformer（Encoder→中间层→Decoder）</p></li><li><p>多语言、双向翻译</p></li><li><p>知识蒸馏：</p></li><li><ul><li><p>使知识在模型之间迁移</p></li><li><p>目标是使得学生模型的预测分布尽可能逼近教师模型的预测分布，实际上在最小化教师模型和学生模型输出分布之间的交叉熵</p></li><li><p>通过教师模型构造伪数据，之后让学生模型从伪数据中学习</p></li><li><ul><li>1、固定教师模型，通过减少模型容量的方式设计学生模型，可以用Transformer-Big做教师模型，把解码器变为一层网络做学生模型</li><li>2、固定学生模型，通过模型继承的方式设计教师模型，融合多个不同初始化的Transformer-Big模型再学习一个Base模型</li></ul></li></ul></li></ul></li></ul><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><p>OpenNMT</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>02.机器翻译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语音识别</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h1><p>CER（字错误率）、WER（词错误率，最常用）、SER（句错误率）</p><h1 id="原理-amp-方法"><a href="#原理-amp-方法" class="headerlink" title="原理&amp;方法"></a>原理&amp;方法</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>声学特征(Acoustic Feature)：</p><ul><li>Waveform 最原始的声波信号 存在的问题是不同语音可能会存在类似的信号</li><li>Spectrogram 频谱图，声波信号进行DFT变换得到 在频域中，可以对不同语言的特征有较好的区分</li><li>filter bank 滤波器组 将频谱图通过不同的滤波器，进一步提取特征</li><li>MFCC 梅尔频率倒谱系数(Mel-Frequency Cepstral Coefficients) filter bank的结果取log之后再用DCT获得MFCC</li></ul><p>根据统计，目前用的最多的是filter bank</p><h2 id="中间模型"><a href="#中间模型" class="headerlink" title="中间模型"></a>中间模型</h2><p>模型的架构基本一致，分成三个部分：编码器(Encoder)、上下文(Context)、解码器(Decoder)</p><h3 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h3><p>主要模型有下面6种：</p><ul><li>Listen, Attend, and Spell (LAS)：LAS分成Listen, Attend,Spell三个部分，其中Listen对应编码器，Spell对应解码器，Attend是在Context中引入了注意力(Attend)机制。</li><li>Connectionist Temporal Classification (CTC)：根据单个h（解码器的一个输入），直接输出一个Token，从而实现实时性。它没有采用注意力机制，而是直接将输出的h单独输入进一个模型W，之后做Softmax来输出各Token的分布，取最大值输出。</li><li>RNA：由于CTC是每个输出都是独立的，因此即使除去空对象，输出很有可能还是会产生连续的Token，像口吃一样，一个朴素的想法是能不能把前面的输出再输入到下一时刻。 RNA就做了这点改进。</li><li>RNN Transducer (RNN-T)：RNA仍然会产生的一个问题是，有的音节对应的是两个Token，比如“th”，这样就比较难输出，RNN-T就做了改进，用来解决这一问题。</li><li>Neural Transducer：在RNN-T的基础上，加入了注意力机制。</li><li>Monotonic Chunkwise Attention (MoChA)：使Neural Transducer中的窗口动态变化。</li></ul><p>上面6种模型的本质：</p><ul><li>LAS: 就是 seq2seq</li><li>CTC: decoder 是     linear classifier 的     seq2seq</li><li>RNA: 输入一个东西就要输出一个东西的seq2seq</li><li>RNN-T: 输入一个东西可以输出出多个东西的 seq2seq</li><li>Neural Transducer: 每次输入一个window的     RNN-T</li><li>MoCha: window 移动伸缩自如的 Neural Transducer</li></ul><h3 id="Language-Model"><a href="#Language-Model" class="headerlink" title="Language Model"></a>Language Model</h3><p>不同于上一块的Models</p><ul><li><p>N-gram：略~</p></li><li><p>Continuous LM：</p><ul><li><p>借鉴到了推荐系统中的一个算法Matrix Factorization。</p></li><li><p>将不同的history和Vocabulary类似地进行表示，通过最小化损失L的方式，利用已知的信息来推算出合适的h和v向量。</p></li></ul></li></ul><h3 id="Fusion"><a href="#Fusion" class="headerlink" title="Fusion"></a>Fusion</h3><p>将Models和Language Model融合</p><ul><li><p>Shallow Fusion：将两个模型的输出取对数之后相加</p></li><li><p>Deep Fusion：</p><ul><li><p>将两个模型的隐藏层输入到一个新的神经网络中进行训练。</p></li><li><p>假如更换了Language Model，那个就需要重新进行训练。改进：在LM中，并不是直接输出隐藏层结果，而是输出下一层在SoftMax前的结果，这样的好处是更换LM后无需再次训练。</p></li></ul></li><li><p>Cold Fusiohn：结构上和Deep Fusion一模一样，区别在于Cold Fusion的LM在正式训练之前已经单独完成训练，个人猜测这个名称中Cold的意思就是将LM这样的变量提前变成常量。这样做的好处是可以加快LAS的训练速度，但同时问题是不能随便更换LM，否则要重复训练。</p></li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>Token是模型的输出形式，以上图<a href="https://cloud.tencent.com/product/asr?from_column=20065&from=20065">语音识别</a>为例，输出的text包含了N个Token，每个Token有V种符号 目前，Token主要有下面五种具体形式：</p><ul><li>Phoneme 音标，即语言的发音。 如果想要换算成文本，需要有个Lexicon(词典表)，例如cat ⟶ K AE T</li><li>Grapheme 字母 最直接的形式，总数为26个字母+空格+其它符号，不需要词典表</li><li>Word 词组 也是比较直观的形式，存在的问题是词组的总量太多，比如英文常用词组数量&gt;100K</li><li>Turkish 介于Word和Grapheme之中的词元，比如英文里的词根词缀</li><li>Bytes 常用编码，比如UTF-8，好处是数量V大小固定为256，并且可以用同样的形式表示符号和不同语言</li></ul><p>根据统计，目前用的最多的是Grapheme和Phoneme。</p><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><p>Kaldi（最常用，C++编写，Python版本有PyTorch-Kaldi、pykaldi）、SpeechBrain、ESPnet</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>01.语音识别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文本相似度</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a><strong>文本</strong></h1><ul><li>欧式距离：侧重空间差异</li><li>余弦相似度：侧重方向差异，值为cosθ（其中1-cosθ就是余弦距离）</li><li>Jacard相似度：|A∩B|&#x2F;{A∪B|</li><li>“反汉明距离”：自编名称，顾名思义~</li><li>词移距离：两文本的词之间的最小累计距离。基于两文本间的词嵌入，测量其中一文本中的单词在语义空间中移动到另一文本单词所需要的最短距离。</li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h1><ul><li>最小编辑距离：两个字符串之间基于设定编辑规则下，变成对方的最少编辑次数</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-2.基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命名实体识别（NER）</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%EF%BC%88NER%EF%BC%89/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB%EF%BC%88NER%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>识别指定名称（通用名称、领域专有名称）</li><li>工具：HanLP、CRF++</li></ul><h1 id="基于规则"><a href="#基于规则" class="headerlink" title="基于规则"></a><strong>基于规则</strong></h1><ul><li>基于句法及词汇特征</li><li>基于词性（Part-of-speech）分析</li><li>基于字典</li></ul><p>在词汇表被穷举时可以取得不错的效果，但一般由于领域规则和词典很难做到完备，所以基于规则的方法一般可以取得高准确率（High Precision）和低召回率（Low recall），同时这样的方法很难直接迁移到其他领域。</p><h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a><strong>无监督学习</strong></h1><ul><li><p>本质上都是对语义层面上进行相似度分析。具体而言，都基于词汇资源（如WordNet等），在大规模未标注语料上使用词汇特征进行统计分析。</p></li><li><p>方法：</p></li><li><ul><li>聚类实体</li><li>种子术语（Seed Terms）的相似度法</li></ul></li></ul><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a><strong>监督学习</strong></h1><h2 id="基于人工特征"><a href="#基于人工特征" class="headerlink" title="基于人工特征"></a><strong>基于人工特征</strong></h2><ul><li><p>将NER任务看作多类别分类（Multi-class Classification）的序列标注（Sequence labeling）任务</p></li><li><p>特征分为以下几类：</p></li><li><ul><li>词语级别特征（Word-level Feature），如特殊样例case，形态学morphology，词性part-of-speech等。</li></ul></li><li><ul><li>查表式特征（list      lookup features），如维基百科词典（wikipedia gazetteer，DBpedia gazetteer）等。</li></ul></li><li><ul><li>文档&#x2F;语料级特征（Document and Corpus features），如局部特征(local syntax)和多次共现(multiple occurrences)等。</li></ul></li><li><p>常用方法：HMM、EM、SVM、CRF</p></li></ul><h2 id="基于深度学习"><a href="#基于深度学习" class="headerlink" title="基于深度学习"></a><strong>基于深度学习</strong></h2><ul><li><p>输入的分布式表示：词语级别表示、字符级别表示、混合表示</p></li><li><p>上下文编码器：CNN，Recurrent     NN，Recursive NN，deep Transformer，语言模型（Language Model）等</p></li><li><ul><li>基于CNN[21]的方法对于局部特征有比较好的提取效果，但其对于句子中的长程依赖（Long-term Dependency）问题效果欠佳，因此基于Bi-LSTM的编码器被广泛使用。递归神经网络（Recursive NN）把句子当作树状结构而非序列进行处理，从理论上而言具有更强的表示能力，但其存在样本标注难度大（需标注语法解析树）、深层易梯度消失、难以并行计算等弱点，因此在实际应用中使用较少。Transformer是近年来越来越应用广泛的网络结构了，同时具有CNN和RNN的特性，对于全局特征有较好的提取效果，同时相较于RNN在并行计算上具有一定优势。大规模预训练语言模型近年来在各种NLP任务中取得巨大成功，如GPT[24]（Generative Pre-trained      Transformer）、ELMo[25]、BERT[26]等。这些预训练语言模型不但有效地捕捉了文本中的上下文关系，且不需要如Word2Vec、GloVe等传统词向量进行分布式表示。</li></ul></li><li><p>标注解码器：MLP+Softmax，CRF，RNN，Pointer Networks</p></li><li><ul><li>MLP+Softmax是最常见的分类任务输出层，如果上游的分布式表征及编码层有效地表征了文本信息，则其可以比较有效地拟合NER任务的标注序列输出。</li><li>CRF是序列标注任务中的常青树，尤其是线性链接CRF（Linear Chain CRF），其通过对观测序列到输出序列的概率建模抽取得到输出序列中的前后约束，如I-PER必定在B-PER后等。</li><li>Pointer Networks最早被应用于组合优化问题，其特点是输出序列长度由输入序列长度决定，也可以比较好地适用于序列标注任务。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-2.基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特征提取</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>TF-IDF：TF（词频）*IDF（逆文档频率，越常见的词频频率越低）</li><li>simhash（敏感哈希算法）：把一篇文档映射为一个长度为64、元素值为0或1的一维向量。这样我们就可以使用某种距离计算方式，计算两篇文本的距离和相似度了。一般来说，与simhash配合的是海明距离。</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-2.基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
      <tag>TF-IDF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语义分析</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>词法&amp;句法分析、语用&amp;语境分析，具体略~</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-2.基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词性标注</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8/1692190050928.jpg" alt="1692190050928"></p><p>下面简写上图里都有~</p><h1 id="字典查找算法"><a href="#字典查找算法" class="headerlink" title="字典查找算法"></a>字典查找算法</h1><ul><li><p>基于字符串匹配</p></li><li><p>分词后根据字典查找相应词性即可</p></li></ul><h1 id="统计模型算法"><a href="#统计模型算法" class="headerlink" title="统计模型算法"></a>统计模型算法</h1><p>基于HMM的统计方法：观测序列即为分词后的语句，隐藏序列即为经过标注后的词性标注序列。起始概率 发射概率和转移概率和分词中的含义大同小异，可以通过大规模语料统计得到。观测序列到隐藏序列的计算可以通过viterbi算法，利用统计得到的起始概率 发射概率和转移概率来得到。得到隐藏序列后，就完成了词性标注过程。</p><h1 id="jieba分词算法"><a href="#jieba分词算法" class="headerlink" title="jieba分词算法"></a>jieba分词算法</h1><p>综合了上述两种算法，对于分词后识别出来的词语，直接从字典中查找其词性。而对于未登录词，则采用HMM隐马尔科夫模型和viterbi算法来识别。</p><h1 id="深度学习算法"><a href="#深度学习算法" class="headerlink" title="深度学习算法"></a>深度学习算法</h1><ul><li>当作序列标注的任务来做</li><li>B[i]LSTM+CRF</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-2.基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中文分词</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>本质上分为两种方法：句子→词&amp;字→词</li><li>常用工具：jieba、HanLP、FoolNLTK</li></ul><h1 id="基于规则"><a href="#基于规则" class="headerlink" title="基于规则"></a><strong>基于规则</strong></h1><p>现今已少用。基于词典。</p><ul><li>正向最大匹配法（MM）</li><li>逆向最大匹配法（RMM）</li><li>双向最大匹配法（BMM）</li><li>最短路径分词法：使分出的词最少（即尽量用词组代替词）</li></ul><h1 id="基于统计"><a href="#基于统计" class="headerlink" title="基于统计"></a><strong>基于统计</strong></h1><ul><li>n-gram：一种基于字的生成树算法。为长度为n的滑动窗口。当前词取决于前n-1个词。选择概率最大的分词方法</li><li>枚举法、Viterbi（维特比）算法（实际上就是一般的贪心&amp;dp算法，基于HMM隐马尔可夫模型）</li></ul><h1 id="基于机器学习"><a href="#基于机器学习" class="headerlink" title="基于机器学习"></a><strong>基于机器学习</strong></h1><h2 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a><strong>生成式模型</strong></h2><p>hmm模型、朴素贝叶斯分类等</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="判别式模型"><a href="#判别式模型" class="headerlink" title="判别式模型"></a><strong>判别式模型</strong></h2><p>感知机、SVM、CRF、最大熵模型（不是EM！）</p><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a><strong>神经网络</strong></h2><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a><strong>RNN</strong></h3><p>LSTM、LSTM+CRF、BiLSTM-CRF、LSTM-CNNs-CRF</p><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a><strong>Transformer</strong></h3><ul><li>MLM（Masked     Language Model）</li></ul><h1 id="-2"><a href="#-2" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-2.基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词嵌入（Word Embedding）</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E8%AF%8D%E5%B5%8C%E5%85%A5%EF%BC%88Word%20Embedding%EF%BC%89/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/%E8%AF%8D%E5%B5%8C%E5%85%A5%EF%BC%88Word%20Embedding%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>原理都是词向量化，使意思相近的词的向量更接近</li><li>由One-Hot编码转换</li></ul><h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><p>基于浅窗口的方法（还有一种是矩阵分解方法，类似于基于统计的方法）</p><p>两种训练模式：</p><ul><li>CBOW（Continuous Bag-of-Words Model）：通过上下文来预测当前值</li><li>Skip-gram：用当前词来预测上下文</li></ul><p>两种加速方法（具体不介绍）：</p><ul><li>Negative Sample（负采样）：每次让一个训练样本仅仅更新一小部分的权重，这样就会降低梯度下降过程中的计算量。</li><li>Hierarchical Softmax（层次Softmax）：利用哈夫曼树结构来减少计算量的一种方式。</li></ul><h1 id="Glove（Global-Vector）"><a href="#Glove（Global-Vector）" class="headerlink" title="Glove（Global Vector）"></a>Glove（Global Vector）</h1><ul><li>解决语料利用率、SVD复杂度过高的问题</li><li>将全局统计和 Word2vec 的基于上下文的学习结合了起来</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-2.基本方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
      <tag>Word Embedding</tag>
      
      <tag>Word2Vec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语言学</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E8%AF%AD%E8%A8%80%E5%AD%A6/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E8%AF%AD%E8%A8%80%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>暂时无需深入学习，凭常识即可~</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-1.基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习（DL）</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>通常区分ML和DL的标准是有无神经网络</li><li>预训练模型通常效果更好</li><li>FNN（前馈神经网络）：单向传播，无反馈机制（即反向传播）</li><li>词袋模型（BOW）：将文本想象成一个装词的袋子，不考虑词之间的上下文关系，不关心词在袋子中存放的顺序，仅记录每个词在该文本（词袋）中出现的次数。</li><li>seq2seq：由以下某几个模型构成的“Encoder→Decoder”结构</li></ul><h1 id="Text-CNN（-文本-卷积神经网络）"><a href="#Text-CNN（-文本-卷积神经网络）" class="headerlink" title="[Text]CNN（[文本]卷积神经网络）"></a>[Text]CNN（[文本]卷积神经网络）</h1><ul><li>单&#x2F;多通道（词向量）下：卷积层（通过卷积核）→池化层（调整维度，常见有最大池化、平均池化）</li><li>每一步计算不依赖于上一步的计算结果，可以并行计算</li><li>能够提取出空间特征，训练效率高，但对输入数据的长度和宽度有限制。</li></ul><h1 id="Text-RNN（Recurrent-Neural-Network，-文本-循环神经网络）"><a href="#Text-RNN（Recurrent-Neural-Network，-文本-循环神经网络）" class="headerlink" title="[Text]RNN（Recurrent Neural Network，[文本]循环神经网络）"></a>[Text]RNN（Recurrent Neural Network，[文本]循环神经网络）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p> <img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/1692188729865.jpg" alt="1692188729865"></p><p><img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/1692188764146.jpg" alt="1692188764146"></p><ul><li>每一时刻的计算都依赖于上一时刻的结果，不能并行计算</li><li>能够提取出时序特征，但训练效率低下，容易出现梯度消失和梯度爆炸的问题。</li></ul><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><h3 id="N→M"><a href="#N→M" class="headerlink" title="N→M"></a>N→M</h3><p>Encoder-Decoder&#x2F;Seq2Seq模型：Encoder进行Encoding→c→Decoder进行Decoding</p><p><img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/1692188779921.jpg" alt="1692188779921"></p><p>或</p><p><img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/1692188788167.jpg" alt="1692188788167"></p><h3 id="双向RNN"><a href="#双向RNN" class="headerlink" title="双向RNN"></a>双向RNN</h3><p><img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88DL%EF%BC%89/1692188796678.jpg" alt="1692188796678"></p><ul><li><p>类似于单向，其中正向计算与反向计算不共享权重。</p></li><li><p>双向RNN中的每个单元可以是普通RNN单元，也可以是LSTM单元，GRU单元等</p></li></ul><h1 id="Bi-LSTM（长短期记忆神经网络）"><a href="#Bi-LSTM（长短期记忆神经网络）" class="headerlink" title="[Bi-]LSTM（长短期记忆神经网络）"></a>[Bi-]LSTM（长短期记忆神经网络）</h1><ul><li>一种RNN</li><li>输入门、遗忘门（决定以多大程度丢弃信息）、输出门</li><li>GRU（门控循环单元）：LSTM单元简化版</li><li>输入信息前向传播、误差反向传播</li></ul><h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><ul><li>可以并行计算，生成式</li><li>当今主流Transformer：BERT、GPT3&#x2F;3.5&#x2F;4、T5</li></ul><h3 id="Attention机制"><a href="#Attention机制" class="headerlink" title="Attention机制"></a>Attention机制</h3><p>抓重点~</p><ul><li><p>Soft&#x2F;Hard&#x2F;Local Attention：局&#x2F;局部&#x2F;窗口</p></li><li><p>General&#x2F;Local Attention：外部&#x2F;内部信息使用</p></li><li><p>单层&#x2F;多层&#x2F;多头Attention：多层是从句子、句向量等多个方面分析，多头是对同一段文字用多次单层Attention</p></li><li><p>常用模型→[CNN&#x2F;LSTM]+Attention：</p></li><li><ul><li>CNN+Attention：卷积操作前&#x2F;后、在pooling层中做Attention三种</li><li>LSTM+Attention：仅使用最后的hidden state、对所有step下的hidden state进行等权平均、Attention机制</li><li>纯Attention（仍需大量向量计算）</li></ul></li></ul><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li><p>Self-Attention机制结构：</p></li><li><ul><li><p>包含Multi-Head Attention，由多个Self-Attention构成</p></li><li><ul><li>Self-Attention计算的时候需要用到矩阵Q(查询),K(键值),V(值)，由Softmax矩阵等计算</li></ul></li><li><p>Multi-Head Attention上方是Add&amp;Norm层：</p></li><li><ul><li>Add 表示残差连接 (Residual Connection) 用于防止网络退化</li><li>Norm 表示Layer Normalization，用于对每一层的激活值进行归一化</li></ul></li></ul></li><li><ul><li>Feed Forward：是一个两层的全连接层，第一层的激活函数为Relu，第二层不使用激活函数，有特定公式</li></ul></li><li><p>Encoder：</p></li><li><ul><li>词和其位置的Embedding（词的嵌入可由Word2Vec得到，位置嵌入PE通过特定公式计算）相加得到词向量X</li><li>所有词向量构成的编码矩阵输入Encoder中，得到Decoder的输入编码矩阵C</li></ul></li><li><p>Decoder：</p></li><li><ul><li>包含两个 Multi-Head Attention 层。</li><li>第一个 Multi-Head Attention 层采用了 Masked 操作。</li><li>第二个 Multi-Head Attention 层的K, V矩阵使用 Encoder 的编码信息矩阵C进行计算，而Q使用上一个 Decoder block 的输出计算。</li><li>最后有一个 Softmax 层计算下一个翻译单词的概率。</li></ul></li></ul><h1 id="A-x2F-N-x2F-Deep-FM"><a href="#A-x2F-N-x2F-Deep-FM" class="headerlink" title="[A&#x2F;N&#x2F;Deep]FM"></a>[A&#x2F;N&#x2F;Deep]FM</h1><ul><li><p>FM（Factorization     Machines）：因子分解机，实现了特征的两两自动交叉</p></li><li><p>Wide&amp;Deep：LR+DNN（深度神经网络，有很多隐藏层的神经网络）</p></li><li><p>FNN：</p></li><li><ul><li>&#x3D;FM+DNN：既有像FM那样做显式特征交叉，又具备DNN的隐式高阶交叉和泛化能力</li><li>一个Embedding + MLP结构，采用FM训练得到的隐向量作为神经网络第一层权重的初始值，之后是隐藏层，最后是点击率预估的输出</li></ul></li><li><p>NFM：通过设计一种结构，把FM和DNN直接组合了起来，不同于FNN需要两阶段训练，NFM是一个同时包含了FM和DNN两部分的完整模型，训练过程是端到端的</p></li><li><p>AFM：将Attention机制引入到了特征交叉模块，可以看作是对NFM功能的增强</p></li><li><p>DeepFM：FM+DNN，Wide&amp;Deep的升级版，用FM来代替Wide&amp;Deep的Wide侧</p></li></ul><h1 id="GAN（生成对抗网络）"><a href="#GAN（生成对抗网络）" class="headerlink" title="GAN（生成对抗网络）"></a>GAN（生成对抗网络）</h1><p>NLP中应用较少，略~</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-1.基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
      <tag>深度学习（DL）</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习（ML，深度学习内容除外）</title>
    <link href="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E9%99%A4%E5%A4%96%EF%BC%89/"/>
    <url>/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E9%99%A4%E5%A4%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用：（关联分析→）判别<strong>分类</strong>、<strong>回归</strong>预测、聚类&amp;降维；评价决策、规划优化</p><h1 id="常用模型算法"><a href="#常用模型算法" class="headerlink" title="常用模型算法"></a><strong>常用模型算法</strong></h1><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><ul><li>汇总：<ul><li>传统算法：逻辑回归（0-1分类问题）、KNN（K邻近）、决策树、多层感知器、朴素贝叶斯（包括伯努利贝叶斯、高斯贝叶斯和多项式贝叶斯）、支持向量机SVM</li><li>集成学习算法：随机森林、AdaBoost、lightGBM、XGBoost、GBDT（梯度提升树）、CatBoost、ExtraTrees</li><li>深度学习算法：神经网络（前馈、反向&#x2F;BP）和LSTM</li></ul></li><li>分别的特点&amp;应用：</li></ul><p>逻辑回归</p><ul><li>特点：逻辑回归是一种线性分类模型，用于预测二进制输出。它通过将线性组合映射到0和1之间的概率，然后根据阈值进行分类。</li><li>适用情况：适用于简单的二分类问题，特征与目标之间的关系近似为线性时。</li></ul><p>KNN（K最近邻）</p><ul><li>特点：KNN通过测量样本之间的距离来进行分类，将新样本与最近邻的训练样本进行投票，决定其分类。</li><li>适用情况：适用于特征空间中相邻样本具有相似性的问题，但在大型数据集上可能效率较低。</li></ul><p>决策树</p><ul><li>特点：决策树通过根据特征值进行分支和决策来进行分类。可以捕捉非线性关系，容易解释。</li><li>适用情况：适用于复杂的分类问题，能够处理混合特征类型。</li></ul><p>多层感知器（MLP）</p><ul><li>特点：MLP是一种深度神经网络，具有多个隐藏层，能够学习复杂的非线性关系。</li><li>适用情况：适用于大型数据集和复杂的非线性问题，但需要调整许多超参数。</li></ul><p>朴素贝叶斯</p><ul><li>特点：朴素贝叶斯基于贝叶斯定理和特征之间的条件独立性假设，用于计算后验概率。</li><li>适用情况：适用于文本分类和稀疏数据，特征之间独立性假设在某些情况下可能过于简化。</li></ul><p>SVM（支持向量机）</p><ul><li>特点：SVM旨在找到一个最优超平面，将不同类别的样本分开，并最大化分类边界的间隔。</li><li>适用情况：适用于高维数据和线性&#x2F;非线性分类问题，能够有效处理边界问题。</li></ul><p>随机森林</p><ul><li>特点：随机森林是基于多个决策树的集成方法，通过投票或平均来提高分类准确性和泛化能力。</li><li>适用情况：适用于复杂的分类问题，能够减少过拟合，对于高维数据也有较好表现。</li></ul><p>AdaBoost</p><ul><li>特点：AdaBoost是一种自适应的集成方法，通过调整样本权重来训练一系列弱分类器，将它们组合成一个强分类器。</li><li>适用情况：适用于二分类问题，能够提高性能并降低偏差。</li></ul><p>LightGBM、XGBoost、GBDT、CatBoost</p><ul><li>特点：这些都是梯度提升树的变种，通过迭代训练一系列弱分类器来逐步改进预测。</li><li>适用情况：适用于复杂的分类问题，具有较高的预测性能和泛化能力，需要调整的超参数较多。</li></ul><p>ExtraTrees</p><ul><li>特点：ExtraTrees是随机森林的一种变种，对每个决策树的特征随机进行划分，增加了多样性。</li><li>适用情况：适用于高维数据，对于噪声和异常值有较好的鲁棒性。</li></ul><p>神经网络</p><ul><li>特点：神经网络可以处理复杂的非线性关系，适用于大型数据集和高维特征。</li><li>适用情况：适用于各种复杂的分类问题，但需要大量的数据和计算资源来进行训练。</li></ul><p>LSTM（长短时记忆网络）</p><ul><li>特点：LSTM是一种循环神经网络（RNN）的变种，适用于处理序列数据，能够捕捉长期依赖关系。</li><li>适用情况：适用于文本、语音、时间序列等问题，需要考虑序列中的时间依赖性。</li></ul><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="聚类问题"><a href="#聚类问题" class="headerlink" title="聚类问题"></a><strong>聚类问题</strong></h2><p>K-Means聚类（基于划分）、DBSCANS&amp;密度聚类、层次聚类（凝聚式、分裂式）、谱聚类、均值漂移、神经网络、模糊聚类</p><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a><strong>回归问题</strong></h2><ul><li>汇总：<ul><li>传统算法：逻辑回归（0-1回归问题）、线性回归、Lasso回归、岭（Ridge）回归、KNN（K邻近）、决策树、多层感知器、支持向量机SVM</li><li>集成学习算法：随机森林、AdaBoost、lightGBM、XGBoost、GBDT（梯度提升树）、CatBoost、ExtraTrees</li><li>深度学习算法：神经网络（前馈、反向&#x2F;BP）和LSTM</li></ul></li><li>分别的特点&amp;应用：</li></ul><p>逻辑回归（0-1回归问题）</p><ul><li>特点：逻辑回归可以用于二元分类问题，通过逻辑函数将线性组合映射到0和1之间。</li><li>适用情况：适用于需要预测概率的二元分类问题，比如判断是否发生某事件。</li></ul><p>线性回归</p><ul><li>特点：线性回归寻找最佳拟合直线，使预测值与真实值之间的平方误差最小。</li><li>适用情况：适用于预测因变量与一个或多个自变量之间的线性关系，特征与目标之间呈现线性关系。</li></ul><p>Lasso回归</p><ul><li>特点：Lasso回归通过L1正则化，倾向于使一些特征的系数变为零，从而实现特征选择和降维。</li><li>适用情况：适用于特征选择和模型简化，有许多特征但只有一部分对目标变量有影响。</li></ul><p>岭（Ridge）回归</p><ul><li>特点：岭回归通过L2正则化，缓解特征之间的共线性问题，能够稳定模型。</li><li>适用情况：适用于数据具有多重共线性，避免模型过拟合。</li></ul><p>KNN（K邻近）</p><ul><li>特点：KNN回归通过选取最近的K个样本，计算其平均值来预测目标变量。</li><li>适用情况：适用于需要考虑相邻样本对预测的影响，不适用于高维数据或大型数据集。</li></ul><p>决策树</p><ul><li>特点：决策树回归通过根据特征值进行分支和决策，预测输出值。</li><li>适用情况：适用于数据具有非线性关系，能够进行局部拟合。</li></ul><p>多层感知器</p><ul><li>特点：多层感知器（MLP）也可以用于回归问题，通过多个隐藏层学习复杂的非线性关系。</li><li>适用情况：适用于非线性回归问题，需要大量数据和计算资源。</li></ul><p>支持向量机（SVM）</p><ul><li>特点：SVM回归寻找一个最优超平面，使样本点尽量靠近这个平面，并且落在容忍范围内。</li><li>适用情况：适用于非线性回归问题，能够处理高维数据。</li></ul><p>随机森林、AdaBoost、LightGBM、XGBoost、GBDT、CatBoost、ExtraTrees</p><ul><li>特点：这些都是梯度提升树的变种，能够在回归问题中进行集成预测，提高性能。</li><li>适用情况：适用于复杂的非线性回归问题，对噪声有较好的鲁棒性，需要调整超参数。</li></ul><p>神经网络（前馈、反向传播&#x2F;BP）</p><ul><li>特点：神经网络可以用于回归问题，通过多层神经元进行特征提取和非线性映射。</li><li>适用情况：适用于复杂的非线性回归问题，需要大量的数据和计算资源。</li></ul><p>LSTM</p><ul><li>特点：LSTM是一种适用于序列数据的循环神经网络，可以用于序列回归问题，能够捕捉时间依赖关系。</li><li>适用情况：适用于时间序列预测、序列数据的回归问题，需要考虑时间关系。</li></ul><h1 id="代价-amp-损失函数"><a href="#代价-amp-损失函数" class="headerlink" title="代价&amp;损失函数"></a>代价&amp;损失函数</h1><ul><li>训练、验证（挑选、适当优化训练后的模型阶段）阶段对于训练或验证集使用~</li><li>损失函数是针对单个样本的，代价函数是所有单个样本损失函数的平均值</li><li>目标函数为代价函数+正则化项</li></ul><h2 id="分类问题-1"><a href="#分类问题-1" class="headerlink" title="分类问题"></a><strong>分类问题</strong></h2><ul><li><p>交叉熵：</p><ul><li>BCE（Binary…）：</li></ul><p>$$<br>\sum_{i&#x3D;0}^m \delta^2\left(\sqrt{1+\left(\frac{y_i-\hat{y}_i}{\delta}\right)^2}-1\right)<br>$$</p></li><li><ul><li>CCE（Categorical…）：</li></ul></li></ul><p>$$<br>\sum_{i&#x3D;0}^C-y_i \log \left(\hat{y}_i\right)<br>$$</p><h2 id="聚类问题-1"><a href="#聚类问题-1" class="headerlink" title="聚类问题"></a><strong>聚类问题</strong></h2><ul><li><p>一般无监督学习：光度损失、平滑损失</p></li><li><p>没有特别的聚类&amp;降维的损失函数</p></li></ul><h2 id="-2"><a href="#-2" class="headerlink" title></a></h2><h2 id="回归问题-1"><a href="#回归问题-1" class="headerlink" title="回归问题"></a><strong>回归问题</strong></h2><ul><li><p>MSE&amp;MAE：MSE更容易解决问题，MAE更鲁棒</p></li><li><p>Huber损失：</p><ul><li>更精确，对异常点更鲁棒<br>$$<br>\sum_{i&#x3D;0}^m \delta^2\left(\sqrt{1+\left(\frac{y_i-\hat{y}_i}{\delta}\right)^2}-1\right)<br>$$</li></ul></li><li><p>Log-Cosh损失：</p><ul><li>取对数，更平滑<br>$$<br>L\left(y, y^p\right)&#x3D;\sum_{i&#x3D;1}^n \log \left(\cosh \left(y_i^p-y_i\right)\right)<br>$$</li></ul></li><li><p>分位数损失：更关注区间预测而不是点预测</p></li></ul><h1 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a><strong>评价指标</strong></h1><p>测试阶段，对于测试集使用~</p><h2 id="分类问题-2"><a href="#分类问题-2" class="headerlink" title="分类问题"></a><strong>分类问题</strong></h2><ul><li><p>混淆矩阵：</p></li><li><p><img src="/2023/08/16/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%EF%BC%88NLP%EF%BC%89/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E9%99%A4%E5%A4%96%EF%BC%89/v2-772989d618f33dc0f1127bac18483736_r.jpg" alt="PR、ROC、AUC全击破 - 知乎"></p></li><li><p>常见参数：</p><ul><li>准确率&#x2F;正确率：(TP+TN)&#x2F;(TP+TN+FP+FN)</li><li>精确率&#x2F;查准率（是否错报）：TP&#x2F;(TP+FP)</li><li>召回率&#x2F;查全率（是否漏报）：TP&#x2F;(TP+FN)</li><li>FPR（假正类率）：FP&#x2F;(FP+TN)</li><li>TNR（真负类率）：TN&#x2F;(FP+TN)</li><li>F1 score：精确率和召回率的调和平均值：2<em>准确率</em>召回率&#x2F;(准确率+召回率)</li><li>P-R曲线：横轴是召回率R，纵轴是精确率P</li><li>ROC曲线（receiveroperating characteristic，接收者操作特征）：横轴为FPR，纵轴为TPR（真正类率）</li><li>AUC（Area under Curve，ROC曲线下的面积），介于0.1和1之间，直观的评价分类器的好坏，值越大越好</li></ul></li></ul><h2 id="-3"><a href="#-3" class="headerlink" title></a></h2><h2 id="聚类问题-2"><a href="#聚类问题-2" class="headerlink" title="聚类问题"></a><strong>聚类问题</strong></h2><ul><li>外部指标：Jaccard系数、FM指数、[调整]Rand指数&#x2F;兰德系数、F值、调整&#x2F;标准互信息分数</li><li>内部指标：紧密度、戴维森堡丁指数、邓恩指数、轮廓系数</li></ul><h2 id="-4"><a href="#-4" class="headerlink" title></a></h2><h2 id="回归问题-2"><a href="#回归问题-2" class="headerlink" title="回归问题"></a><strong>回归问题</strong></h2><ul><li>MAE：平均绝对误差（Mean      Absolute Error）</li><li>MSE：均方误差（Mean Square Error）</li><li>RMSE：根均方误差（Root Mean Square Error）</li></ul><p>取均方误差的平方根可以使得量纲一致，这对于描述和表示是有意义的。</p><ul><li>MAPE：平均绝对百分比误差（Mean Absolute Percentage Error）</li></ul><p>注意点：当真实值有数据等于0时，存在分母0除问题，该公式不可用！</p><ul><li>SMAPE：对称平均绝对百分比误差（Symmetric Mean Absolute Percentage Error）</li></ul><p>注意点：真实值、预测值均等于0时，存在分母为0，该公式不可用！</p><ul><li>R Squared:</li><li>即决定系数（Coefficient of determination），被人们称为最好的衡量线性回归法的指标。</li><li>如果我们使用同一个算法模型，解决不同的问题，由于不同的数据集的量纲不同，MSE、RMSE等指标不能体现此模型针对不同问题所表现的优劣，也就无法判断模型更适合预测哪个问题。得到的性能度量都在[0, 1]之间，可以判断此模型更适合预测哪个问题。</li></ul><p>公式的理解：</p><ul><li>分母代表baseline（平均值）的误差，分子代表模型的预测结果产生的误差；</li><li>预测结果越大越好，为1说明完美拟合，为0说明和baseline一致。</li></ul>]]></content>
    
    
    <categories>
      
      <category>自然语言处理（NLP）</category>
      
      <category>0-1.基础理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理（NLP）</tag>
      
      <tag>机器学习（ML）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读</title>
    <link href="/2023/08/13/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2023/08/13/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><ul><li>自然语言处理（NLP）的先进论文成果一般有以下几个渠道获得：</li></ul><ol><li>会议。ACL（7.9）、EMNLP（12.6）、NAACL（7.10），以上三会为NLP旗舰会议，每年一办，质量都不错。除此之外，COLING（10.12）、CIKM、SIGIR、NLPCC也是较好的会议。除此之外，AAAI（2.20）、IJCAI（8.19）、ICLR（5.1）、ICML（7.23）等人工智能顶级会议也是NLP常客。会议都有submit deadline，可以在 <a href="https://aideadlin.es/?sub=ML,CV,CG,NLP,RO,SP,DM,AP,KR,HCI">https://aideadlin.es/?sub=ML,CV,CG,NLP,RO,SP,DM,AP,KR,HCI</a> 关注；</li><li>期刊。TACL，旗舰期刊，论文质量颇高。TNNLS、TPAMI、CL、Information management &amp; processing也都挺好。</li></ol><ul><li>会议集、期刊论文获取途径：</li></ul><ol><li>Arxiv预印网站。由于会议期刊需要审稿、公示、索引（可获取pdf）等步骤，往往论文从投稿到中稿再到可索引获取需要3-6个月，从而失去先进性。所以很多论文作者通常抢先发表自己的成果在Arxiv上，然后再投稿会议期刊。搜索技巧：一般可以输入关键词+会议缩写来获取。例如 Question Answering acl 2023</li><li>dblp。一般出索引后的会议、期刊论文都可以在上面找到。直接在输入框搜索上述会议期刊缩写即可获得每年份会议、每版期刊的论文</li></ol><ul><li>文献树构建：</li></ul><ol><li>被引。论文出索引后，在Google scholar可以搜到，点击下面的“被引次数”即可</li><li>引用。论文中的Introduction、Related Work章节都会显式引用该篇论文之前的工作</li></ol><p> *边读边翻译：Ctrl+F9（有字数限制但直接翻译在一旁）、Ctrl+C+C（无字数限制但通过打开的客户端界面翻译）</p><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a><strong>idea</strong></h1><ul><li>目的大方向：理论&amp;方法的创新性改进&#x2F;全新提出、体现自己全面深厚的NLP技术能力、不[显得]抄袭</li><li>目的：从性能（多方面应用需求、评价指标）、效率&amp;开销（端到端流程、时空复杂度、成本）等方面，对现有模型&amp;算法的缺点进行改进</li><li>内容：NLP&amp;CV理论和方法（项目）之间&amp;各自内部各领域的互相结合（笛卡尔积）</li><li>信息渠道：针对搜索引擎中对于各分支值得研究&amp;待解决问题的检索，各数据科学竞赛平台中关于NLP的AI算法竞赛赛题，搜索引擎、GitHub、B站上的NLP项目，各分支搜索引擎&amp;文献的综述、（近三年顶会）会议[、年份]论文中的不足&amp;展望部分、有启发的点、*不太认同的地方</li><li>其他：*跟导师争取代工&#x2F;自己投稿从而参加学术会议，与大牛交流</li></ul>]]></content>
    
    
    <categories>
      
      <category>读研</category>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm</title>
    <link href="/2023/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/npm/"/>
    <url>/2023/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/npm/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>类似Ubuntu的apt、Python的pip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm list<br>npm show package_name<br>npm install package_name<br>npm update package_name <br>npm uninstall/remove package_name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2023/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Nginx/"/>
    <url>/2023/07/21/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Nginx/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>反代等</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><ul><li>nginx.conf配置文件除了server改为localhost、用alias改location路径（勿忘最后的&#x2F;！）之外，还需把user从nginx改为root，同时注释掉两个include默认页面的配置！</li><li>查找nginx运行程序路径（一般在&#x2F;usr&#x2F;sin或者&#x2F;usr&#x2F;local&#x2F;sbin里面）：ps -aux | grep      nginx</li><li>重启：.&#x2F;nginx -s reload</li><li>启动：.&#x2F;nginx或systemctl start nginx</li><li>设置开机自启动：chkconfig nginx on</li><li>可能还需修改nginx运行程序权限为可执行</li><li>内网穿透：screen -S cpolar</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Word</title>
    <link href="/2023/07/13/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/Word/"/>
    <url>/2023/07/13/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/Word/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>*Latex共享写作：Overleaf（免费版最多支持一人协作）；独立写作：Overleaf&#x2F;Vscode</p><p>*首页下横线居中等长对齐：全部移到最左边（留一个在原来的中间）后逐一黏贴然后手动删下划线对齐其他→用标尺或自己按空格丈量一下来居中横线上内容→将整行内容手动</p><p>移到中间对齐留下来的那一个（制表或者Tab键对齐横线都没啥用！）</p><p>*设置成正文字体样式快捷键：Ctrl+Shift+N</p><p>*插入公式（图表直接插入，略~）：</p><ul><li><p>公式书写：（本来就为图片形式略~）不复杂直接在电脑mathpix中用鼠标写，复杂则在平板onenote上用笔手写（写大一点，撤回或者擦去时较方便）</p></li><li><p>手写识别：mathpix截图</p></li><li><p>Word中LaTeX转公式：先将Latex公式选中按Alt和&#x3D;，将其变为居中的公式，然后再选中公式右键，选择“专业”（OneNote中为后Ctrl+Enter）</p></li></ul><p>**插入本地图片：注意选中图片-段落 ，看是否有首行缩进！有的话去掉！</p><p>**插入PPT图片：可将ppt绘制的图形放到画布中——插入-形状-最下方-新建画布</p><p>*图片、表格、公式自动编号：都是选中整个后右键选择插入题注！</p><p>*翻译：Deepl，Word内选中中文Ctrl+Win+C，每次最多翻译1000字</p><p>*写完润色检查：Quillbot+Grammarly插件！</p><p>**截图识别文字:Ctrl+F8</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>F4：重复上一步操作</p><p>Ctrl Enter 分页符&#x2F;生成新页面</p><p>Delete键：有时候排版时用backspace论文排版格式会乱</p><p>Shift+F3：大小写转换</p><p>*若字写的少：页边距调大一点；若字写的多：页边距调小（适用于数模国赛等等）</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>*文字变打入的覆盖原有的：按Insert</p><p>*假回车的符号是向下的箭头，在word中光标不能定在硬回车符号的右方，硬回车是带有拐角的箭头。</p><p>当文档中出现软回车符时，且数量不少时。我们可以用查找替换法，将软回车替换为硬回车，单击开始选项卡下的替换功能，会出现一个查找和替换对话框，然后在查找内容框中输入一个拖字符和L，在替换为框中输入拖字符和P,单击确定就好了。（注意：是在英文输入法中输入拖字符，按Shift+6就可输入拖字符）</p>]]></content>
    
    
    <categories>
      
      <category>读研</category>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTeX</title>
    <link href="/2023/07/13/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/LaTeX/"/>
    <url>/2023/07/13/%E8%AF%BB%E7%A0%94/%E7%A7%91%E7%A0%94/LaTeX/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">%这是单行注释</span><br><span class="hljs-keyword">\begin</span>&#123;comment&#125;<br>这是<br>多行注释<br><span class="hljs-keyword">\end</span>&#123;comment&#125;<br></code></pre></td></tr></table></figure><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><strong>标题</strong></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\section</span>&#123;一级标题内容&#125;<br><span class="hljs-keyword">\subsection</span>&#123;二级标题内容&#125;<br><span class="hljs-keyword">\subsubsection</span>&#123;三级标题内容&#125;<br></code></pre></td></tr></table></figure><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a><strong>段落</strong></h2><p>首行缩进：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;indentfirst&#125;<br><span class="hljs-keyword">\setlength</span>&#123;<span class="hljs-keyword">\parindent</span>&#125;&#123;2em&#125; <br><span class="hljs-keyword">\noindent</span> 正文 <span class="hljs-comment">%关闭某段的首行缩进</span><br></code></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a><strong>无序列表</strong></h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;itemize&#125;[leftmargin=2em,labelsep=0.5em]<br>        <span class="hljs-comment">%leftmargin设置了左边距，labelsep设置了标签（项目符号）和文本之间的间距</span><br><span class="hljs-keyword">\item</span>[标签] 条目内容<br><span class="hljs-keyword">\end</span>&#123;itemize&#125;<br></code></pre></td></tr></table></figure><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a><strong>有序列表</strong></h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;[可选格式]<br><span class="hljs-keyword">\item</span>[标签] 条目内容<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br></code></pre></td></tr></table></figure><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a><strong>符号</strong></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">`、&#x27; <span class="hljs-comment">%分别表示‘、’</span><br>``、&#x27;&#x27; <span class="hljs-comment">%分别表示“、”</span><br>-、--、--- <span class="hljs-comment">%连字号-、短破折号—、长破折号——</span><br><span class="hljs-keyword">\dots</span> <span class="hljs-comment">%省略号</span><br><span class="hljs-keyword">\footnote</span>&#123;text for footnote&#125; <span class="hljs-comment">%脚注（自动在文本中插入一个上标数字，被称为脚注的标号（mark），同时在页面的底部插入脚注的标记和内容）</span><br></code></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a><strong>字体</strong></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\textbf</span>&#123;加粗&#125; <br><span class="hljs-keyword">\emph</span>&#123;斜体&#125;<br><span class="hljs-keyword">\underline</span>&#123;下划线&#125;<br></code></pre></td></tr></table></figure><h1 id="图表"><a href="#图表" class="headerlink" title="图表"></a><strong>图表</strong></h1><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a><strong>图片</strong></h2><h3 id="单图"><a href="#单图" class="headerlink" title="单图"></a><strong>单图</strong></h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\includegraphics</span>&#123;a.jpg&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><h3 id="多图"><a href="#多图" class="headerlink" title="多图"></a><strong>多图</strong></h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\ </span>begin &#123; figure &#125;[ htbp ]<br>        <span class="hljs-keyword">\ </span>centering<br>        <span class="hljs-keyword">\ </span>subfigure [ Hot Map of one Room ]&#123; <span class="hljs-comment">% 图 片 1([] 内 为 子 图 标 题 )</span><br>        <span class="hljs-keyword">\ </span>label &#123; fig : sub . roomhot &#125; <span class="hljs-comment">% 子 图 1 的 标 签</span><br>        <span class="hljs-keyword">\ </span>i nc l ud e gr ap h ic s [ width =0.45<span class="hljs-keyword">\ </span>textwidth ]&#123; XXX . jpg &#125;&#125; <span class="hljs-comment">% 子 图 1 位 置</span><br>        <span class="hljs-keyword">\ </span>subfigure [ Hot Map of one Floor ]&#123; <span class="hljs-comment">% 图 片 2</span><br>        <span class="hljs-keyword">\ </span>label &#123; fig : sub . floorhot &#125; <span class="hljs-comment">% 子 图 2 的 标 签</span><br>        <span class="hljs-keyword">\ </span>i nc l ud e gr ap h ic s [ width =0.45<span class="hljs-keyword">\ </span>textwidth ]&#123; XXX . jpg &#125;&#125; <span class="hljs-comment">% 子 图 2 位 置</span><br>        <span class="hljs-keyword">\ </span>caption &#123; Hot Map of one Room and one Floor &#125; <span class="hljs-comment">% 总 图 标 题</span><br>        <span class="hljs-keyword">\ </span>label &#123; fig : hot &#125; <span class="hljs-comment">% 总 图 标 签</span><br><span class="hljs-keyword">\ </span>end &#123; figure &#125;<br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a><strong>表格</strong></h2><h2 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a><strong>自动生成</strong></h2><p> <a href="https://www.tablesgenerator.com/">https://www.tablesgenerator.com/</a></p><h2 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a><strong>手搓</strong></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|l|c|r|&#125;<br> <span class="hljs-keyword">\hline</span><br>操作系统<span class="hljs-built_in">&amp;</span> 发行版<span class="hljs-built_in">&amp;</span> 编辑器<span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br>Windows <span class="hljs-built_in">&amp;</span> MikTeX <span class="hljs-built_in">&amp;</span> TexMakerX <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br>Unix/Linux <span class="hljs-built_in">&amp;</span> teTeX <span class="hljs-built_in">&amp;</span> Kile <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br>Mac OS <span class="hljs-built_in">&amp;</span> MacTeX <span class="hljs-built_in">&amp;</span> TeXShop <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br>通用<span class="hljs-built_in">&amp;</span> TeX Live <span class="hljs-built_in">&amp;</span> TeXworks <span class="hljs-keyword">\\</span><br> <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">操作系统</th><th align="center">发行版</th><th align="right">编辑器</th></tr></thead><tbody><tr><td align="left">Windows</td><td align="center">MikTeX</td><td align="right">TexMakerX</td></tr><tr><td align="left">Unix&#x2F;Linux</td><td align="center">teTeX</td><td align="right">Kile</td></tr><tr><td align="left">Mac OS</td><td align="center">MacTeX</td><td align="right">TeXShop</td></tr><tr><td align="left">通用</td><td align="center">TeX Live</td><td align="right">TeXworks</td></tr></tbody></table><ul><li>三线表：</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\ </span>begin &#123; table &#125;[! htbp ]<br>     <span class="hljs-keyword">\ </span>begin &#123; center &#125;<br>     <span class="hljs-keyword">\ </span>caption &#123; Fitness of the three formations for the Huskies &#125;<br>     <span class="hljs-keyword">\ </span>begin &#123; tabular &#125;&#123; cccc &#125;<br>     <span class="hljs-keyword">\ </span>toprule<br>     Formation <span class="hljs-built_in">&amp;</span> Coordination <span class="hljs-built_in">&amp;</span> Flexibility <span class="hljs-built_in">&amp;</span> Pressing <span class="hljs-keyword">\\</span><br>     <span class="hljs-keyword">\ </span>midrule<br>     <span class="hljs-keyword">\ </span>textsf &#123;4 -3 -3&#125; <span class="hljs-built_in">&amp;</span>5.1043 <span class="hljs-built_in">&amp;</span>32.42 <span class="hljs-built_in">&amp;</span>42.37<span class="hljs-keyword">\\</span><br>     <span class="hljs-keyword">\ </span>textsf &#123;4 -4 -2&#125; <span class="hljs-built_in">&amp;</span>6.0104 <span class="hljs-built_in">&amp;</span>40.88 <span class="hljs-built_in">&amp;</span>43.58<span class="hljs-keyword">\\</span><br>     <span class="hljs-keyword">\ </span>textsf &#123;5 -3 -2&#125; <span class="hljs-built_in">&amp;</span>7.5032 <span class="hljs-built_in">&amp;</span>23.50 <span class="hljs-built_in">&amp;</span>49.67<span class="hljs-keyword">\\</span><br>     <span class="hljs-keyword">\ </span>bottomrule<br>     <span class="hljs-keyword">\ </span>end &#123; tabular &#125;<span class="hljs-keyword">\ </span>label &#123; tb : Fitness <span class="hljs-built_in">_</span> formations &#125;<br>     <span class="hljs-keyword">\ </span>end &#123; center &#125;<br> <span class="hljs-keyword">\ </span>end &#123; table &#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">Formation</th><th align="center">Coordination</th><th align="center">Flexibility</th><th align="center">Pressing</th></tr></thead><tbody><tr><td align="center">$4-3-3$</td><td align="center">5.1043</td><td align="center">32.42</td><td align="center">42.37</td></tr><tr><td align="center">$4-4-2$</td><td align="center">6.0104</td><td align="center">40.88</td><td align="center">43.58</td></tr><tr><td align="center">$5-3-2$</td><td align="center">7.5032</td><td align="center">23.50</td><td align="center">49.67</td></tr></tbody></table><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a><strong>代码</strong></h1><h2 id="简约版"><a href="#简约版" class="headerlink" title="简约版"></a><strong>简约版</strong></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;lstlisting&#125;[language=C]<br>你的代码<br><span class="hljs-keyword">\end</span>&#123;lstlisting&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂版"><a href="#复杂版" class="headerlink" title="复杂版"></a><strong>复杂版</strong></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;listings&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;color&#125;<br><br><span class="hljs-keyword">\definecolor</span>&#123;dkgreen&#125;&#123;rgb&#125;&#123;0,0.6,0&#125;<br><span class="hljs-keyword">\definecolor</span>&#123;gray&#125;&#123;rgb&#125;&#123;0.5,0.5,0.5&#125;<br><span class="hljs-keyword">\definecolor</span>&#123;mauve&#125;&#123;rgb&#125;&#123;0.58,0,0.82&#125;<br><br><span class="hljs-keyword">\lstset</span>&#123; <span class="hljs-comment">%</span><br>  language=Octave,                <span class="hljs-comment">% the language of the code</span><br>  basicstyle=<span class="hljs-keyword">\footnotesize</span>,           <span class="hljs-comment">% the size of the fonts that are used for the code</span><br>  numbers=left,                   <span class="hljs-comment">% where to put the line-numbers</span><br>  numberstyle=<span class="hljs-keyword">\tiny</span><span class="hljs-keyword">\color</span>&#123;gray&#125;,  <span class="hljs-comment">% the style that is used for the line-numbers</span><br>  stepnumber=2,                   <span class="hljs-comment">% the step between two line-numbers. If it&#x27;s 1, each line</span><br>                                  <span class="hljs-comment">% will be numbered</span><br>  numbersep=5pt,                  <span class="hljs-comment">% how far the line-numbers are from the code</span><br>  backgroundcolor=<span class="hljs-keyword">\color</span>&#123;white&#125;,      <span class="hljs-comment">% choose the background color. You must add \usepackage&#123;color&#125;</span><br>  showspaces=false,               <span class="hljs-comment">% show spaces adding particular underscores</span><br>  showstringspaces=false,         <span class="hljs-comment">% underline spaces within strings</span><br>  showtabs=false,                 <span class="hljs-comment">% show tabs within strings adding particular underscores</span><br>  frame=single,                   <span class="hljs-comment">% adds a frame around the code</span><br>  rulecolor=<span class="hljs-keyword">\color</span>&#123;black&#125;,        <span class="hljs-comment">% if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))</span><br>  tabsize=2,                      <span class="hljs-comment">% sets default tabsize to 2 spaces</span><br>  captionpos=b,                   <span class="hljs-comment">% sets the caption-position to bottom</span><br>  breaklines=true,                <span class="hljs-comment">% sets automatic line breaking</span><br>  breakatwhitespace=false,        <span class="hljs-comment">% sets if automatic breaks should only happen at whitespace</span><br>  title=<span class="hljs-keyword">\lstname</span>,                   <span class="hljs-comment">% show the filename of files included with \lstinputlisting;</span><br>                                  <span class="hljs-comment">% also try caption instead of title</span><br>  keywordstyle=<span class="hljs-keyword">\color</span>&#123;blue&#125;,          <span class="hljs-comment">% keyword style</span><br>  commentstyle=<span class="hljs-keyword">\color</span>&#123;dkgreen&#125;,       <span class="hljs-comment">% comment style</span><br>  stringstyle=<span class="hljs-keyword">\color</span>&#123;mauve&#125;,         <span class="hljs-comment">% string literal style</span><br>  escapeinside=&#123;<span class="hljs-keyword">\%</span>*&#125;&#123;*)&#125;,            <span class="hljs-comment">% if you want to add LaTeX within your code</span><br>  morekeywords=&#123;*,...&#125;               <span class="hljs-comment">% if you want to add more keywords to the set</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a><strong>伪代码</strong></h1><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>[UTF8]&#123;ctex&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;algorithm&#125; <span class="hljs-comment">% 排版算法</span><br><span class="hljs-keyword">\usepackage</span>&#123;algorithmic&#125; <span class="hljs-comment">% 排版算法</span><br><br><span class="hljs-keyword">\title</span>&#123;Algorithm&#125;<br><span class="hljs-keyword">\author</span>&#123;NSJim Green&#125;<br><span class="hljs-keyword">\date</span>&#123;October 2020&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\maketitle</span><br><br><span class="hljs-keyword">\section</span>&#123;Algorithm 1&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;algorithm&#125;<br><span class="hljs-keyword">\caption</span>&#123;CheckSum(A,x)&#125; <span class="hljs-comment">%算法标题</span><br><span class="hljs-keyword">\label</span>&#123;alg2&#125; <span class="hljs-comment">%标签</span><br><span class="hljs-keyword">\begin</span>&#123;algorithmic&#125; <span class="hljs-comment">%算法开始</span><br><span class="hljs-keyword">\STATE</span> &#123;<span class="hljs-keyword">\bf</span> Input:&#125; An array A and a value x  <span class="hljs-comment">%也可以用\textbf&#123;Input:&#125;</span><br><span class="hljs-keyword">\STATE</span> &#123;<span class="hljs-keyword">\bf</span> Output:&#125; A bool value show if there is two elements in A whose sum is x<br><span class="hljs-keyword">\STATE</span> A <span class="hljs-built_in">$</span><span class="hljs-keyword">\gets</span><span class="hljs-built_in">$</span> SORT(A)<br><span class="hljs-keyword">\STATE</span> n <span class="hljs-built_in">$</span><span class="hljs-keyword">\gets</span><span class="hljs-built_in">$</span> length(n)<br><span class="hljs-keyword">\FOR</span>&#123;i <span class="hljs-built_in">$</span><span class="hljs-keyword">\gets</span><span class="hljs-built_in">$</span> 0 to n&#125;<br>    <span class="hljs-keyword">\IF</span>&#123;Binary-search(A,x-A[i],1,n)&#125;<br>    <span class="hljs-keyword">\STATE</span> return true<br>    <span class="hljs-keyword">\ENDIF</span><br><span class="hljs-keyword">\ENDFOR</span><br><span class="hljs-keyword">\STATE</span> return false<br><span class="hljs-keyword">\end</span>&#123;algorithmic&#125;<br><span class="hljs-keyword">\end</span>&#123;algorithm&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">Algorithm 1 CheckSum $(\mathrm{A}, \mathrm{x})$</th></tr></thead><tbody><tr><td align="left">Input: An array A and a value $\mathrm{x}$</td></tr><tr><td align="left">Output: $\mathrm{A}$ bool value show if there is two elements in $\mathrm{A}$ whose sum is $\mathrm{x}$</td></tr><tr><td align="left">$\mathrm{A} \leftarrow \operatorname{SORT}(\mathrm{A})$</td></tr><tr><td align="left">$\mathrm{n} \leftarrow$ length(n)</td></tr><tr><td align="left">for $\mathrm{i} \leftarrow 0$ to $\mathrm{n}$ do</td></tr><tr><td align="left">if Binary-search $(\mathrm{A}, \mathrm{x}-\mathrm{A}[\mathrm{i}], 1, \mathrm{n})$ then</td></tr><tr><td align="left">return true</td></tr><tr><td align="left">end if</td></tr><tr><td align="left">end for</td></tr><tr><td align="left">return false</td></tr></tbody></table><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>    <span class="hljs-keyword">\[</span> ... <span class="hljs-keyword">\]</span> <span class="hljs-comment">%行间公式（会对之前的文字换行，然后公式单独成行并居中显示）</span><br>    <span class="hljs-built_in">$</span> ... <span class="hljs-built_in">$</span> <span class="hljs-comment">%行内公式（让你的公式和之前的文字处于同一行）</span><br>    <br>    <span class="hljs-comment">%长公式的对齐</span><br>    <span class="hljs-keyword">\[</span><span class="hljs-keyword">\begin</span>&#123;aligned&#125; <br>    x =&#123;&#125;<span class="hljs-built_in">&amp;</span> a+b+c+&#123;&#125; <span class="hljs-keyword">\\</span><br>    <span class="hljs-built_in">&amp;</span>d+e+f+g<br>    <span class="hljs-keyword">\end</span>&#123;aligned&#125;<span class="hljs-keyword">\]</span><br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br><br><span class="hljs-comment">%需要对齐的公式组</span><br><span class="hljs-keyword">\begin</span>&#123;align&#125;<br>a <span class="hljs-built_in">&amp;</span>= b+c+d <span class="hljs-keyword">\\</span><br>x <span class="hljs-built_in">&amp;</span>= y+z<br><span class="hljs-keyword">\end</span>&#123;align&#125;<br></code></pre></td></tr></table></figure><h2 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-comment">%这是单行注释</span><br><span class="hljs-keyword">\begin</span>&#123;comment&#125;<br>这是<br>多行注释<br><span class="hljs-keyword">\end</span>&#123;comment&#125;<br><br><span class="hljs-keyword">\alpha</span> <span class="hljs-comment">%α</span><br><span class="hljs-keyword">\boldsymbol</span>&#123;<span class="hljs-keyword">\alpha</span>&#125; <span class="hljs-comment">%加粗</span><br>x<span class="hljs-built_in">^</span>&#123;a+b&#125; <span class="hljs-comment">%上标</span><br>y<span class="hljs-built_in">_</span>&#123;2k+1&#125; <span class="hljs-comment">%下标</span><br><span class="hljs-keyword">\sqrt</span>[3]&#123;2&#125; <span class="hljs-comment">%三次根号2</span><br><span class="hljs-keyword">\vec</span>&#123;a&#125; <span class="hljs-comment">%向量</span><br><span class="hljs-keyword">\left</span>[ <span class="hljs-keyword">\matrix</span>&#123; 1 <span class="hljs-built_in">&amp;</span> x <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">^</span>2<span class="hljs-keyword">\\</span> 1 <span class="hljs-built_in">&amp;</span> y <span class="hljs-built_in">&amp;</span> y<span class="hljs-built_in">^</span>2<span class="hljs-keyword">\\</span> 1 <span class="hljs-built_in">&amp;</span> z <span class="hljs-built_in">&amp;</span> z<span class="hljs-built_in">^</span>2 &#125; <span class="hljs-keyword">\right</span>]  <span class="hljs-comment">%矩阵</span><br>X=<span class="hljs-keyword">\left</span>| <span class="hljs-keyword">\begin</span>&#123;matrix&#125; x<span class="hljs-built_in">_</span>&#123;11&#125; <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;12&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\cdots</span> <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;1d&#125;<span class="hljs-keyword">\\</span> x<span class="hljs-built_in">_</span>&#123;21&#125; <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;22&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\cdots</span> <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;2d&#125;<span class="hljs-keyword">\\</span> <span class="hljs-keyword">\vdots</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\vdots</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\ddots</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\vdots</span> <span class="hljs-keyword">\\</span> x<span class="hljs-built_in">_</span>&#123;11&#125; <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;12&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\cdots</span> <span class="hljs-built_in">&amp;</span> x<span class="hljs-built_in">_</span>&#123;1d&#125;<span class="hljs-keyword">\\</span> <span class="hljs-keyword">\end</span>&#123;matrix&#125; <span class="hljs-keyword">\right</span>| <span class="hljs-comment">%行列式</span><br></code></pre></td></tr></table></figure><p>$$<br>\left[ \matrix{ 1 &amp; x &amp; x^2\ 1 &amp; y &amp; y^2\ 1 &amp; z &amp; z^2 } \right]  %矩阵<br>X&#x3D;\left| \begin{matrix} x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\ x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\ \end{matrix} \right| %行列式<br>$$</p><ul><li>字母表：</li></ul><table><thead><tr><th><strong>小写字母代码</strong></th><th><strong>小写字母效果</strong></th><th><strong>大写字母代码</strong></th><th><strong>大写字母效果</strong></th><th><strong>异体字母代码</strong></th><th><strong>异体字母效果</strong></th></tr></thead><tbody><tr><td>$\alpha$</td><td>α  \alphaα</td><td>$\Alpha$</td><td>A  \AlphaA</td><td></td><td></td></tr><tr><td>$\beta$</td><td>β  \betaβ</td><td>$\Beta$</td><td>B  \BetaB</td><td></td><td></td></tr><tr><td>$\gamma$</td><td>γ  \gammaγ</td><td>$\Gamma$</td><td>Γ  \GammaΓ</td><td></td><td></td></tr><tr><td>$\delta$</td><td>δ  \deltaδ</td><td>$\Delta$</td><td>Δ  \DeltaΔ</td><td></td><td></td></tr><tr><td>$\epsilon$</td><td>ϵ  \epsilonϵ</td><td>$\Epsilon$</td><td>E  \EpsilonE</td><td>$\varepsilon$</td><td>ε  \varepsilonε</td></tr><tr><td>$\zeta$</td><td>ζ  \zetaζ</td><td>$\Zeta$</td><td>Z  \ZetaZ</td><td></td><td></td></tr><tr><td>$\eta$</td><td>η  \etaη</td><td>$\Eta$</td><td>H  \EtaH</td><td></td><td></td></tr><tr><td>$\theta$</td><td>θ  \thetaθ</td><td>$\Theta$</td><td>Θ  \ThetaΘ</td><td>$\vartheta$</td><td>ϑ  \varthetaϑ</td></tr><tr><td>$\iota$</td><td>ι  \iotaι</td><td>$\Iota$</td><td>I  \IotaI</td><td></td><td></td></tr><tr><td>$\kappa$</td><td>κ  \kappaκ</td><td>$\Kappa$</td><td>K  \KappaK</td><td>$\varkappa$</td><td>ϰ \varkappaϰ</td></tr><tr><td>$\lambda$</td><td>λ  \lambdaλ</td><td>$\Lambda$</td><td>Λ  \LambdaΛ</td><td></td><td></td></tr><tr><td>$\mu$</td><td>μ  \muμ</td><td>$\Mu$</td><td>M  \MuM</td><td></td><td></td></tr><tr><td>$\nu$</td><td>ν  \nuν</td><td>$\Nu$</td><td>N  \NuN</td><td></td><td></td></tr><tr><td>$\xi$</td><td>ξ  \xiξ</td><td>$\Xi$</td><td>Ξ  \XiΞ</td><td></td><td></td></tr><tr><td>$\omicron$</td><td>ο  \omicronο</td><td>$\Omicron$</td><td>O  \OmicronO</td><td></td><td></td></tr><tr><td>$\pi$</td><td>π  \piπ</td><td>$\Pi$</td><td>Π  \PiΠ</td><td>$\varpi$</td><td>ϖ  \varpiϖ</td></tr><tr><td>$\rho$</td><td>ρ  \rhoρ</td><td>$\Rho$</td><td>P  \RhoP</td><td>$\varrho$</td><td>ϱ  \varrhoϱ</td></tr><tr><td>$\sigma$</td><td>σ  \sigmaσ</td><td>$\Sigma$</td><td>Σ  \SigmaΣ</td><td>$\varsigma$</td><td>ς  \varsigmaς</td></tr><tr><td>$\tau$</td><td>τ  \tauτ</td><td>$\Tau$</td><td>T  \TauT</td><td></td><td></td></tr><tr><td>$\upsilon$</td><td>υ  \upsilonυ</td><td>$\Upsilon$</td><td>Υ  \UpsilonΥ</td><td></td><td></td></tr><tr><td>$\phi$</td><td>ϕ  \phiϕ</td><td>$\Phi$</td><td>Φ  \PhiΦ</td><td>$\varphi$</td><td>φ  \varphiφ</td></tr><tr><td>$\chi$</td><td>χ  \chiχ</td><td>$\Chi$</td><td>X  \ChiX</td><td></td><td></td></tr><tr><td>$\psi$</td><td>ψ  \psiψ</td><td>$\Psi$</td><td>Ψ  \PsiΨ</td><td></td><td></td></tr><tr><td>$\omega$</td><td>ω  \omegaω</td><td>$\Omega$</td><td>Ω  \OmegaΩ</td><td></td><td></td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h2><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a><strong>基本运算符</strong></h3><p>± ：\pm</p><p>× ：\times</p><p>÷：\div</p><p>∣：\mid</p><p>log ：\log</p><p>lg ：\lg</p><p>ln ：\ln</p><h3 id="比较符号"><a href="#比较符号" class="headerlink" title="比较符号"></a><strong>比较符号</strong></h3><p>≤：\leq</p><p>≥：\geq</p><p>≠：\neq</p><p>≈：\approx</p><p>≡：\equiv</p><p>∑：\sum</p><p>∏：\prod</p><p>∐：\coprod</p><h3 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a><strong>微积分</strong></h3><p>y′：y^\prime</p><p>∫：\int</p><p>∬ ：\iint</p><p>∭ ：\iiint</p><p>⨌：\iiiint</p><p>∮ ：\oint</p><p>lim ：\lim</p><p>∞ ：\infty</p><p>∇：\nabla</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>分段函数：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">y= <span class="hljs-keyword">\begin</span>&#123;cases&#125;<br>-x,<span class="hljs-keyword">\quad</span> x<span class="hljs-keyword">\leq</span> 0 <span class="hljs-keyword">\\</span><br>x,<span class="hljs-keyword">\quad</span> x&gt;0<br><span class="hljs-keyword">\end</span>&#123;cases&#125; <br></code></pre></td></tr></table></figure><p>$$<br>y&#x3D; \begin{cases}<br>-x,\quad x\leq 0 \<br>x,\quad x&gt;0<br>\end{cases}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>读研</category>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>科研</tag>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎来到昨夜如梦的梦之夜！</title>
    <link href="/2023/07/11/hello-world/"/>
    <url>/2023/07/11/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里是昨夜如梦的梦之夜。在这里我构筑了我的知识星球，并带你康康什么是快乐星球~~</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=446935665&auto=1&height=66"></iframe>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分治</title>
    <link href="/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/"/>
    <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*适用于所有在单调线性的区间上进行定位的问题！（务必确定是完全的单调！）<br>*有时滑动窗口优于二分查找！</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="经典二分查找"><a href="#经典二分查找" class="headerlink" title="经典二分查找"></a>经典二分查找</h2><p>查找分＞、＜、&#x3D;三种情况，只有一个相等的值</p><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><ul><li><p>Python</p><p>库函数 bisect(), bisect_left()和bisect_right()：</p><ul><li><p>bisect()和bisect_right()等同。</p></li><li><p>如果列表中没有元素x，那么bisect_left(ls, x)和bisec_right(ls, x)返回相同的值，该值是x在ls中“合适的插入点索引，使得数组有序”。</p></li><li><p>如果列表中只有一个元素等于x，那么bisect_left(ls, x)的值是x在ls中的索引，ls[index2] &#x3D; x。而bisec_right(ls, x)的值是x在ls中的索引加1。</p></li><li><p>如果列表中存在多个元素等于x，那么bisect_left(ls, x)返回最左边的那个索引，此时ls[index2] &#x3D; x。bisect_right(ls, x)返回最右边的那个索引加1。（结合两类函数的定义可以判断列表中是否含有此函数）</p></li></ul></li><li><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(Object[] a, Object key)</span>；<span class="hljs-comment">//有则返回索引无则返回-1</span><br></code></pre></td></tr></table></figure></li><li><p>C++</p><ul><li><p>lower_bound(数组名+l，数组名+r，tm)：返回大于或等于目标值的第一个位置</p></li><li><p>upper_bound(数组名+l，数组名+r，tm)：返回大于目标值的第一个位置</p></li><li><p>binary_search(数组名+l，数组名+r，tm)：若目标值存在则返回true，否则返回false</p></li></ul></li></ul><h3 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">l=head<br>r=tail<br><span class="hljs-keyword">while</span> l&lt;=r:<br>        m=(l+r)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> a[m]&lt;TM:<br>                l=m+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> a[m]&gt;TM:<br>                r=m-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><span class="hljs-comment">#a[m]即为TM值</span><br></code></pre></td></tr></table></figure><h2 id="不存在等于的情况"><a href="#不存在等于的情况" class="headerlink" title="不存在等于的情况"></a>不存在等于的情况</h2><p>从某个值开始往上&#x2F;下就一直满足条件,用类型为布尔值的check函数检验，寻找值为True的最值</p><p>无库函数，只能手搓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Python">l=head<br>r=tail<br><span class="hljs-keyword">while</span> l&lt;=r:<br>        m=(l+r)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> check(): <span class="hljs-comment">#如果是查找最小值则添一个not</span><br>            l=m+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            r=m-<span class="hljs-number">1</span><br><span class="hljs-comment">#求最小/大值时，l/r为TM</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划dp</title>
    <link href="/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dp/"/>
    <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dp/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果（有重叠就有希望，看上去不太合理的一遍遍历也有可能成功！）</p><p>*无后效性：一旦一个子问题的求解得到结果，以后的计算过程就不会修改它</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>*核心在于建立状态转移方程，从而实现递归（PS:状态之间可能会有二维的关系，即还得分行列两种情况再递归下去）<br>*一种递归方式不行的话试试另一种思路<br>*建立备忘录或者每次更新一遍有关的变量（“我为人人&#x2F;人人为我”）<br>*自底向上：递推<br> 自顶向下：记忆化递归<br>*试着以做一些有价值的记录为切入口，用空间置换时间！<br>*可以尝试状压DP:进制编码化，用编号代表状态~</p><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><p>*dp数组初始值可设置为-1，便于在dp某元素实际应有值就为零，遍历过后自然还是零时区分它有没有遍历过（不然还得用一个book数组去记录）</p><p>*dp数组设置长度时至少要包括已经定好的几个dp元素值！（如已经确定dp[0]&#x3D;0,dp[1]&#x3D;1,dp[2]&#x3D;2,则dp长度至少应为3，此时用max(len(list),3)作为其长度即可）</p><p>*遍历可以试着从右往左遍历，可能更简单！</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论</title>
    <link href="/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gcd</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> b:<br>        <span class="hljs-keyword">return</span> a<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> gcd(b, a%b)<br></code></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> n? <span class="hljs-built_in">gcd</span>(n, m% n): m;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><h2 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h2><p>正整数 $\mathrm{m} 1, \mathrm{<del>m} 2, \ldots, \mathrm{mk}$ 两两互素，对 $\mathrm{b} 1, \mathrm{</del>b} 2, \ldots, \mathrm{bk}$ 的同余式组为<br>$$<br>\left{\begin{array}{c}<br>x \equiv b_1 \bmod m_1 \<br>x \equiv b_2 \bmod m_2 \<br>\vdots \<br>x \equiv b_k \bmod m_k<br>\end{array}\right.<br>$$<br>在 $\bmod \mathrm{M}$<br>$$<br>M&#x3D;\prod_{i&#x3D;1}^k m_i<br>$$<br>的情况下有唯一解<br>$$<br>x&#x3D;\left(\sum_{i&#x3D;1}^k b_i M_i M_i^{\prime}\right) \bmod M<br>$$<br>其中<br>$$<br>\begin{gathered}<br>M_i&#x3D;\frac{M}{m_i} \<br>M_i^{\prime}&#x3D;M_i^{-1} \bmod m_i<br>\end{gathered}<br>$$<br>注：Mi^-1为Mi的逆元，即二者相乘模mi为1</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>其他部分自己照着原理写，给出求逆元算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inv</span>(<span class="hljs-params">n,m</span>): <span class="hljs-comment">#n已经保证比m小了</span><br>        <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> (m-m//n)*inv(m%n)%m <br></code></pre></td></tr></table></figure><p>这里给出快速幂的计算方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">pow</span> <span class="hljs-params">(<span class="hljs-type">long</span> cnt)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-type">long</span> part = <span class="hljs-built_in">pow</span>(cnt / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> part * part;<br>    <span class="hljs-keyword">return</span> a * part * part;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博弈论</title>
    <link href="/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>后继（局面）：某步操作局面后每一步操作导致的局面</p><h1 id="所有ICG游戏（普适）"><a href="#所有ICG游戏（普适）" class="headerlink" title="所有ICG游戏（普适）"></a>所有ICG游戏（普适）</h1><p>*对于一个ICG游戏，可以将其拆分为若干个分游戏，每个游戏的局面都可以用SG函数值描述状态，而总游戏的状态则为其分游戏异或的结果。</p><p>*SG函数：</p><ul><li><p>为0则必败，非0则必胜</p></li><li><p>SG(x)&#x3D;mex{SG(y)|y是x的后继}；其中mex(A)&#x3D;最小的不属于集合A的非负整数</p></li></ul><h1 id="典型ICG游戏"><a href="#典型ICG游戏" class="headerlink" title="典型ICG游戏"></a>典型ICG游戏</h1><h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>若干堆石子，每堆石子的数量都是有限的，双方轮流选择一堆石子，并取走至少1个石子，取走最后一个石子的玩家获胜（对方无法操作）。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>假设有n堆石子，第i堆石子数量为ai，则若a1⊕a2⊕…an&#x3D;0，先手必败，反之先手必胜。</p><h3 id="证明提示"><a href="#证明提示" class="headerlink" title="证明提示"></a>证明提示</h3><p>数列a都转化为二进制后，使得数列每一位上1的个数都为偶数</p><h2 id="反nim游戏"><a href="#反nim游戏" class="headerlink" title="反nim游戏"></a>反nim游戏</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>取走最后一个石子的玩家输~</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>先手必胜当且仅当：</p><p>所有堆的石子数都为1且游戏的SG值为0</p><p>至少一堆石子数大于1且游戏的SG值不为0</p><h2 id="树上删边"><a href="#树上删边" class="headerlink" title="树上删边"></a>树上删边</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>给定一个有N个节点的树，节点1是树的根</p><p>双方轮流从树上选一条边删除，并移除所有和根节点不再相连的点（及与这些点关联的边）</p><p>先无法操作的玩家输掉游戏。</p><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>叶子节点的SG值为0，其它节点的SG值为其所有子节点的SG值加1后异或的结果。</p><p>（PS:树上加简单环：删除树上的偶环并将奇环转换为长度为1的链后转化为普通问题，结果不变，即二者等效）</p><h2 id="无向图删边"><a href="#无向图删边" class="headerlink" title="无向图删边"></a>无向图删边</h2><p>结论：将图中的偶环删掉，变为一个新点；将图中的奇环删掉，变为一个新点+新边，原图中所有与环相连的点连接到新点上</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配</title>
    <link href="/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>若为字符串在字典中的匹配可以考虑字典树</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> str2 <span class="hljs-keyword">in</span> str1: … <span class="hljs-comment">#布尔值</span><br>str1.find(str2) <span class="hljs-comment">#匹配成功则返回str2在str1中的开始下标，若匹配不成功则返回-1</span><br></code></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>给pat建立一个状态的索引（只与pat有关），从而在匹配时只要单向遍历txt即可，无需回溯搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#KMP算法</span><br><span class="hljs-comment">#首先计算next数组，即我们需要怎么去移位</span><br><span class="hljs-comment">#接着我们就是用暴力解法求解即可</span><br><span class="hljs-comment">#next是用递归来实现的</span><br><span class="hljs-comment">#这里是用回溯进行计算的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calNext</span>(<span class="hljs-params">str2</span>):<br>    i=<span class="hljs-number">0</span><br>    <span class="hljs-built_in">next</span>=[-<span class="hljs-number">1</span>]<br>    j=-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-built_in">len</span>(str2)-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span>(j==-<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> str2[i]==str2[j]):<span class="hljs-comment">#首次分析可忽略</span><br>            i+=<span class="hljs-number">1</span><br>            j+=<span class="hljs-number">1</span><br>            <span class="hljs-built_in">next</span>.append(j)<br>        <span class="hljs-keyword">else</span>:<br>            j=<span class="hljs-built_in">next</span>[j]<span class="hljs-comment">#会重新进入上面那个循环</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span><br><span class="hljs-built_in">print</span>(calNext(<span class="hljs-string">&#x27;abcabx&#x27;</span>))<span class="hljs-comment">#-1,0,0,0,1,2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">KMP</span>(<span class="hljs-params">s1,s2,pos=<span class="hljs-number">0</span></span>):<span class="hljs-comment">#从那个位置开始比较</span><br>    <span class="hljs-built_in">next</span>=calNext(s2)<br>    i=pos<br>    j=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(i&lt;<span class="hljs-built_in">len</span>(s1) <span class="hljs-keyword">and</span> j&lt;<span class="hljs-built_in">len</span>(s2)):<br>        <span class="hljs-keyword">if</span>(j==-<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> s1[i]==s2[j]):<br>            i+=<span class="hljs-number">1</span><br>            j+=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            j=<span class="hljs-built_in">next</span>[j]<br>    <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-built_in">len</span>(s2)):<br>        <span class="hljs-keyword">return</span> i -<span class="hljs-built_in">len</span>(s2)<span class="hljs-comment">#说明匹配到最后了</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>s1 = <span class="hljs-string">&quot;acabaabaabcacaabc&quot;</span><br>s2 = <span class="hljs-string">&quot;abaabcac&quot;</span><br><span class="hljs-built_in">print</span>(KMP(s1,s2))<br></code></pre></td></tr></table></figure><p>时间复杂度O(M+N)</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> index=string1.indexOf(string2[,start_index]) <span class="hljs-comment">//返回[从指定下标开始]第一次出现的指定子字符串在此字符串中的索引,若没找到则返回-1</span><br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="库函数-1"><a href="#库函数-1" class="headerlink" title="库函数"></a>库函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-type">char</span> p=<span class="hljs-built_in">strstr</span>(str1,str2); <span class="hljs-comment">//此函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL</span><br></code></pre></td></tr></table></figure><h2 id="KMP算法-1"><a href="#KMP算法-1" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>思想见上~</p><h3 id="完整KMP算法过程"><a href="#完整KMP算法过程" class="headerlink" title="完整KMP算法过程"></a>完整KMP算法过程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Index_KMP</span><span class="hljs-params">(string main,string pattern)</span></span><br><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//KMP模式匹配算法</span><br>    <span class="hljs-type">int</span> i=pos,j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=main[<span class="hljs-number">0</span>] &amp;&amp; j&lt;=pattern[<span class="hljs-number">0</span>])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!j || main[i]==pattern[j]) <span class="hljs-comment">//继续比较后继字符串</span><br>        &#123;<br>            i++;<br>            j++<br>        &#125;<br>        <span class="hljs-keyword">else</span> j=next[j]; <span class="hljs-comment">//pattern，即模式串向右移动</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;pattern[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> i-pattern[<span class="hljs-number">0</span>];<span class="hljs-comment">//匹配成功</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="next数组求解"><a href="#next数组求解" class="headerlink" title="next数组求解"></a>next数组求解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_next</span><span class="hljs-params">(string pattern,<span class="hljs-type">int</span> *next)</span></span><br><span class="hljs-function"></span>&#123;       <span class="hljs-comment">//求next数组</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;next[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;pattern[<span class="hljs-number">0</span>])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!j || pattern[i]==pattern[j])<br>        &#123;<br>            i++;<br>            j++;<br>            next[i]=j;<br>        &#125;<br>        <span class="hljs-keyword">else</span> j=next[j]; <span class="hljs-comment">//next[1]到next[j]已经有值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口&amp;双指针</title>
    <link href="/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>单向遍历时具有类似于二分查找的单调性质（一定要仔细辨认r是否是单调递增，不再回溯！）</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>下面分别给出板子。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">l,r,cnt,t=<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>length=<span class="hljs-built_in">len</span>(nums)<br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>    <span class="hljs-keyword">if</span> l:t/=nums[l-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">while</span> r&lt;length-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> t*nums[r+<span class="hljs-number">1</span>]&lt;target:<br>        t*=nums[r+<span class="hljs-number">1</span>]<br>        r+=<span class="hljs-number">1</span> <br>          <span class="hljs-comment">#此时r为满足题意的窗口最右端</span><br>        <span class="hljs-keyword">if</span> r!=-<span class="hljs-number">1</span>:cnt+=r-l+<span class="hljs-number">1</span> <span class="hljs-comment">#r=-1的话就不能再加上这个结果了</span><br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l1): <span class="hljs-comment">#l1,l2分别为数组a,b的长度</span><br>    <span class="hljs-keyword">while</span> j&lt;l2 <span class="hljs-keyword">and</span> check(b[j],a[i]):j+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> j&gt;<span class="hljs-number">0</span>:j-=<span class="hljs-number">1</span> <span class="hljs-comment">#非常容易忘的一步！！！</span><br>    <span class="hljs-keyword">if</span> j==l2-<span class="hljs-number">1</span>:ans=best(ans,func(a[i]-b[j])) <span class="hljs-comment">#best()就是个取最值~</span><br>    <span class="hljs-keyword">else</span>:ans=best(ans,func(a[i],b[j]),func(b[j+<span class="hljs-number">1</span>],a[i]))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总体比较"><a href="#总体比较" class="headerlink" title="总体比较"></a>总体比较</h1><table><thead><tr><th align="left">排序方法</th><th align="left">平均时间</th><th align="left">最好时间</th><th align="left">最坏时间</th></tr></thead><tbody><tr><td align="left">桶排序(不稳定)</td><td align="left">$O(n)$</td><td align="left">$O(n)$</td><td align="left">$O(n)$</td></tr><tr><td align="left">基数排序(稳定)</td><td align="left">$O(n)$</td><td align="left">$O(n)$</td><td align="left">$O(n)$</td></tr><tr><td align="left">归并排序(稳定)</td><td align="left">$O(n \operatorname{logn})$</td><td align="left">$O(n \operatorname{logn})$</td><td align="left">$O(n \log n)$</td></tr><tr><td align="left">快速排序(不稳定)</td><td align="left">$O(n \operatorname{logn})$</td><td align="left">$O(n \operatorname{logn})$</td><td align="left">$O\left(n^{\wedge} 2\right)$</td></tr><tr><td align="left">堆排序(不稳定)</td><td align="left">$O(n \operatorname{logn})$</td><td align="left">$O(n \operatorname{logn})$</td><td align="left">$O(n \operatorname{logn})$</td></tr><tr><td align="left">希尔排序(不稳定)</td><td align="left">$O\left(n^{\wedge} 1.25\right)$</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">冒泡排序(稳定)</td><td align="left">$O\left(n^{\wedge} 2\right)$</td><td align="left">$O(n)$</td><td align="left">$O\left(n^{\wedge} 2\right)$</td></tr><tr><td align="left">选择排序(不稳定)</td><td align="left">$O\left(n^{\wedge} 2\right)$</td><td align="left">$O\left(n^{\wedge} 2\right)$</td><td align="left">$O\left(n^{\wedge} 2\right)$</td></tr><tr><td align="left">直接揷入排序(稳定)</td><td align="left">$O\left(n^{\wedge} 2\right)$</td><td align="left">$(n)$</td><td align="left">$O\left(n^{\wedge} 2\right)$</td></tr></tbody></table><ul><li><p>当数据规模较小的时候，可以用简单的排序算法如直接插入排序或直接选择排序。</p></li><li><p>当文件的初态已经基本有序时，可以用直接插入排序或冒泡排序。</p></li><li><p>当数据规模比较大且较为无序时，应用速度快的排序算法，可以考虑用快速排序。</p></li><li><p>堆排序不会出现快排那样的最坏情况，且堆排序所需的辅助空间比快排要少，但这两种算法都不是稳定的。若要求排序时稳定的，可以考虑用归并排序。</p></li><li><p>归并排序可以用于内排序，也可以用于外排序。在外排序时，通常采用多路归并，并且通过解决长顺串的合并，产生长的初始串，提高主机与外设并行能力等措施，以减少访问外存额次数，提高外排序的效率。</p></li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h2><p>每次将第i个数插入到前面i-1个排好序的数中</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>略~</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="总体思想-1"><a href="#总体思想-1" class="headerlink" title="总体思想"></a>总体思想</h2><p>设置一个gap变量，其从数组长度&#x2F;2开始逐渐再除二取整（直到gap为1），期间以gap为间隔的子数组分别各自内部排好序</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, k, tmp, gap;  <span class="hljs-comment">// gap 为步长</span><br>    <span class="hljs-keyword">for</span> (gap = len / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) <br>        &#123;  <span class="hljs-comment">// 步长初始化为数组长度的一半，每次遍历后步长减半,</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; gap; ++i) <br>            &#123; <span class="hljs-comment">// 变量 i 为每次分组的第一个元素下标 </span><br>            <span class="hljs-keyword">for</span> (j = i + gap; j &lt; len; j += gap) <br>                &#123; <span class="hljs-comment">//对步长为gap的元素进行直插排序，当gap为1时，就是直插排序</span><br>                tmp = a[j];  <span class="hljs-comment">// 备份a[j]的值</span><br>                k = j - gap;  <span class="hljs-comment">// j初始化为i的前一个元素（与i相差gap长度）</span><br>                <span class="hljs-keyword">while</span> (k &gt;= <span class="hljs-number">0</span> &amp;&amp; a[k] &gt; tmp) <br>                   &#123;<br>                    a[k + gap] = a[k]; <span class="hljs-comment">// 将在a[i]前且比tmp的值大的元素向后移动一位</span><br>                    k -= gap;<br>                &#125;<br>                a[k + gap] = tmp; <br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//此处可以输出中途每一步操作的排序结果</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, len, * a;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要排的数的个数：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;len);<br>    a = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(len * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 动态定义数组</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要排的数：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);  <br>    <span class="hljs-built_in">shellSort</span>(a, len); <span class="hljs-comment">// 调用希尔排序函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;希尔升序排列后结果为：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>,a[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="总体思想-2"><a href="#总体思想-2" class="headerlink" title="总体思想"></a>总体思想</h2><p>将每次的最左数作为基准数（枢轴值），两边各设置一个哨兵分别往中间走，遇到大于&#x2F;小于基准数的就交换，直到哨兵相遇，此时基准数已经到了最终的位置，且其左右的数分别比它都小&#x2F;大（实际上隐含了一颗递归树）（其中第一枢轴值为第一次此过程完成后两个哨兵交汇点的数组元素值）</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="输出每一轮结果"><a href="#输出每一轮结果" class="headerlink" title="输出每一轮结果"></a>输出每一轮结果</h3><p>即中途必须老老实实交换值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Qs</span><span class="hljs-params">(<span class="hljs-type">int</span> *n,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp=n[start],left=start,right=end;<span class="hljs-comment">//一定要记录下初始的起止点！！！</span><br>    <span class="hljs-keyword">if</span>(left&gt;right) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span>(left&lt;right)<span class="hljs-comment">//真正的快排（如此处）中途是会交换值的，只不过是我自己改写的简便写法不需要！！！</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; n[right]&gt;=temp) right--;<br>        n[left]=n[right];<br>        <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; n[left]&lt;=temp) left++;<br>        n[right]=n[left];<br>    &#125;<br>    n[left]=temp; <span class="hljs-comment">//此时的left为哨兵相遇的地方        </span><br>    <span class="hljs-built_in">Qs</span>(n,start,left<span class="hljs-number">-1</span>);<span class="hljs-comment">//这里的起始点是start而非left！！！</span><br>    <span class="hljs-built_in">Qs</span>(n,left+<span class="hljs-number">1</span>,end);<span class="hljs-comment">//同上！</span><br>    <span class="hljs-keyword">return</span>；<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简便写法"><a href="#简便写法" class="headerlink" title="简便写法"></a>简便写法</h3><p>不交换值：</p><ul><li><p>Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">qs</span>(<span class="hljs-params">array</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(array) &lt; <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> array<br>    t = array[<span class="hljs-number">0</span>]<br>    l = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &lt;= t] <span class="hljs-comment">#注意此处i即为array[…]!</span><br>    r = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &gt; t]<br>    <span class="hljs-keyword">return</span> qs(l) + [t] + qs(r)  <br><span class="hljs-comment">#这里可能会报错（不能相加），如果这样就开个temp[]列表去append元素t、extend列表l和r</span><br></code></pre></td></tr></table></figure></li><li><p>C++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qs</span><span class="hljs-params">(<span class="hljs-type">int</span> *n, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> t=n[<span class="hljs-number">0</span>],i,*l,*r,llen=<span class="hljs-number">0</span>,rlen=<span class="hljs-number">0</span>;<br>    l=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    r=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n[i]&lt;=t) l[llen++]=n[i];<br>        <span class="hljs-keyword">else</span> r[rlen++]=n[i];<br>    &#125;<br>    <span class="hljs-built_in">qs</span>(l,llen);<br>    <span class="hljs-built_in">qs</span>(r,rlen);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;llen;i++) n[i]=l[i];<br>    n[llen]=t;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;rlen;i++) n[i+llen+<span class="hljs-number">1</span>]=r[i];<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="总体思想-3"><a href="#总体思想-3" class="headerlink" title="总体思想"></a>总体思想</h2><p>建立最大堆，每次删除堆顶点（当前最大值）并将其传到记录的数组里</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="利用库函数"><a href="#利用库函数" class="headerlink" title="利用库函数"></a>利用库函数</h3><p>无论是要求输出每一轮结果还是仅仅是为了省时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span> <span class="hljs-comment">//用来支持大顶堆</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> heap[Max],ans[Max];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)<br>&#123;<br>    <span class="hljs-built_in">make_heap</span>(heap+<span class="hljs-number">1</span>,heap+len+<span class="hljs-number">2</span>-i,[less/<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()]);<span class="hljs-comment">//less为大顶堆</span><br>    ans[i]=heap[<span class="hljs-number">0</span>];<br>    heap[<span class="hljs-number">0</span>]=heap[len+<span class="hljs-number">1</span>-i];<br>    <span class="hljs-comment">//输出每一轮结果：</span><br>    <span class="hljs-comment">//int j;</span><br>        <span class="hljs-comment">//每一轮已排好序的元素：</span><br>        <span class="hljs-comment">//for(j=1;j&lt;=i;j++) cout&lt;&lt;ans[j]&lt;&lt;&quot; &quot;;</span><br>        <span class="hljs-comment">//cout&lt;&lt;endl;</span><br>        <span class="hljs-comment">//每一轮剩下的堆：</span><br>        <span class="hljs-comment">//for(j=1;j&lt;=len-i;j++) cout&lt;&lt;heap[j]&lt;&lt;&quot; &quot;;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//heap下标从1开始</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> *n, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,temp;<br>    temp=n[p];<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>*p;i&lt;=len;i*=<span class="hljs-number">2</span>) <br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;len &amp;&amp; heap[i]&lt;heap[i+<span class="hljs-number">1</span>]) i++;<br>        <span class="hljs-keyword">if</span>(temp&gt;=heap[i]) <span class="hljs-keyword">break</span>;<br>        heap[p]=heap[i]; <br>        p=i;<br>    &#125;<br>    heap[p]=temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> *heap, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,ans[Max];<br>    <span class="hljs-comment">//构造大顶堆</span><br>    <span class="hljs-keyword">for</span> (i=len/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">HeapAdjust</span>(heap,i,len);<br>    <span class="hljs-comment">//依次取出当前的最大元素</span><br>    <span class="hljs-keyword">for</span> (i=len;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        ans[i]=heap[<span class="hljs-number">1</span>];<br>        heap[<span class="hljs-number">1</span>]=heap[i];<br>        <span class="hljs-built_in">HeapAdjust</span>(heap,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);<br>           <span class="hljs-comment">//此处可以输出中途每一步操作的排序结果</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<span class="hljs-comment">//ans为升序排列！</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="总体思想-4"><a href="#总体思想-4" class="headerlink" title="总体思想"></a>总体思想</h2><p>*将数组不断两两拆分成子数组，直到不能再分后，先各自排好序，后不断递归将子数组两两合并，直到全部合并</p><p>*特点：效率高、稳定</p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ArrLen 20</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> i;<br>   <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\t&quot;</span>, arr[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> end)</span> </span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> result[ArrLen];<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = start;<br>        <span class="hljs-type">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) <br>        &#123;<br>                <span class="hljs-keyword">if</span> (arr[i] &lt; arr[j])&#123;          <br>                        result[k++] = arr[i++];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>                result[k++] = arr[j++];<br>        &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">while</span>(j &lt;= end)<br>                        result[k++] = arr[j++];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (j == end + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">while</span> (i &lt;= mid)<br>                        result[k++] = arr[i++];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, i = start ; j &lt; k; i++, j++) &#123;<br>                arr[i] = result[j];<br>        &#125;<br>        &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (start &gt;= end)<br>                <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = ( start + end ) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(arr, start, mid);<br>        <span class="hljs-built_in">mergeSort</span>(arr, mid + <span class="hljs-number">1</span>, end);<br>        <span class="hljs-built_in">merge</span>(arr, start, mid, end);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-built_in">mergeSort</span>(arr, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br>        <span class="hljs-built_in">printList</span>(arr, <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="总体思想-5"><a href="#总体思想-5" class="headerlink" title="总体思想"></a>总体思想</h2><p>由低位依次向更高位，每轮（一位）按基数（0-9，a-z）排好序（*一样则按原序）（若位数不同则可以填充最小值）</p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><p>三维数组即可，略~</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h1><h2 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h2><p>*以点为操作对象</p><ol><li><p>设置一个顶点集合S和一个边集合TE，S和TE的初始状态皆为空集。</p></li><li><p>选定图中的任意顶点K，从K开始生成最小生成树。(K加入集合S).</p></li><li><p>重复下列操作，直到选取了n-1条边为止：</p><p>(1)选取一条权最小的边(X，Y)，要求是X要是集合S的元素，Y不是集合S的元素</p><p>(2)将顶点加入到集合S中，将边 (X，Y) 加入集合TE中。</p></li><li><p>得到最小生成树T，T&#x3D; (S，TE)</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Prim算法生成最小生成树 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree_Prim</span><span class="hljs-params">(MGraph G)</span></span>&#123;<br><span class="hljs-type">int</span> min, i, j, k;<br><span class="hljs-type">int</span> adjvex[MAXVEX];<span class="hljs-comment">//保存相关顶点下标</span><br><span class="hljs-type">int</span> lowcost[MAXVEX];<span class="hljs-comment">//保存相关顶点间边的权值</span><br>lowcast[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化第一个权值为0，即v0加入生成树，lowcost的值为0，在这里就是此下标的顶点已经加入生成树</span><br>adjvex[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化第一个顶点下标为0</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i&lt;G.numVertexes;i++)&#123;<span class="hljs-comment">//循环除下标为0外的全部顶点</span><br>lowcost[i] = G.arc[<span class="hljs-number">0</span>][i];<span class="hljs-comment">//将v0顶点与之有边的权值存入数组</span><br>adjvex[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化都为v0的下标</span><br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;G.numVertexes;i++)&#123;<br>min = INFINITY;<span class="hljs-comment">//初始化最小权值为无穷大，通常设置为很大的数字</span><br>j = <span class="hljs-number">1</span>;<br>k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(j&lt;G.numVertexes)&#123;<span class="hljs-comment">//循环全部顶点</span><br><span class="hljs-keyword">if</span>(lowcost[j] != <span class="hljs-number">0</span> &amp;&amp; lowcost[j] &lt; min)&#123;<span class="hljs-comment">//如果权值不为0且权值小于min</span><br>min = lowcost[j];<span class="hljs-comment">//让当前权值成为最小值</span><br>k = j;<span class="hljs-comment">//将当前最小值的下标存入k</span><br>&#125;<br>j++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d)&quot;</span>,adjvex[k],k);<span class="hljs-comment">//打印当前顶点边中权值最小边</span><br>lowcost[k] = <span class="hljs-number">0</span>;<span class="hljs-comment">//将当前顶点的权值设置为0，表示此顶点已经完成任务</span><br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;G.numVertexes;j++)&#123;<span class="hljs-comment">//循环所有顶点</span><br><span class="hljs-keyword">if</span>(lowcost[j] != <span class="hljs-number">0</span> &amp;&amp; G.arc[k][j] &lt; lowcost[j])&#123;<span class="hljs-comment">//若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值</span><br>lowcost[j] = G.arc[k][j];<span class="hljs-comment">//将较小权值存入lowcost</span><br>adjvex[j] = k;<span class="hljs-comment">//将下标为k的顶点存入adjvex</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Prim算法</span><br>base=[]<br>tm=pointset<br>base=tm.pop()<br>n=<span class="hljs-built_in">len</span>(edge)<br>inf=<span class="hljs-number">10000</span>… <span class="hljs-comment">#一个超过给定边权最大值的数</span><br>edge=[[inf <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>edge… <span class="hljs-comment">#输入</span><br><span class="hljs-keyword">while</span> tm:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> base:<br>        best=inf<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> tm:<br>            <span class="hljs-keyword">if</span> edge[i][j]!=inf <span class="hljs-keyword">and</span> edge[i][j]&lt;best:<br>                best=edge[i][j]<br>                ans=j<br>                base.append(ans)<br>                tm.remove(ans)<br></code></pre></td></tr></table></figure><h1 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h1><h2 id="总体思想-1"><a href="#总体思想-1" class="headerlink" title="总体思想"></a>总体思想</h2><p>*以边为核心对象</p><ol><li>设最小生成树为T，T&#x3D; (S，TE) ，TE初始状态为空集。</li><li>将图中的边权从小到大依次排序。</li><li>选取权最小的边，若这条边没有使T构成回路，就将这条边加入TE中(T保留了这条边);若构成回路，则舍弃，不能加入TE中。</li><li>再选取最小边，重复执行第三步，直到TE中包含n-1条边为止，最后的T即为最小生成树。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 对边集数组Edge结构的定义 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br><span class="hljs-type">int</span> begin;<br><span class="hljs-type">int</span> end;<br><span class="hljs-type">int</span> weight;<br>&#125;Edge;<br><br><span class="hljs-comment">/* kruskal算法生成最小生成树 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiniSpanTree</span><span class="hljs-params">(MGraph G)</span></span>&#123;<span class="hljs-comment">//生成最小生成树</span><br><span class="hljs-type">int</span> i, n, m;<br>Edge edges[MAXEDGE];<span class="hljs-comment">//定义边集数组</span><br><span class="hljs-type">int</span> parent[MAXVEX];<span class="hljs-comment">//定义一数组用来判断边与边是否形成环路</span><br><span class="hljs-comment">/* 此处省略将邻接矩阵G转化为边集数组edges并按权由小到大排序的代码 */</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;G.numVertexes;i++)<br>parent[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化数组值为0</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;G.numEdges;i++)&#123;<span class="hljs-comment">//循环每一条边</span><br>n = <span class="hljs-built_in">Find</span>(parent, edges[i].begin);<br>m = <span class="hljs-built_in">Find</span>(parent, edges[i].end);<br><span class="hljs-keyword">if</span>(n != m)&#123;<span class="hljs-comment">//假如n与m不等，说明此边没有与现有生成树形成环路</span><br>parent[n] = m;<span class="hljs-comment">//将此边的结尾顶点放入下标为起点的parent中，表示此顶点已经在生成树集合中</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d) %d&quot;</span>, edges[i].begin, edges[i].end, edges[i].weight);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span>* parent, <span class="hljs-type">int</span> f)</span></span>&#123;<span class="hljs-comment">//查找连线顶点的尾部下标</span><br><span class="hljs-keyword">while</span>(parent[f] &gt; <span class="hljs-number">0</span>)<br>f = parent[f];<br><span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广度优先搜索BFS</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2BFS/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2BFS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>适用于求解最值问题（因为它搜索到的解一定是路径最短的解）</p><h1 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h1><p>*就是枚举</p><p>*每次都把能走的路都试了，不再回溯</p><p>*找到了即停止搜索</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>*用队列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>queue=deque()<br>queue.append((x,y))<br></code></pre></td></tr></table></figure><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><h3 id="一般板子"><a href="#一般板子" class="headerlink" title="一般板子"></a>一般板子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i … : <span class="hljs-comment">#实际上属于&quot;一main到底&quot;,此处看情况需不需要对queue进行初始的元素加入(如果这样一般无需再双重循环遍历)</span><br><span class="hljs-keyword">for</span> j … :<br><span class="hljs-keyword">if</span> book[i][j]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> … :<br>queue.append([x,y])<span class="hljs-comment">#queue不是一般的列表，而是双向队列deque！</span><br>book[i][j]=<span class="hljs-number">1</span><br>cnt+=<span class="hljs-number">1</span> <span class="hljs-comment">#记录广搜的总次数（看题意需不需要记录，记得cnt=0初始化！）</span><br><span class="hljs-keyword">while</span> queue:<br>x,y=queue.popleft()<span class="hljs-comment">#注意这里是popleft而非pop！</span><br><span class="hljs-keyword">for</span> nx,ny <span class="hljs-keyword">in</span> [[x-<span class="hljs-number">1</span>,y],…]:<br><span class="hljs-keyword">if</span> book[nx][ny]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> … :<br>book[nx][ny]=<span class="hljs-number">1</span><br>queue.append([nx,ny])<br></code></pre></td></tr></table></figure><p>PS：本来为取值为0，1的二维题可以省去book！</p><h3 id="最优解板子"><a href="#最优解板子" class="headerlink" title="最优解板子"></a>最优解板子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">queue.append(n,<span class="hljs-number">0</span>) <span class="hljs-comment">#n为最终目标，0为目前步数</span><br><span class="hljs-keyword">while</span> queue:<br>        tm,step=queue.popleft()<br>        <span class="hljs-keyword">for</span> i … : <span class="hljs-comment">#遍历所有可能路径</span><br>                <span class="hljs-keyword">if</span> … : <span class="hljs-keyword">return</span> step+<span class="hljs-number">1</span> <span class="hljs-comment">#已经满足目标则返回</span><br>                <span class="hljs-keyword">elif</span> … <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> book[…]: <span class="hljs-comment">#仍没达目标但满足题目条件时，若未标记则继续加入队列</span><br>                        queue.append(tm-…,step+<span class="hljs-number">1</span>)<br>                        book[…]=<span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <span class="hljs-comment">#全部遍历完仍未搜索到则返回-1</span><br></code></pre></td></tr></table></figure><h3 id="记忆型板子"><a href="#记忆型板子" class="headerlink" title="记忆型板子"></a>记忆型板子</h3><p>记录走过的路径：不再用队列而是用栈！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">stack=[]<br>stack.append([start_x,start_y]) <span class="hljs-comment">#起点</span><br><span class="hljs-built_in">next</span>=[[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>]]<br>ans=[]<br>l=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> stack:<br>    temp_x,temp_y=stack.pop()<br>    ans.append([temp_x,temp_y])<br>    l+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> temp_x==end_x <span class="hljs-keyword">and</span> temp_y==end_y:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ans:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(&#123;&#125;,&#123;&#125;)-&gt;&quot;</span>.<span class="hljs-built_in">format</span>(i[<span class="hljs-number">0</span>],i[<span class="hljs-number">1</span>]),end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\b\b&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">next</span>:<br>        <span class="hljs-keyword">if</span> up_boundary&lt;=temp_x+i[<span class="hljs-number">0</span>]&lt;=down_boundary <span class="hljs-keyword">and</span> left_boundary&lt;=temp_y+i[<span class="hljs-number">1</span>]&lt;=right_boundary <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> maze[temp_x+i[<span class="hljs-number">0</span>]][temp_y+i[<span class="hljs-number">1</span>]]: <span class="hljs-comment">#maze意为迷宫</span><br>            maze[temp_x+i[<span class="hljs-number">0</span>]][temp_y+i[<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span><br>            stack.append([temp_x+i[<span class="hljs-number">0</span>],temp_y+i[<span class="hljs-number">1</span>]])<br>    <span class="hljs-keyword">while</span> ans:<br>        <span class="hljs-keyword">if</span> ans[-<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> stack: ans.pop()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ans:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Not found.&quot;</span>)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>《啊哈！算法》里的“拯救小美”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-type">int</span> f;<span class="hljs-comment">//父亲在队列中的编号。？？？干啥用的呢？有点像课本上的那个呀。</span><br>&#125;;<br>node que[<span class="hljs-number">2501</span>];<br><span class="hljs-type">int</span> head,tail;<br><span class="hljs-comment">//mmp数组表示地图</span><br><span class="hljs-type">int</span> mmp[<span class="hljs-number">51</span>][<span class="hljs-number">51</span>];<br><span class="hljs-comment">//Book数组用来记录哪些点已经在队列中，防止一个点被重复扩展.....为啥教材上没有呢？</span><br><span class="hljs-type">int</span> Book[<span class="hljs-number">51</span>][<span class="hljs-number">51</span>];<br><span class="hljs-comment">//定义一个用于表示走的方向的数组</span><br><span class="hljs-type">int</span> Next[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        <span class="hljs-built_in">cin</span>&gt;&gt;mmp[i][j];<br>    <span class="hljs-type">int</span> startx,starty,p,q;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;startx&gt;&gt;starty&gt;&gt;p&gt;&gt;q;<br>    head=tail=<span class="hljs-number">1</span>;<br>    que[tail].x=startx;<br>    que[tail].y=starty;<br>    que[tail].f=<span class="hljs-number">0</span>;<br>    que[tail].s=<span class="hljs-number">0</span>;<br>    tail++;<br>    Book[startx][starty]=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(head&lt;tail)<br>    &#123;<br>        <span class="hljs-type">int</span> tx,ty;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>        &#123;<br>            tx=que[head].x+Next[i][<span class="hljs-number">0</span>];<br>            ty=que[head].y+Next[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(tx&lt;<span class="hljs-number">1</span>||ty&lt;<span class="hljs-number">1</span>||tx&gt;n||ty&gt;m) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(Book[tx][ty]==<span class="hljs-number">0</span>&amp;&amp;mmp[tx][ty]==<span class="hljs-number">0</span>)<br>            &#123;<br>                que[tail].x=tx;<br>                que[tail].y=ty;<br>                tail++;<br>                Book[tx][ty]=<span class="hljs-number">1</span>;<br>                mmp[tx][ty]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(que[head].x==p&amp;&amp;que[head].y==q)<br>        &#123;<br>            flag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        head++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>) <span class="hljs-built_in">cout</span>&lt;&lt;que[head].x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;que[head].y&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br> <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">5 4</span><br><span class="hljs-comment">0 0 1 0</span><br><span class="hljs-comment">0 0 0 0</span><br><span class="hljs-comment">0 0 1 0</span><br><span class="hljs-comment">0 1 0 0</span><br><span class="hljs-comment">0 0 0 1</span><br><span class="hljs-comment">1 1 4 3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索DFS</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2DFS/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2DFS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*几乎可以应用于任何问题！</p><p>*适用于找出所有解的问题</p><p>*在深度较大时效率较低</p><h1 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h1><p>*就是枚举</p><p>*每次都把路先走到最深，实在走不下去了再一步步逐一回溯搜索，用递归函数或栈来实现</p><p>*同样是深搜，也要尽量寻找简单的思路！（如果涉及了太多条件则也要思考有无简单办法）</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x,y</span>): <span class="hljs-comment">#参数在问题为一维时也可以是step</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">0</span>&lt;=x&lt;m <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>&lt;=y&lt;n <span class="hljs-keyword">or</span> book[x][y] <span class="hljs-keyword">or</span> … :<span class="hljs-comment">#已经走到尽头了(也有可能是step==n等等）</span><br>…<span class="hljs-comment">#执行走到尽头时该干的事（检验是否满足条件然后count++等等）</span><br><span class="hljs-keyword">return</span><br>book[x][y]=<span class="hljs-number">1</span> <span class="hljs-comment">#标记这路走过了</span><br>… <span class="hljs-comment">#此时还需要执行的操作</span><br>dfs(x-<span class="hljs-number">1</span>,y) <span class="hljs-comment">#开始遍历所有的路</span><br>dfs(x,y+<span class="hljs-number">1</span>)<br>dfs(x+<span class="hljs-number">1</span>,y)<br>dfs(x,y-<span class="hljs-number">1</span>)<br><span class="hljs-comment">#有的题目还需要book[x][y]=0来把走过的路收回！</span><br><span class="hljs-comment">#写主函数</span><br><span class="hljs-keyword">for</span> i … :<br><span class="hljs-keyword">for</span> j … :<br><span class="hljs-keyword">if</span> book[i][j]==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> … :<br>dfs(i，j) <br></code></pre></td></tr></table></figure><p>PS：本来为取值为0，1的二维题可以省去book！</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p> 求出123的全排列，即123  132  213  231  312  321</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">//在全局变量中,数组默认为0</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>], book[<span class="hljs-number">5</span>], n = <span class="hljs-number">3</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> step)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-comment">//当数组a存放了1-3所有元素且每个数都是被标记过的,证明该序列满足</span><br><span class="hljs-keyword">if</span> (step == n + <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//执行路走到尽头时该做的操作</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br><span class="hljs-comment">//判断该位置是否被标记过</span><br><span class="hljs-keyword">if</span> (book[i] == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//再往深里走一步时要执行的操作，此处即把i存入到数组的第step的位置中</span><br>a[step] = i;<br><span class="hljs-comment">//标记i位置证明i已经存入到a数组当中</span><br>book[i] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//更新step继续执行循环</span><br>Dfs(step + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//将刚标记的位置收回,执行下一次尝试，这是非常重要且容易忘的一步！！！</span><br>book[i] = <span class="hljs-number">0</span>；<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//首先从第一个数字开始</span><br>Dfs(<span class="hljs-number">1</span>);<br>system(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多源最短路径</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>graph[i][j] = <span class="hljs-built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j])<br></code></pre></td></tr></table></figure><h2 id="Johnson"><a href="#Johnson" class="headerlink" title="Johnson"></a>Johnson</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>对于稀疏矩阵，减少了其在空间上的存储浪费，同时提高了效率</p><h3 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h3><p>结合单源最短路径中的几个算法（Bellman-Ford+Dijkstra）来解决（但不能理解？）</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求解稀疏矩阵图</span><br><span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">johnson</span>(<span class="hljs-params">G</span>):<br>    G = deepcopy(G)<br>    s = <span class="hljs-built_in">object</span>()<br>    G[s] = &#123;v: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G&#125;<br>    h, _ = bellman_ford(G, s)<br>    <span class="hljs-keyword">del</span> G[s]<br>    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G:<br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G[u]:<br>            G[u][v] += h[u] - h[v]<br>    D, P = <span class="hljs-built_in">dict</span>(), <span class="hljs-built_in">dict</span>()<br>    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G:<br>        D[u], P[u] = dijkstra(G, u)<br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> G:<br>            D[u][v] += h[v] - h[u]<br>    <span class="hljs-keyword">return</span> D, P<br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>*Floyd：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>&#123;<br><span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>&#123;<br><span class="hljs-keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j]=e[i][k]+e[k][j];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单源最短路径</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h1><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h3><p>主要针对的是有向图的单元最短路径问题，且不能出现权值为负的情况</p><h3 id="总体思想"><a href="#总体思想" class="headerlink" title="总体思想"></a>总体思想</h3><p>假设存在G&#x3D;&lt;V,E&gt;，源顶点为V0，S&#x3D;{V0},distance[i]记录V0到i的最短距离，matrix[i][j]记录从i到j的边的权值，即两点之间的距离。</p><ol><li><p>从V-S中选择使dist[i]值最小的顶点i，将i加入到U中；</p></li><li><p>更新与i直接相邻顶点的dist值。dist[j]&#x3D;min{dist[j],dist[i]+matrix[i][j]}</p></li><li><p>直到S&#x3D;V，所有顶点都包含进来了，算法停止。</p></li></ol><h2 id="Bellman-ford"><a href="#Bellman-ford" class="headerlink" title="Bellman ford"></a>Bellman ford</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>有向图，且允许出现负权重，复杂度略高（O(N^2)）</p><h3 id="总体思想-1"><a href="#总体思想-1" class="headerlink" title="总体思想"></a>总体思想</h3><p>首先初始化，对所有的节点V来说，所有的边E进行松弛操作，再然后循环遍历每条边，如果d[v] &gt; d[u] + w(u,v),表示有一个负权重的环路存在。最后如果没有负权重环路，那么d[v] 是最小路径值。</p><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>有向图，且允许出现负权重~</p><h3 id="总体思想-2"><a href="#总体思想-2" class="headerlink" title="总体思想"></a>总体思想</h3><p>每次选取队首顶点u的所有边进行松弛操作，假设有一条u到v的边，如果通过这条边使得源点到顶点v的最短路程变短，且顶点v不在当前队列中，就将顶点v放入队尾。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="Dijkstra-1"><a href="#Dijkstra-1" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dijkstra</span>(<span class="hljs-params">s</span>):<br>    distance[s] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># v在这里相当于是一个哨兵，对包含起点s做统一处理！</span><br>        v = -<span class="hljs-number">1</span><br>        <span class="hljs-comment"># 从未使用过的顶点中选择一个距离最小的顶点</span><br>        <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> used[u] <span class="hljs-keyword">and</span> (v == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> distance[u] &lt; distance[v]):<br>                v = u<br>        <span class="hljs-keyword">if</span> v == -<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 说明所有顶点都维护到S中了！</span><br>            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># 将选定的顶点加入到S中, 同时进行距离更新</span><br>        used[v] = <span class="hljs-literal">True</span><br>        <span class="hljs-comment"># 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</span><br>        <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(V):<br>            distance[u] = <span class="hljs-built_in">min</span>(distance[u], distance[v] + cost[v][u])<br></code></pre></td></tr></table></figure><h2 id="Bellman-ford-1"><a href="#Bellman-ford-1" class="headerlink" title="Bellman ford"></a>Bellman ford</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bellman_ford</span>(<span class="hljs-params">graph, source</span>):<br>    dist = &#123;&#125;<br>    p = &#123;&#125;<br>    <span class="hljs-built_in">max</span> = <span class="hljs-number">10000</span><br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph:<br>        dist[v] = <span class="hljs-built_in">max</span>  <span class="hljs-comment">#赋值为负无穷完成初始化</span><br>        p[v] = <span class="hljs-literal">None</span><br>    dist[source] = <span class="hljs-number">0</span><br> <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>( graph ) - <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:<br>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:<br>                <span class="hljs-keyword">if</span> dist[v] &gt; graph[u][v] + dist[u]:<br>                    dist[v] = graph[u][v] + dist[u]<br>                    p[v] = u    <span class="hljs-comment">#完成松弛操作，p为前驱节点</span><br> <br>    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:<br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:<br>            <span class="hljs-keyword">if</span> dist[v] &gt; dist[u] + graph[u][v]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>  <span class="hljs-comment">#判断是否存在环路</span><br>    <span class="hljs-keyword">return</span> dist, p<br></code></pre></td></tr></table></figure><h2 id="SPFA-1"><a href="#SPFA-1" class="headerlink" title="SPFA"></a>SPFA</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>q=deque()<br>q.append/extend(…)<br>book=[]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spfa</span>():<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q:<br>t=q.popleft()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> graph[t]: <span class="hljs-comment">#t的所有邻边</span><br><span class="hljs-keyword">if</span> ans[u]+edge[i][j]&lt;ans[v]:<br>q.append(v)<br><span class="hljs-keyword">if</span> book[v]&gt;n-<span class="hljs-number">1</span>: <span class="hljs-comment">#有负环</span><br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h1 id="Java-amp-C"><a href="#Java-amp-C" class="headerlink" title="Java &amp; C++"></a>Java &amp; C++</h1><p>以C++为例：</p><h2 id="Dijkstra-2"><a href="#Dijkstra-2" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dis[t]=<span class="hljs-number">0</span>;<span class="hljs-comment">//t为目标节点</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<br>&#123;<br>        <span class="hljs-comment">//找到离1号最近的顶点</span><br>        min=inf;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>                <span class="hljs-keyword">if</span>(book[j]==<span class="hljs-number">0</span>&amp;&amp;dis[j]&lt;min)<br>                &#123;<br>                        min=dis[j];<br>                        u=j;<br>                &#125;<br>         &#125; <br>        book[u]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(v=<span class="hljs-number">1</span>;v&lt;=n;v++)<br>        &#123;<br>                <span class="hljs-keyword">if</span>(e[u][v]&lt;inf)<br>                &#123;<br>                        <span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+e[u][v]) dis[v]=dis[u]+e[u][v];<br>                 &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓扑排序</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>推广：思想很重要！</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">topoSort</span>(<span class="hljs-params">graph</span>):     <br>    in_degrees = <span class="hljs-built_in">dict</span>((u,<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph)  <span class="hljs-comment">#初始化所有顶点入度为0     </span><br>    num = <span class="hljs-built_in">len</span>(in_degrees)     <br>    <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> graph:         <br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:             <br>            in_degrees[v] += <span class="hljs-number">1</span>    <span class="hljs-comment">#计算每个顶点的入度     </span><br>    Q = [u <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> in_degrees <span class="hljs-keyword">if</span> in_degrees[u] == <span class="hljs-number">0</span>]   <span class="hljs-comment"># 筛选入度为0的顶点     </span><br>    Seq = []     <br>    <span class="hljs-keyword">while</span> Q:         <br>        u = Q.pop()       <span class="hljs-comment">#默认从最后一个删除         </span><br>        Seq.append(u)         <br>        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> graph[u]:             <br>            in_degrees[v] -= <span class="hljs-number">1</span>    <span class="hljs-comment">#移除其所有出边</span><br>            <span class="hljs-keyword">if</span> in_degrees[v] == <span class="hljs-number">0</span>:        <br>                Q.append(v)          <span class="hljs-comment">#再次筛选入度为0的顶点</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(Seq) == num:       <span class="hljs-comment">#输出的顶点数是否与图中的顶点数相等</span><br>        <span class="hljs-keyword">return</span> Seq     <br>    <span class="hljs-keyword">else</span>:         <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span><span class="hljs-comment">//为了引入string型</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br>unordered_map&lt;string,<span class="hljs-type">int</span>&gt;indegrees;<span class="hljs-comment">//用字典来记录入度</span><br><span class="hljs-function">string <span class="hljs-title">topoSort</span><span class="hljs-params">(string *graph,<span class="hljs-type">int</span> l)</span> <span class="hljs-comment">//graph的元素是长度为2的字符数组</span></span><br><span class="hljs-function"></span>&#123; <br>        <span class="hljs-type">int</span> i,l1=<span class="hljs-number">0</span>,l2=<span class="hljs-number">0</span>;<span class="hljs-comment">//l1，l2分别为ans，q的长度</span><br>        string ans[N],q[N];<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=l;i++) indegrees[graph[i][<span class="hljs-number">0</span>]]=<span class="hljs-number">0</span>; <span class="hljs-comment">//初始化入度</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=l;i++) indegrees[graph[i][<span class="hljs-number">1</span>]]+=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(pair&lt;string,<span class="hljs-type">int</span>&gt; node:indegrees)<br>        &#123;<br>                <span class="hljs-keyword">if</span>(!indegrees.second) q[++l2]=indegrees.first);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q)<br>        &#123;<br>            <span class="hljs-built_in">strcpy</span>(t,q[l2--]);<br>            ans[++l1]=t;<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=l;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcpy</span>(graph[i][<span class="hljs-number">0</span>],t))<br>                &#123;<br>                    indegrees[grpah[i][<span class="hljs-number">1</span>]]-=<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(!indegrees[graph[i][<span class="hljs-number">1</span>]])<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(graph[i][<span class="hljs-number">1</span>]);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>()==num) <span class="hljs-comment">//输出的顶点是否与图中的顶点数相等</span><br>                        <span class="hljs-keyword">return</span> ans;<br>                <span class="hljs-keyword">return</span> Null;<br>         &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有、无向图有无环的判定</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E6%9C%89%E3%80%81%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%89%E6%97%A0%E7%8E%AF%E7%9A%84%E5%88%A4%E5%AE%9A/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/%E6%9C%89%E3%80%81%E6%97%A0%E5%90%91%E5%9B%BE%E6%9C%89%E6%97%A0%E7%8E%AF%E7%9A%84%E5%88%A4%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>全部由C++实现。</p><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ol><li>创建一个队列q，将入度为0的顶点全部加入队列。</li><li>当队列不为空时，取出首结点，[访问输出]，遍历其所有后继顶点，另后继结点的入度减一，判断若入度减一后为0，则将这后继顶点加入队列。再清除首结点从它出发的边，即后继结点。</li><li>步骤2结束意味着队列为空。判断加入拓扑序列的顶点数和图的顶点数n是否相等，若相等则证明拓扑排序成功，和该图是有向无环图。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">//为了引入string型</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br>unordered_map&lt;string,<span class="hljs-type">int</span>&gt;indegrees; <span class="hljs-comment">//用字典来记录入度</span><br><br><span class="hljs-function">string <span class="hljs-title">topoSort</span><span class="hljs-params">(string *graph,<span class="hljs-type">int</span> l)</span> <span class="hljs-comment">//graph的元素是长度为2的字符数组</span></span><br><span class="hljs-function"></span>&#123; <br>        <span class="hljs-type">int</span> i,l1=<span class="hljs-number">0</span>,l2=<span class="hljs-number">0</span>; <span class="hljs-comment">//l1，l2分别为ans，q的长度，ans为拓扑排序后的结果</span><br>        string ans[N],q[N];<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=l;i++) indegrees[graph[i][<span class="hljs-number">0</span>]]=<span class="hljs-number">0</span>; <span class="hljs-comment">//初始化入度</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=l;i++) indegrees[graph[i][<span class="hljs-number">1</span>]]+=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(pair&lt;string,<span class="hljs-type">int</span>&gt; node:indegrees)<br>        &#123;<br>                <span class="hljs-keyword">if</span>(!indegrees.second) q[++l2]=indegrees.first);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q)<br>        &#123;<br>                <span class="hljs-built_in">strcpy</span>(t,q[l2--]);<br>                ans[++l1]=t;<br>                <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=l;i++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcpy</span>(graph[i][<span class="hljs-number">0</span>],t))<br>                    &#123;<br>                        indegrees[grpah[i][<span class="hljs-number">1</span>]]-=<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">if</span>(!indegrees[graph[i][<span class="hljs-number">1</span>]])<br>                        &#123;<br>                            q.<span class="hljs-built_in">push</span>(graph[i][<span class="hljs-number">1</span>]);<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>()==num) <span class="hljs-comment">//输出的顶点是否与图中的顶点数相等</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//无环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//有环</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 因为是有向图两个顶点也可以成环 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Graph g, <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> j;<br>        color[i] = gray; <span class="hljs-comment">//灰色 表示正在访问</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, g.vex[i]);<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; g.vex_num; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; g.edge[i][j] != INFINITY) &#123;<span class="hljs-comment">//两顶点有边相连</span><br>                        <span class="hljs-keyword">if</span> (color[j] == white) &#123;<br>                                <span class="hljs-built_in">dfs</span>(g, j);<span class="hljs-comment">//如果该节点未访问 继续访问其临近节点</span><br>                        &#125;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[j] == gray)&#123;<br>                                loop_num++;<br>                                is_dag = <span class="hljs-literal">false</span>; <span class="hljs-comment">//有环</span><br>                        &#125;<br>                &#125;<br>        &#125;<br>        color[i] = black;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_trvsal</span><span class="hljs-params">(Graph g)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; g.vex_num; i++) &#123;<br>                color[i] = white;<br>                loop_num = <span class="hljs-number">0</span>;<br>        &#125;<br>        link_component = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; g.vex_num; i++) &#123;<br>                <span class="hljs-keyword">if</span> (color[i] == white) &#123;<br>                        link_component++;<br>                        <span class="hljs-built_in">dfs</span>(g, i);<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>​首先我们把每个点看成独立的集合{0} ，{1}， {2}, 然后规定如果两个点之间有边相连，如果这两个点不属于同一个集合，那就将他们所属的结合合并，看边0-1，直接将这两个点代表的集合合并{0， 1}, 其中让1来当父节点， 看边1-2， 它们分别属于不同的集合，合并集合之后是{1， 2}，让2来当父节点，依照这种逻辑关系，0的祖先节点就是2， 然后在看边0-2，他们属于一个集合，因为他们有着共同的祖先2， 这就说明0-2之间在没有0-2这条边之前已经连通了，如果在加上这条边的话那从0到2就有两条路径可达，就说明存在一个环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-type">int</span> n,m,f1,f2;<br>   <span class="hljs-type">int</span> pre[<span class="hljs-number">1000</span>];                              <br>       <span class="hljs-comment">//每个点互相独立，自成一个集合，从1编号到1000的上级都是自己</span><br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;++i)&#123;   <br>       pre[i]=i; <br>   &#125;               <br>   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d,%d&quot;</span>,&amp;m,&amp;n)==<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">//m和n相连              </span><br>       f1=<span class="hljs-built_in">find</span>(n);<br>       f2=<span class="hljs-built_in">find</span>(m);<br>       <span class="hljs-keyword">if</span>(f2==f1)<br>           <span class="hljs-comment">//两点已经连通了，那么这条路有一个环 </span><br>       <span class="hljs-keyword">else</span><br>           <span class="hljs-built_in">unio</span>(n,m);     <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> pre)</span>&lt;/span&gt;</span>&#123;<br>    visit[i]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=v;j++)<br>        <span class="hljs-keyword">if</span>(g[i][j])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visit[j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(j,i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j!=pre)  <span class="hljs-comment">//如果访问过，且不是其父节点，那么就构成环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*维护（快速修改）区间信息，快速获取信息（求和等）</p><p>*线段树完全替代树状数组功能且树状数组相较其不能修改维护，但线段树更复杂</p><h1 id="代码实现（Java）"><a href="#代码实现（Java）" class="headerlink" title="代码实现（Java）"></a>代码实现（Java）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> <br>&#123;<br>    <span class="hljs-comment">//下标都从1开始~</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> maxlenth=MAX;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> [] c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[maxlenth]; <span class="hljs-comment">//树状数组</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> [] pre=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [len_max]; <span class="hljs-comment">//前缀和数组</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <br>        &#123; <span class="hljs-comment">//计算能整除x的最小的2的幂</span><br>        <span class="hljs-keyword">return</span> x&amp;(-x);<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> value)</span> <span class="hljs-comment">//插入</span><br>        &#123; <span class="hljs-comment">//i为插入的下标</span><br>        <span class="hljs-keyword">while</span>(i&lt;=maxlenth) <br>           &#123;<br>            c[i]+=value;<br>            i+=lowbit(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//前i个的前缀和</span><br>        &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>) <br>            &#123;<br>            sum+=c[i];<br>            i-=lowbit(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <br>   &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++) <br>        &#123;<br>            <span class="hljs-type">int</span> t=scanner.nextInt();<br>            add(i, t);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++) pre[i]=sum(i);<br>    <span class="hljs-comment">//之后每次查询局部和只需根据前缀和数组作差即可~</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*维护（快速修改）区间信息，快速获取信息（求和等）</p><p>*线段树完全替代树状数组功能且树状数组相较其不能修改维护，但线段树更复杂</p><p>**是区间树（红黑树的一种变式，属于红黑树）的一种特殊情况~</p><h1 id="代码实现（Python）"><a href="#代码实现（Python）" class="headerlink" title="代码实现（Python）"></a>代码实现（Python）</h1><p>树状的线段（区间），每个线段是类定义的self，val是满足某个目标（下面是区间上的最大值）的区间上的函数，l、r是线段的左右端点。而它们又用一个大小为4n的数组（n为总线段的长度）保存，类似于堆，下标之间存在乘除2加减一这样的数值关系。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义树节点，l,r, val表示该节点记录的是区间[l, r]的最大值是val</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.l = <span class="hljs-number">0</span><br>        self.r = <span class="hljs-number">0</span><br>        self.lazy = <span class="hljs-number">0</span><br>        self.val = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二叉树是堆形式，可以用一维数组存储，注意数组长度要开4倍空间</span><br>tree = [Tree() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>*<span class="hljs-number">4</span>)]<br><span class="hljs-comment"># 建树，用cur&lt;&lt;1访问左子树，cur&lt;&lt;1|1访问右子树，位运算操作很方便</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">cur, l, r</span>):<br>    tree[cur].l, tree[cur].r, tree[cur].lazy, tree[cur].val = l, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 当l==r的时候结束递归</span><br>    <span class="hljs-keyword">if</span> l &lt; r:<br>        mid = l + r &gt;&gt; <span class="hljs-number">1</span><br>        build(cur&lt;&lt;<span class="hljs-number">1</span>, l, mid)<br>        build(cur&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, mid+<span class="hljs-number">1</span>, r)<br></code></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 当子节点计算完成后，用子节点的值来更新自己的值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pushup</span>(<span class="hljs-params">cur</span>):<br>    tree[cur].val = <span class="hljs-built_in">max</span>(tree[cur&lt;&lt;<span class="hljs-number">1</span>].val, tree[cur&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val)<br></code></pre></td></tr></table></figure><h3 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">cur, x, v</span>):<br>    <span class="hljs-keyword">if</span> tree[cur].l == tree[cur].r:<br>        tree[cur].val += v<br>    <span class="hljs-keyword">else</span>:<br>        mid = tree[cur].r + tree[cur].l &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> x &gt; mid:<br>            add(cur&gt;&gt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, x, v)<br>        <span class="hljs-keyword">else</span>:<br>            add(cur&lt;&lt;<span class="hljs-number">1</span>, x, v)<br>        pushup(cur)<br></code></pre></td></tr></table></figure><h3 id="区间更新"><a href="#区间更新" class="headerlink" title="区间更新"></a>区间更新</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将lazy标记向下传递一层</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pushdown</span>(<span class="hljs-params">cur</span>):<br>    <span class="hljs-keyword">if</span> tree[cur].lazy:<br>        lazy = tree[cur].lazy<br>        tree[cur&lt;&lt;<span class="hljs-number">1</span>].lazy += lazy<br>        tree[cur&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].lazy += lazy<br>        tree[cur&lt;&lt;<span class="hljs-number">1</span>].val += lazy<br>        tree[cur&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].val += lazy<br>        tree[cur].lazy = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 区间更新</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">cur, l, r, v</span>):<br>    <span class="hljs-keyword">if</span> l &lt;= tree[cur].l <span class="hljs-keyword">and</span> tree[cur].r &lt;= r:<br>        tree[cur].lazy += v<br>        tree[cur].val += v<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> r &lt; tree[cur].l <span class="hljs-keyword">or</span> l &gt; tree[cur].r:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> tree[cur].lazy:<br>        pushdown(cur)<span class="hljs-comment">#为什么要先pushdown再pushup？</span><br>    update(cur&lt;&lt;<span class="hljs-number">1</span>, l, r, v)<br>    update(cur&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>, l, r, v)<br>    pushup(cur)<br></code></pre></td></tr></table></figure><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">cur, l, r</span>):<br>    <span class="hljs-keyword">if</span> l &lt;= tree[cur].l <span class="hljs-keyword">and</span> tree[cur].r &lt;= r:<br>        <span class="hljs-keyword">return</span> tree[cur].val<br>    <span class="hljs-keyword">if</span> tree[cur].l &gt; r <span class="hljs-keyword">or</span> tree[cur].r &lt; l:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> tree[cur].lazy:<br>        pushdown(cur)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(query(cur&lt;&lt;<span class="hljs-number">1</span>, l, r), query(cur&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用方向：已给一个由许多字符串构成的字典，之后再给某个字符串，判断其是否在字典内</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">Trie=&#123;&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">word</span>):<span class="hljs-comment">#不用另建一个Trie类，直接放在其他函数里面即可</span><br>    t=Trie<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> word:<br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t:t[i]=&#123;&#125;<br>        t=t[i]<br>    t[<span class="hljs-string">&#x27;#&#x27;</span>]=<span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">word</span>):<br>    t=Trie<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> word:<br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t:<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        t=t[i]<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;#&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> t:<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="Java-amp-C"><a href="#Java-amp-C" class="headerlink" title="Java &amp; C++"></a>Java &amp; C++</h1><p>以C++为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> nex[<span class="hljs-number">100005</span>][<span class="hljs-number">26</span>],cnt=<span class="hljs-number">0</span>; <span class="hljs-comment">//nex即为Trie树</span><br><span class="hljs-type">bool</span> exist[<span class="hljs-number">100005</span>]=&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//该结点结尾的字符串是否存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> l)</span> </span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">//插入字符串</span><br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) <br>   &#123;<br>      <span class="hljs-type">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (!nex[p][c]) nex[p][c] = ++cnt;  <span class="hljs-comment">//如果没有，就添加结点</span><br>      p = nex[p][c];<br>    &#125;<br>    exist[p] = <span class="hljs-number">1</span>;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> l)</span> </span>&#123;  <span class="hljs-comment">//查找字符串</span><br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; i++) &#123;<br>              <span class="hljs-type">int</span> c = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>              <span class="hljs-keyword">if</span> (!nex[p][c]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>              p = nex[p][c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> exist[p];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉堆</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用方向：求最值，支持插入、删除（仅限于顶部最值）</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="库函数（推荐）"><a href="#库函数（推荐）" class="headerlink" title="库函数（推荐）"></a>库函数（推荐）</h2><p>默认为最大堆：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq <span class="hljs-comment">#导入标准库中的heap库，heap指的是最小堆</span><br></code></pre></td></tr></table></figure><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.heapify(<span class="hljs-built_in">list</span>) <span class="hljs-comment">#使数组转化为堆（若初始化heapq可以直接写heap=[]</span><br></code></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.heappush(heap,item)<br></code></pre></td></tr></table></figure><h3 id="删除（堆顶元素）"><a href="#删除（堆顶元素）" class="headerlink" title="删除（堆顶元素）"></a>删除（堆顶元素）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.heappop(heap) <br>heapq.heapreplace(heap, item) <span class="hljs-comment">#删除最小值并添加新值</span><br></code></pre></td></tr></table></figure><h3 id="查堆中最大的n个数"><a href="#查堆中最大的n个数" class="headerlink" title="查堆中最大的n个数"></a>查堆中最大的n个数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">heapq.nlargest (n, heap)<br></code></pre></td></tr></table></figure><h2 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h2><h3 id="构建-1"><a href="#构建-1" class="headerlink" title="构建"></a>构建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHeap</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, maxsize=<span class="hljs-literal">None</span></span>):<br>        self.maxsize = maxsize<br>        self._elements = Array(maxsize)<br>        self._count = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> self._count &gt;= self.maxsize:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;The heap is full!&quot;</span>)<br>        self._elements[self._count] = value<br>        self._count += <span class="hljs-number">1</span><br>        self._siftup(self._count-<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_siftup</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-keyword">if</span> index &gt; <span class="hljs-number">0</span>:<br>            parent = <span class="hljs-built_in">int</span>((index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">if</span> self._elements[parent] &gt; self._elements[index]:<br>                self._elements[parent], self._elements[index] = self._elements[index], self._elements[parent]<br>                self._siftup(parent)                <br></code></pre></td></tr></table></figure><h3 id="删除（堆顶元素）-1"><a href="#删除（堆顶元素）-1" class="headerlink" title="删除（堆顶元素）"></a>删除（堆顶元素）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract</span>(<span class="hljs-params">self</span>):<span class="hljs-comment">#删除堆顶元素并返回此元素值</span><br>    <span class="hljs-keyword">if</span> self._count &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;The heap is empty!&#x27;</span>)<br>    value = self._elements[<span class="hljs-number">0</span>]<br>    self._count -= <span class="hljs-number">1</span><br>    self._elements[<span class="hljs-number">0</span>] = self._elements[self._count]<br>    self._siftdown(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> value<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_siftdown</span>(<span class="hljs-params">self, index</span>):<br>    <span class="hljs-keyword">if</span> index &lt; self._count: <br>        left = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span><br>        right = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> left &lt; self._count <span class="hljs-keyword">and</span> right &lt; self._count \<br>            <span class="hljs-keyword">and</span> self._elements[left] &lt;= self._elements[right] \<br>            <span class="hljs-keyword">and</span> self._elements[left] &lt;= self._elements[index]:<br>            self._elements[left], self._elements[index] = self._elements[index], self._elements[left]<br>            self._siftdown(left)<br>        <span class="hljs-keyword">elif</span> left &lt; self._count <span class="hljs-keyword">and</span> right &lt; self._count \<br>            <span class="hljs-keyword">and</span> self._elements[left] &gt;= self._elements[right] \<br>            <span class="hljs-keyword">and</span> self._elements[right] &lt;= self._elements[index]:<br>            self._elements[right], self._elements[index] = self._elements[index], self._elements[right]<br>            self._siftdown(left)<br>        <span class="hljs-keyword">if</span> left &lt; self._count <span class="hljs-keyword">and</span> right &gt; self._count \<br>            <span class="hljs-keyword">and</span> self._elements[left] &lt;= self._elements[index]:<br>            self._elements[left], self._elements[index] = self._elements[index], self._elements[left]<br>               self._siftdown(left)<br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>手搓太麻烦，只写了库函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span> <span class="hljs-comment">//用来支持大顶堆</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> heap[Max];<br><span class="hljs-built_in">make_heap</span>(heap+<span class="hljs-number">1</span>,heap+cur_len+<span class="hljs-number">1</span>,[less/<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()]);<span class="hljs-comment">//less为大顶堆</span><br><span class="hljs-comment">//不管是一开始就建好堆还是逐一插入（然后每次问最值）都用make_heap</span><br><span class="hljs-comment">//当前最小/大值即为heap[0]</span><br><span class="hljs-comment">//若要每次删除顶部最值，只需弹出后把顶部和尾部值交换后再make_heap即可</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡二叉树AVL</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><p>可以用有序列表，但为第三方库，机试用不了！</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pip install sortedcontainers<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sortedcontainers <span class="hljs-keyword">import</span> SortedList<br>lst=SortedList()<br>val=lst.index(index) <span class="hljs-comment">#查找</span><br>lst.count(val)<br>lst.add(val)<br>lst.update(<span class="hljs-built_in">iter</span>) <span class="hljs-comment">#把一新容器的数都插入进去</span><br>lst.bisect_left/right(val)<br><span class="hljs-comment">#插入，若存在相同元素则插入其左/右侧并返回索引值</span><br>val=lst.pop(index) <span class="hljs-comment">#index不写的话默认为-1</span><br>lst.discard/remove(val) <span class="hljs-comment">#discard不报错，remove抛异常</span><br>lst.clear()<br></code></pre></td></tr></table></figure><h2 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h2><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLTree</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.root = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">left_height</span>(<span class="hljs-params">self, node</span>):  <span class="hljs-comment"># 开始传入根结点，后面传入每颗子树的根结点</span><br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> self.tree_height(node.left)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">right_height</span>(<span class="hljs-params">self, node</span>):  <span class="hljs-comment"># 开始传入根结点，后面传入每颗子树的根结点</span><br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> self.tree_height(node.right)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_height</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.tree_height(node.left), self.tree_height(node.right)) +<span class="hljs-number">1</span> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">left_rotate</span>(<span class="hljs-params">self, node</span>):<br>           … <span class="hljs-comment">#略，见上</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, val</span>):<span class="hljs-comment">#插入节点，此处的插入函数不包括后续的调整（最好能包括）</span><br>           … <span class="hljs-comment">#略，见之前笔记（实在不行见CSDN收藏）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">jude_node</span>(<span class="hljs-params">self, node</span>):  <span class="hljs-comment"># 对AVL树进行必要的调整</span><br>        <span class="hljs-keyword">if</span> self.right_height(node) - self.left_height(node) &gt; <span class="hljs-number">1</span>:        <br>            <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">and</span> self.left_height(node.right) &gt;<br>               self.right_height(node.right):                                                         <br>                self.right_rotate(node.right)<br>                self.left_rotate(self.root)<br>            <span class="hljs-keyword">else</span>:<br>                self.left_rotate(self.root)    <br>        <span class="hljs-keyword">if</span> self.left_height(node) - self.right_height(node) &gt; <span class="hljs-number">1</span>: <br>            <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">and</span> self.right_height(node.left) &gt; <br>                self.left_height(node.left):<br>                self.left_rotate(node.left)<br>                self.right_rotate(self.root)<br>            <span class="hljs-keyword">else</span>:<br>                self.right_rotate(self.root)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, val</span>):<br>        node = TreeNode(val)<br>        <span class="hljs-keyword">if</span> self.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.root = node<br>            <span class="hljs-keyword">return</span><br>        queue = [self.root]<br>        <span class="hljs-keyword">while</span> queue:<br>            temp_node = queue.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># 判断传入结点的值和当前子树结点的值关系</span><br>            <span class="hljs-keyword">if</span> node.val &lt; temp_node.val:<br>                <span class="hljs-keyword">if</span> temp_node.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    temp_node.left = node<br>                    <span class="hljs-keyword">return</span><br>                <span class="hljs-keyword">else</span>:<br>                    queue.append(temp_node.left)<br>            <span class="hljs-keyword">if</span> node.val &gt;= temp_node.val:<br>                <span class="hljs-keyword">if</span> temp_node.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    temp_node.right = node<br>                    <span class="hljs-keyword">return</span><br>                <span class="hljs-keyword">else</span>:<br>                    queue.append(temp_node.right)<br><span class="hljs-comment">#接下来构造AVL树时就是每次插入新节点时调用一次add函数，再调用一次jude_node函数判断根节点是否需要调整（即node是root），代码略~（不应该每个节点都要调整一遍？）</span><br></code></pre></td></tr></table></figure><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><ul><li>类型&amp;方法</li></ul><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/1689000207304.jpg" alt="1689000207304"></p><p>LL&#x2F;RR:一次右&#x2F;左旋转</p><p>LR&#x2F;RL:左旋转→右旋转&#x2F;右旋转→左旋转</p><blockquote><p>注：此处讲的仅是总体上不平衡的情况，细节上仍需加入一些可能的操作！</p></blockquote><ul><li>示例</li></ul><ol><li>LL</li></ol><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/1689000316521.jpg" alt="1689000316521"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">right_rotate</span>(<span class="hljs-params">node</span>):<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-comment"># 创建新的结点，以当前根结点的值</span><br>    new_node = copy.deepcopy(node)<br>    <span class="hljs-comment"># 把新结点的右子树设为当前结点的右子树</span><br>    new_node.right = node.right<br>    <span class="hljs-comment"># 把新结点的左子树设为当前结点的左子树的右子树</span><br>    new_node.left = node.left.right<br>    <span class="hljs-comment"># 把当前结点的值替换成它的左子结点的值</span><br>    node.val = node.left.val<br>    <span class="hljs-comment"># 把当前结点的左子树设置成当前结点的左子树的左子树</span><br>    node.left = node.left.left<br>    <span class="hljs-comment"># 把当前结点的右子结点设置成（指向）新的结点</span><br>    node.right = new_node<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure><ol start="2"><li><p>RR</p><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/1689000367743.jpg" alt="1689000367743"></p></li><li><p>RL</p><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/1689000480226.jpg" alt="1689000480226"></p></li><li><p>LR</p></li></ol><p>可以看成先左旋转化归成LL的情况，然后再右旋转一次！</p><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL/1689000519451.jpg" alt="1689000519451"></p><p>代码实现：就是一次LL的代码加上一次RR的代码，略~</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>手搓太麻烦，只给库函数了（能用为何不用doge）~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeMap;<br>avl.empty();<br>avl.size();<br>avl.get(); <span class="hljs-comment">//若找不到返回null</span><br>avl.put(key[,value]); <span class="hljs-comment">//插入</span><br>avl.remove(key[,value]);<br>avl.clear();<br>avl.entrySet()/keySet()/values(); <span class="hljs-comment">//键值对/键/值的遍历</span><br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>同上，只给库函数~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span> </span><br>multiset &lt;string&gt; avl;<br>avl.<span class="hljs-built_in">size</span>();<br>avl.<span class="hljs-built_in">empty</span>();<br>avl.<span class="hljs-built_in">find</span>(val); <span class="hljs-comment">//不存在则返回avl.end()</span><br>upper/<span class="hljs-built_in">lower_bound</span>(val); <span class="hljs-comment">//返回首个值&gt;val的元素的迭代器/最后一个值&lt;val的迭代器</span><br>avl.<span class="hljs-built_in">insert</span>(val);<br>avl.<span class="hljs-built_in">erase</span>(iter)/(begin,end)/val;<br><span class="hljs-comment">//删除iter/区间上迭代器所指的/值为val的元素，返回下一个元素的迭代器</span><br>avl.<span class="hljs-built_in">clear</span>();<br>avl.<span class="hljs-built_in">sort</span>(iter_left,iter_right,comp_func); <span class="hljs-comment">//少用</span><br><span class="hljs-keyword">for</span>(i=avl.<span class="hljs-built_in">begin</span>();i!=avl.<span class="hljs-built_in">end</span>();i++)&#123;…&#125; <span class="hljs-comment">//遍历（少用）</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索（排序）树BST</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89%E6%A0%91BST/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89%E6%A0%91BST/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>无库函数。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, data</span>):<br>    node=self.root <span class="hljs-comment">#self是个实例对象，此处先将node初始化，使其指向根节点</span><br>    <span class="hljs-keyword">while</span> node:<br>    <span class="hljs-keyword">if</span> node.val==data:<br>    <span class="hljs-keyword">return</span> node<br>    <span class="hljs-keyword">elif</span> node.val&gt;data:<br>    node=node.left<br>    <span class="hljs-keyword">else</span>:<br>    node=node.right<br>    <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>就比查找多一步，略~</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>*总体思路：</p><p>​从根节点开始，依次比较要插入的数据与节点的大小关系。如果插入的数据比节点的大，并且节点的右子树为空，就将数据直接插到右子节点的位置；如果右子树不为空，就在递归遍历右子树，查找插入位置。如果要插入的数据比节点的小，并且节点的左子树为空，就将数据直接插到左子树的位置；如果左子树不为空，就再递归遍历左子树，查找插入位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, data</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.root:<br>        self.root = TreeNode(data) <span class="hljs-comment">#对象类型TreeNode需说明白</span><br>    <span class="hljs-keyword">else</span>:<br>        node = self.root<br>        <span class="hljs-keyword">while</span> node:<br>            p = node<br>            <span class="hljs-keyword">if</span> data &lt; node.val:<br>                node = node.left<br>            <span class="hljs-keyword">else</span>:<br>                node = node.right<br>                TreeNode(data).parent = p <span class="hljs-comment">#这步看情况要不要</span><br>                <span class="hljs-keyword">if</span> data &lt; p.val:<br>                    p.left = nTreeNode(data)<br>                <span class="hljs-keyword">else</span>:<br>                    p.right = TreeNode(data)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>*总体思路：分三种情况进行讨论：</p><ul><li><p>要删除的节点没有子节点：直接将父结点中指向要删除节点的指针置为null。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_del</span>(<span class="hljs-params">self, node</span>):    <br>    <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> node == self.root:<br>            self.root = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> node.val &lt; node.parent.val:<br>                node.parent.left = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                node.parent.right = <span class="hljs-literal">None</span><br>                node.parent = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></li><li><p>要删除的节点只有一个子节点（只有左子节点或者右子节点）：更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">elif</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> node == self.root:<br>        self.root = node.right<br>        self.root.parent = <span class="hljs-literal">None</span><br>        node.right = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> node.val &lt; node.parent.val:<br>            node.parent.left = node.right<br>        <span class="hljs-keyword">else</span>:<br>            node.parent.right = node.right<br>        node.right.parent = node.parent<br>        node.parent = <span class="hljs-literal">None</span><br>        node.right = <span class="hljs-literal">None</span><br><span class="hljs-keyword">elif</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> node == self.root:<br>        self.root = node.left<br>        self.root.parent = <span class="hljs-literal">None</span><br>        node.left = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> node.val &lt; node.parent.val:<br>            node.parent.left = node.left<br>        <span class="hljs-keyword">else</span>:<br>            node.parent.right = node.left<br>        node.left.parent = node.parent<br>        node.parent = <span class="hljs-literal">None</span><br>        node.left = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure></li><li><p>要删除的节点有两个子节点：首先找到要删除节点的右子树中的最小节点，把它的值替换到要删除的节点上。然后再删除掉这个最小节点即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">else</span>:<br>    min_node = node.right<br>    <span class="hljs-keyword">while</span> min_node.left:<br>        min_node = min_node.left<br>    <span class="hljs-keyword">if</span> node.val != min_node.val:<br>        node.val = min_node.val<br>        self._<span class="hljs-keyword">del</span>(min_node)<br>    <span class="hljs-keyword">else</span>:<br>        self._<span class="hljs-keyword">del</span>(min_node)<br>        self._<span class="hljs-keyword">del</span>(node)<br></code></pre></td></tr></table></figure></li></ul><h1 id="Java-amp-C-（以C-为例）"><a href="#Java-amp-C-（以C-为例）" class="headerlink" title="Java &amp; C++（以C++为例）"></a>Java &amp; C++（以C++为例）</h1><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>此处不使用一次次插入的方法！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-type">int</span> *n,<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!len) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    TreeNode *root;<br>    root=(TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(TreeNode));<br>    root-&gt;val=n[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> small[<span class="hljs-number">10001</span>],big[<span class="hljs-number">10001</span>],len_s=<span class="hljs-number">0</span>,len_b=<span class="hljs-number">0</span>,i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=len;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n[i]&lt;n[<span class="hljs-number">1</span>]) small[++len_s]=n[i];<br>        <span class="hljs-keyword">else</span> big[++len_b]=n[i];<br>    &#125;<br>    root-&gt;left=<span class="hljs-built_in">Create</span>(small,len_s);<br>    root-&gt;right=<span class="hljs-built_in">Create</span>(big,len_b);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Insert</span><span class="hljs-params">(BSTree *bst, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == *bst)  <span class="hljs-comment">//空树</span><br>        &#123;<br>                *bst = <span class="hljs-built_in">BuyNode</span>(key);   <span class="hljs-comment">//插入根节点</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        BSTNode *p;<br>        <span class="hljs-comment">//先在二叉排序树中查找要插入的值是否已经存在</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Search</span>(*bst, key, <span class="hljs-literal">NULL</span>, &amp;p))  <br>            <span class="hljs-comment">//如果查找失败，则插入；此时p指向遍历的最后一个节点</span><br>        &#123;<br>                BSTNode *pNew = <span class="hljs-built_in">BuyNode</span>(key);<br>                <span class="hljs-keyword">if</span> (key &lt; p-&gt;data)  <span class="hljs-comment">//将s作为p的左孩子</span><br>                &#123;<br>                        p-&gt;lchild = pNew;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; p-&gt;data)  <span class="hljs-comment">//将s作为p的右孩子</span><br>                &#123;<br>                        p-&gt;rchild = pNew;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//插入成功</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nThe node(%d) already exists.\n&quot;</span>, key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Search</span><span class="hljs-params">(BSTree bst, <span class="hljs-type">int</span> key, BSTree f, BSTree *p)</span>  </span><br><span class="hljs-function">    <span class="hljs-comment">//查找成功时，p指向值为key的节点。如果查找失败，则p指向遍历的最后一个节点</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (!bst)<br>        &#123;<br>                *p = f;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bst-&gt;data == key)  <span class="hljs-comment">//查找成功，直接返回</span><br>        &#123;<br>                *p = bst;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bst-&gt;data &lt; key)<br>        &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Search</span>(bst-&gt;rchild, key, bst, p);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Search</span>(bst-&gt;lchild, key, bst, p);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>三种情况同上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BSTNode* <span class="hljs-title">FindParent</span><span class="hljs-params">(BSTree bst, BSTNode *child)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == bst)<br>        &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (bst-&gt;lchild == child || bst-&gt;rchild == child)<br>        &#123;<br>                <span class="hljs-keyword">return</span> bst;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != bst-&gt;lchild)<br>        &#123;<br>                <span class="hljs-built_in">FindParent</span>(bst-&gt;lchild, child);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != bst-&gt;rchild)<br>        &#123;<br>                <span class="hljs-built_in">FindParent</span>(bst-&gt;rchild, child);<br>        &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(BSTree *bst, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == *bst)<br>        &#123;<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//空树直接报错</span><br>        &#125;<br>        BSTNode *p;<br>        BSTNode *f = <span class="hljs-literal">NULL</span>;<br>        BSTNode *q, *s;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Search</span>(*bst, key, <span class="hljs-literal">NULL</span>, &amp;p)) <span class="hljs-comment">//确实存在值为key的节点,则p指向该节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == p-&gt;lchild &amp;&amp; <span class="hljs-literal">NULL</span> != p-&gt;rchild)  <span class="hljs-comment">//无左孩子,有右孩子</span><br>            &#123;<br>                q = p-&gt;rchild;<br>                p-&gt;data = q-&gt;data;    <br>                <span class="hljs-comment">//因为两个节点之间本质的不同在于数据域的不同，而与放在哪个地址没有关系</span><br>                p-&gt;rchild = q-&gt;rchild;<br>                p-&gt;lchild = q-&gt;lchild;<br>                <span class="hljs-built_in">free</span>(q);<br>            &#125;<br>            <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == p-&gt;rchild &amp;&amp; <span class="hljs-literal">NULL</span> != p-&gt;lchild)  <span class="hljs-comment">//无右孩子,有左孩子</span><br>            &#123;<br>                q = p-&gt;lchild;<br>                p-&gt;data = q-&gt;data;<br>                p-&gt;rchild = q-&gt;rchild;<br>                p-&gt;lchild = q-&gt;lchild;<br>                <span class="hljs-built_in">free</span>(q);<br>            &#125;<br>            <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != p-&gt;rchild &amp;&amp; <span class="hljs-literal">NULL</span> != p-&gt;lchild) <span class="hljs-comment">//既有左孩子，又有右孩子</span><br>            &#123;<br>                q = p;<br>                s = p-&gt;lchild;   <span class="hljs-comment">//找左孩子的最右孩子</span><br>                <span class="hljs-keyword">while</span> (s-&gt;rchild)<br>                &#123;<br>                    q = s;<br>                    s = s-&gt;rchild;<br>                &#125;<br>                p-&gt;data = s-&gt;data;<br><br>                <span class="hljs-keyword">if</span> (q != p)<br>                &#123;<br>                    q-&gt;rchild = p-&gt;lchild;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    q-&gt;lchild = s-&gt;lchild;<br>                &#125;<br>                <span class="hljs-built_in">free</span>(s);<br>            &#125;<br>            <br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">if</span> (*bst == p)   <span class="hljs-comment">//只有一个根节点</span><br>                &#123;<br>                    <span class="hljs-built_in">free</span>(*bst);<br>                    *bst = <span class="hljs-literal">NULL</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                BSTNode* parent = <span class="hljs-built_in">FindParent</span>(*bst, p);<br>                <span class="hljs-keyword">if</span> (parent-&gt;lchild == p)<br>                &#123;<br>                    parent-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    parent-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-built_in">free</span>(p);<br>            &#125;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter Notebook</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/Jupyter%20Notebook/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/Jupyter%20Notebook/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>Cell（Input、Output）和Kernel单元</p></li><li><p>Web应用，在本地8888端口（多个Notebook则端口号依次递增）</p></li><li></li></ul>  <figure class="highlight plaintext"><figcaption><span>notebook</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jupyter">!… #系统命令 <br>% #单行魔法命令（Python之外的语言）<br>%% #多行魔法命令<br></code></pre></td></tr></table></figure><ul><li><p>快捷键：</p></li><li><ul><li>在 cell 之间上下浏览采用上下箭头，或者 Up 和 Down 键</li><li>A 表示在当前 cell 上方插入一个新的 cell ，而 B 则是下方插入新的cell</li><li>M 表示变为 Markdown cell ，而 Y 是表示变为 code cell</li><li>连续按两次 D 是删除当前 cell</li><li>Z 是撤销操作</li><li>Shift 加上 Up 或者 Down 可以一次选择多个 cells ，接着采用 Shift + M 可以合并多个 cells</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Jupyter Notebook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本问题</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binarytree<br></code></pre></td></tr></table></figure><h2 id="求树高"><a href="#求树高" class="headerlink" title="求树高"></a>求树高</h2><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">root.height <br></code></pre></td></tr></table></figure><h3 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:  <span class="hljs-comment">#递归边界</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        l = <span class="hljs-number">1</span> + self.maxDepth(root.left)  <span class="hljs-comment">#递归</span><br>        r = <span class="hljs-number">1</span> + self.maxDepth(root.right)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l, r)<br></code></pre></td></tr></table></figure><h1 id="C-amp-Java（以C-为例）"><a href="#C-amp-Java（以C-为例）" class="headerlink" title="C++&amp;Java（以C++为例）"></a>C++&amp;Java（以C++为例）</h1><h2 id="找父节点"><a href="#找父节点" class="headerlink" title="找父节点"></a>找父节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">getParent</span><span class="hljs-params">(TreeNode root,TreeNode p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == null ||root.left == p || root.right == p) <span class="hljs-keyword">return</span> root; <br>    <span class="hljs-comment">//树为空，或者p是root的子节点，返回root  </span><br>    TreeNode left = <span class="hljs-built_in">getParent</span>(root.left,p); <span class="hljs-comment">//root的左孩子 是否为p的父节点</span><br>    <span class="hljs-keyword">if</span>(left != null) <span class="hljs-keyword">return</span> left;  <span class="hljs-comment">//是的话，return left，无需找右子树</span><br>    TreeNode right = <span class="hljs-built_in">getParent</span>(root.right,p); <span class="hljs-comment">//root的右孩子 是否为p的父节点</span><br>    <span class="hljs-keyword">if</span>(right != null) <span class="hljs-keyword">return</span> right;  <span class="hljs-comment">//是的话，return right</span><br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//左右子树都不包含p，返回 null; (return right 同样是null)</span><br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本操作</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>为第三方库，机试用不了！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> binarytree <span class="hljs-keyword">import</span> Node<br>root=Node(value) <span class="hljs-comment">#Node已经全部初始化好了!</span><br>root.left=…<br></code></pre></td></tr></table></figure><h3 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>: <span class="hljs-comment">#构建时用TreeNode(val)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">self,val,left,right,parent</span>):<br> <span class="hljs-comment">#下面初始化的参数也可以不写在这里面（甚至可以只有self）</span><br>       self.val = val<br>       self.left = <span class="hljs-literal">None</span><br>       self.right = <span class="hljs-literal">None</span><br>       self.parent = <span class="hljs-literal">None</span> <span class="hljs-comment">#这个较不常见</span><br></code></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>输入用’#’表示叶子结点的层次遍历序列，构建二叉树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">global</span> lst=<span class="hljs-built_in">input</span>(),index=<span class="hljs-number">0</span><br>length=<span class="hljs-built_in">len</span>(lst)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Build</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> indexlength-<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> lst[index]<span class="hljs-string">&#x27;#&#x27;</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-comment">#理论上可以不用比较index和length-1</span><br>        root=TreeNode(lst[index])<br>        index+=<span class="hljs-number">1</span><br>        root.left=self.Build()<br>        root.right=self.Build()<br>        <span class="hljs-keyword">return</span> root<br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="前-x2F-中-x2F-后序遍历"><a href="#前-x2F-中-x2F-后序遍历" class="headerlink" title="前&#x2F;中&#x2F;后序遍历"></a>前&#x2F;中&#x2F;后序遍历</h3><ul><li><p>库函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> binarytree <span class="hljs-keyword">import</span> Node<br>root.preorder/inorder/postorder <span class="hljs-comment">#前中后序遍历</span><br></code></pre></td></tr></table></figure></li><li><p>手搓</p><p>以中序为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inorder</span>(<span class="hljs-params">self,root</span>):<br>    <span class="hljs-keyword">if</span> root:<br>        self.inorder(root.left)<br>        self.traverse_path.append(root.val)<br>        self.inorder(root.right)<br></code></pre></td></tr></table></figure></li></ul><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>*类似于BFS</p><ol><li>结果放在一个一维列表中：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span><br>    result = []<br>    stack = [root]<br>    <span class="hljs-keyword">while</span> stack:<br>        lay=[]<br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> stack:<br>        result.append(node.val)<br>        <span class="hljs-keyword">if</span> node.left: lay.append(node.left)<br>        <span class="hljs-keyword">if</span> node.right: lay.append(node.right)<br>        stack = lay<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><ol start="2"><li>结果逐层放在二维列表中：</li></ol><ul><li><p>库函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binarytree<br><span class="hljs-built_in">list</span>=root.levelorder <span class="hljs-comment">#二维列表</span><br></code></pre></td></tr></table></figure></li><li><p>手搓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]:<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root: <span class="hljs-keyword">return</span><br>result = []<br>stack = [root]<br><span class="hljs-keyword">while</span> stack:<br>lay=[]<br>lay_value=[]<br><span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> stack: lay_value.append(node.val)<br><span class="hljs-keyword">if</span> node.left: lay.append(node.left)<br><span class="hljs-keyword">if</span> node.right: lay.append(node.right)<br>stack = lay<br>result.append(lay_value)<br><span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li></ul><h1 id="Java、C-（以C-为例）"><a href="#Java、C-（以C-为例）" class="headerlink" title="Java、C++（以C++为例）"></a>Java、C++（以C++为例）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span><br>&#123;<br>        <span class="hljs-type">int</span> val;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> *left;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> *right;<br>&#125;;<br><span class="hljs-keyword">typedef</span>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> TreeNode; <br></code></pre></td></tr></table></figure><h2 id="构建-1"><a href="#构建-1" class="headerlink" title="构建"></a>构建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">()</span> <span class="hljs-comment">//中序遍历输入</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    cin&gt;&gt;val;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        TreeNode *root;<br>        root = (TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(TreeNode));<br>        root-&gt;val = value;<br>        root-&gt;left = <span class="hljs-built_in">create</span>();<br>        root-&gt;right = <span class="hljs-built_in">create</span>();<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h2><h3 id="前-x2F-中-x2F-后序遍历-1"><a href="#前-x2F-中-x2F-后序遍历-1" class="headerlink" title="前&#x2F;中&#x2F;后序遍历"></a>前&#x2F;中&#x2F;后序遍历</h3><p>以中序遍历为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> book[maxsize];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">midorder</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">midorder</span>(root-&gt;left);<br>        book[l]=root-&gt;val;<br>        l++;<br>        <span class="hljs-built_in">midorder</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>*输入形参为二叉树结点，输出result数组名（相当于指针）</p><p>*用l记录lay的长度，用l&#x3D;0将其清空</p><p>*用memcpy(stack,lay,l)将lay复制给stack（库函数？）</p><p>*result可以用队列，也可以用length记录其长度然后一个个加~</p><ol><li><p>结果放在一个一维列表中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Levelorder</span><span class="hljs-params">(TreeNode *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    TreeNode que[<span class="hljs-number">100</span>],t;<br>    <span class="hljs-type">int</span> front=<span class="hljs-number">0</span>,rear=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    que[++rear]=root;<br>    <span class="hljs-keyword">while</span>(front!=rear)<br>    &#123;<br>        t=que[++front];<br>        cout&lt;&lt;t-&gt;data;<br>        <span class="hljs-keyword">if</span>(t-&gt;left) que[++rear]=t-&gt;left;<br>        <span class="hljs-keyword">if</span>(t-&gt;right) que[++rear]=t-&gt;right;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结果逐层放在二维列表中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-function">def <span class="hljs-title">levelOrder</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[List[<span class="hljs-type">int</span>]]:</span><br><span class="hljs-function">        if not root:</span><br><span class="hljs-function">            return</span><br><span class="hljs-function">        result =</span> []<br>        stack = [root]<br>        <span class="hljs-keyword">while</span> stack:<br>            lay=[]<br>            lay_value=[]<br>            <span class="hljs-keyword">for</span> node in stack:<br>                lay_value.<span class="hljs-built_in">append</span>(node.val)<br>                <span class="hljs-keyword">if</span> node.left:<br>                    lay.<span class="hljs-built_in">append</span>(node.left)<br>                <span class="hljs-keyword">if</span> node.right:<br>                    lay.<span class="hljs-built_in">append</span>(node.right)<br>            stack = lay<br>            result.<span class="hljs-built_in">append</span>(lay_value)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure></li></ol><h1 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h1><p>相对于前面用的类属性和结构体方法</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tree[Max];<br></code></pre></td></tr></table></figure><h2 id="构建-2"><a href="#构建-2" class="headerlink" title="构建"></a>构建</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BuildTree</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-type">int</span> temp;<br>        cin &gt;&gt; temp;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>                tree[root] = temp;<br>                <span class="hljs-built_in">BuildTree</span>(root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">BuildTree</span>(root * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h2><h3 id="前-x2F-中-x2F-后序遍历-2"><a href="#前-x2F-中-x2F-后序遍历-2" class="headerlink" title="前&#x2F;中&#x2F;后序遍历"></a>前&#x2F;中&#x2F;后序遍历</h3><p>以中序遍历为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MiddleOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span> (tree[root] &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">MiddleOrder</span>(root * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        cout &lt;&lt; tree[root] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">MiddleOrder</span>(root * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="层序遍历-2"><a href="#层序遍历-2" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>*输入形参为二叉树结点，输出result数组名（相当于指针）</p><p>*用l记录lay的长度，用l&#x3D;0将其清空</p><p>*用memcpy(stack,lay,l)将lay复制给stack（库函数？）</p><p>*result可以用队列，也可以用length记录其长度然后一个个加~</p><ol><li><p>结果放在一个一维列表中：</p><p>只需将原数组中不为-1的值全部剔除即可~</p></li><li><p>结果逐层放在二维列表中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">level=<span class="hljs-number">1</span>;<span class="hljs-comment">//头结点为第一层，level_order[i]用来记录第level层的遍历结果，每层结果从下标0开始</span><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,level<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>&lt;=max)<br>&#123;<br>    <span class="hljs-type">int</span> temp_len=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,level<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>;i&lt;=<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,level)<span class="hljs-number">-2</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(tree[i]!=<span class="hljs-number">-1</span>) level_order[level][temp_len++]=tree[i];<br>    &#125;<br>    level++;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>散列表</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>*数组下标太大，内存不够，需适当“压缩”</p><p>*时空的权衡</p><p>*用键值对的方式进行高效“匹配式”查询（即if …&#x3D;&#x3D;…），如多个元素出现次数的计数（字典）</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>*构造散列函数的方法：除法取余、乘法取小数部分（集中在0-1）后乘以某常数取整（再略做分散）</p><p>*多个元素被操作至同一个单元中时：构造链表将其组合&#x2F;构造二维数组(下标可以分别是取模的商和余数）</p><p>*关键在于构造键值对！</p><p>注：</p><ul><li><p>有元素加到哈希表某一处时（若此处还未开出数组）再开出数组！</p></li><li><p>字典就是一个哈希表！（无需额外处理，直接常规操作就行了）</p></li><li><p>想要手动“&#x3D;&#x3D;”判断或计数时勿忘字典的存在以及Counter函数！（写得快而且时间复杂度更低!）</p></li></ul><h1 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h1><p>*这个不能手搓~</p><p>*获取某个值都是通过val&#x3D;Map_name[key]!</p><p>*排序无意义，没写~</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">b=ds.empty() <br>length=<span class="hljs-built_in">len</span>(ds) <br>val=ds[index]<br>index=ds.index(val) <span class="hljs-comment">#查找，若为找到则返回-1</span><br>cnt=ds.count(index) <span class="hljs-comment">#计数</span><br>ds[index]=val <span class="hljs-comment">#添加</span><br>ds1.update(ds2) <span class="hljs-comment">#合并</span><br>ds.pop(key) <span class="hljs-comment">#删除</span><br>ds.clear()<br>ds[left:right]=<span class="hljs-built_in">sorted</span>(ds[left:right],reverse=b)<br>    <span class="hljs-comment">#局部/整体排序(用sort无效！）</span><br></code></pre></td></tr></table></figure><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br>HashMap&lt;<span class="hljs-type">float</span>, String&gt;hm=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-type">float</span>, String&gt;();<br>hm.isEmpty();<br>len=hm.size();<br>hm.containsKey(); <span class="hljs-comment">//是否存在某键</span><br>val=hm.get(key); <span class="hljs-comment">//获取键对应的值</span><br><span class="hljs-comment">//无查找函数，只能手搓遍历~</span><br>hm.put(key,value);<br>hm.remove(key);<br>hm.clear();<br>hm.keySet()/values(); <span class="hljs-comment">//获取所有键/值</span><br></code></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br>unordered_map &lt;<span class="hljs-type">float</span>, string&gt; f;<br>f.<span class="hljs-built_in">size</span>();<br>f.<span class="hljs-built_in">empty</span>();<br>f.<span class="hljs-built_in">find</span>(val); <span class="hljs-comment">//没找到就指向.end()</span><br>f.<span class="hljs-built_in">count</span>(key);<br>f.<span class="hljs-built_in">insert</span>(key,value);<br>f.<span class="hljs-built_in">erase</span>(key)/(left_iter,right_iter);<br>f.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span>(i=f.<span class="hljs-built_in">begin</span>();i!=f.<span class="hljs-built_in">end</span>();i++)&#123;…&#125; <span class="hljs-comment">//遍历</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用方向：源头感，适合求解类似于BFS的最值问题和“蔓延问题”，及求图论中的连通性（类似于前面的蔓延问题）、环数及边数的问题</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="创建-amp-查询（路径压缩）"><a href="#创建-amp-查询（路径压缩）" class="headerlink" title="创建&amp;查询（路径压缩）"></a>创建&amp;查询（路径压缩）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">f=&#123;&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find</span>(<span class="hljs-params">x</span>):<br>    f.setdefault(x,x)<br>    <span class="hljs-keyword">if</span> f[x]!=x:f[x]=find(f[x])<br>    <span class="hljs-keyword">return</span> f[x]<br></code></pre></td></tr></table></figure><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>比较规模大小，选择更省时的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">union</span>(<span class="hljs-params">x, y</span>):<br>    f[find(y)] = find(x)<br></code></pre></td></tr></table></figure><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="创建-amp-查询（路径压缩）-1"><a href="#创建-amp-查询（路径压缩）-1" class="headerlink" title="创建&amp;查询（路径压缩）"></a>创建&amp;查询（路径压缩）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BFSet</span>&#123;<br>    HashMap&lt;<span class="hljs-type">float</span>,String&gt; f=<span class="hljs-keyword">new</span> <span class="hljs-built_in">HashMap</span>&lt;<span class="hljs-type">float</span>,String&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">float</span> key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!f.<span class="hljs-built_in">containsKey</span>(key))<br>            f.<span class="hljs-built_in">put</span>(key,key);<br>        <span class="hljs-keyword">if</span>(f[key]!=key)<br>            f[key]=<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">return</span> f[key];<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="合并-1"><a href="#合并-1" class="headerlink" title="合并"></a>合并</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">void</span><span class="hljs-params">(<span class="hljs-type">float</span> key1,<span class="hljs-type">float</span> key2)</span></span><br><span class="hljs-function"></span>&#123;<br>f[<span class="hljs-built_in">find</span>(key1)])]=<span class="hljs-built_in">find</span>(key2);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="创建-amp-查询（路径压缩）-2"><a href="#创建-amp-查询（路径压缩）-2" class="headerlink" title="创建&amp;查询（路径压缩）"></a>创建&amp;查询（路径压缩）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br>unordered_map &lt;<span class="hljs-type">float</span>, <span class="hljs-type">float</span>&gt; f;<span class="hljs-comment">//支持string型</span><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">float</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">if</span>(!f.<span class="hljs-built_in">count</span>(x)||f[x]==x) <span class="hljs-keyword">return</span> f[x]=x;<br>        <span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="合并-2"><a href="#合并-2" class="headerlink" title="合并"></a>合并</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-type">float</span> x,<span class="hljs-type">float</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>        f[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用方向：需要频繁在头、尾部增删操作时</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>无库函数，只能手搓：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>（增删改查操作略~）</p><p>*一直只用a、a.next按某种规律遍历某个链表后依然可以得到一个完整的新链表！（最后返回的表头也得是a）</p><p>*链表变换时注意末尾的next置空！</p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>就直接调包，不搞手搓了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br>Linklist&lt;String&gt; l;<br>l.getFirst(…); <span class="hljs-comment">//获取头结点（尾部唯为getLast）</span><br>l.add(…); <span class="hljs-comment">//尾部追加</span><br>l.removeFirst(…); <span class="hljs-comment">//移除头结点（尾部唯为removeLast）</span><br><span class="hljs-comment">//修改操作包内无函数，必须遍历再改~</span><br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="库函数-极力推荐"><a href="#库函数-极力推荐" class="headerlink" title="库函数(极力推荐)"></a>库函数(极力推荐)</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>list&lt;string&gt; l; <span class="hljs-comment">//声明一个空链表</span><br><span class="hljs-function">list&lt;string&gt; <span class="hljs-title">l</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//声明一个含n个元素的链表并全部初始化为0</span><br></code></pre></td></tr></table></figure><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">l.insert/<span class="hljs-built_in">emplace</span>();                  <span class="hljs-comment">// 插入一个元素到list中(emplace更高效）</span><br>l.<span class="hljs-built_in">push_back</span>();                       <span class="hljs-comment">//在list的末尾添加一个元素 </span><br>l.<span class="hljs-built_in">push_front</span>();                      <span class="hljs-comment">//在list的头部添加一个元素</span><br>l.<span class="hljs-built_in">merge</span>();                           <span class="hljs-comment">//合并两个list</span><br></code></pre></td></tr></table></figure><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">l.<span class="hljs-built_in">erase</span>();                           <span class="hljs-comment">//删除一个元素</span><br>l.<span class="hljs-built_in">pop_back</span>();                        <span class="hljs-comment">//删除最后一个元素 </span><br>l.<span class="hljs-built_in">remove</span>();                          <span class="hljs-comment">//从list删除指定元素 </span><br>l.<span class="hljs-built_in">unique</span>();                          <span class="hljs-comment">//删除list中重复的元素</span><br></code></pre></td></tr></table></figure><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">l.<span class="hljs-built_in">reverse</span>();                         <span class="hljs-comment">//把list的元素倒转</span><br></code></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt;::iterator itr=l.<span class="hljs-built_in">begin</span>();   <span class="hljs-comment">// 返回第一个元素的迭代器 </span><br>l.<span class="hljs-built_in">front</span>();                           <span class="hljs-comment">//返回第一个元素 </span><br>l.<span class="hljs-built_in">back</span>();                            <span class="hljs-comment">//返回最后一个元素 </span><br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">l.<span class="hljs-built_in">sort</span>();                            <span class="hljs-comment">//给list排序</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/Anaconda/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/Anaconda/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list <span class="hljs-comment">#列出现有虚拟环境</span><br>conda list <span class="hljs-comment">#列出现有库</span><br>conda create -n name <span class="hljs-comment">#创建虚拟环境</span><br>conda activate name <span class="hljs-comment">#激活并进入到某虚拟环境</span><br>conda deactivate <span class="hljs-comment">#停止当前所在虚拟环境</span><br>conda <span class="hljs-built_in">env</span> remove -n name <span class="hljs-comment">#删除虚拟环境</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>优先队列：相当于完全二叉树的一维数组结构~（类似于堆）</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>由于Deque库函数语句全覆盖Queue，所以此处双向队列Deque和单向队列Queue专门不区分。</p><h2 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h2><p>略~</p><h2 id="库函数（推荐）"><a href="#库函数（推荐）" class="headerlink" title="库函数（推荐）"></a>库函数（推荐）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>d=deque() <span class="hljs-comment">#Deque()（双向队列） 创建一个空的新 deque。它不需要参数，并返回空的 deque</span><br>d.append/extend[left]()<br>[val=]d.pop[left]()<br></code></pre></td></tr></table></figure><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="单向队列Queue"><a href="#单向队列Queue" class="headerlink" title="单向队列Queue"></a>单向队列Queue</h2><p>用ArrayList类实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> java.util.ArrayList;<br>ArrayList&lt;DataType&gt;array_name=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayList</span>&lt;DataType&gt;();<br>array_name.<span class="hljs-built_in">add</span>() <span class="hljs-comment">//追加</span><br>array.name.<span class="hljs-built_in">set</span>(index,reset) <span class="hljs-comment">//修改</span><br>array_name.<span class="hljs-built_in">remove</span>(index) <span class="hljs-comment">//删除</span><br>array_name.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">//排序</span><br></code></pre></td></tr></table></figure><h2 id="双向队列Deque"><a href="#双向队列Deque" class="headerlink" title="双向队列Deque"></a>双向队列Deque</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> java.util.Deque;<span class="hljs-comment">//Deque类实现的子类有LinkedList、ArrayDeque</span><br>Deque &lt;ArrayDeque&gt; d=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Deque</span>&lt;ArrayDeque&gt;();<br>d.peek/getFirst/<span class="hljs-built_in">Last</span>();<br>    <span class="hljs-comment">//返回队首元素,若为空peek返回null,get抛异常</span><br>d.offer/addFirst/<span class="hljs-built_in">Last</span>(ele);<br>    <span class="hljs-comment">//如果不能添加元素,offer返回false,add会抛异常</span><br>d.poll/removeFirst/<span class="hljs-built_in">Last</span>();<br>    <span class="hljs-comment">//若为空poll返回null,remove抛异常</span><br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="单向队列Queue-1"><a href="#单向队列Queue-1" class="headerlink" title="单向队列Queue"></a>单向队列Queue</h2><h3 id="手搓-1"><a href="#手搓-1" class="headerlink" title="手搓"></a>手搓</h3><p>略~</p><h3 id="库函数（推荐）-1"><a href="#库函数（推荐）-1" class="headerlink" title="库函数（推荐）"></a>库函数（推荐）</h3><p>略~</p><h2 id="双向队列Deque-1"><a href="#双向队列Deque-1" class="headerlink" title="双向队列Deque"></a>双向队列Deque</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br>val=q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//获取队首</span><br>val=q.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">//获取队尾</span><br>q.<span class="hljs-built_in">push</span>(n); <span class="hljs-comment">//入队</span><br>q.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//出队，无返回值</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>应用：单调栈→按序遍历，栈中放置的因素单调递增&#x2F;减，若此时遍历到的元素＜&#x2F;&gt;栈末尾的元素（如果栈非空），则栈一路往回剔除元素直到此元素放入后可以继续单调</p><p>*共性操作（同队列、链表的操作，之后队列、链表的博客中便不再重复~）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">b=ds.empty() <br>length=<span class="hljs-built_in">len</span>(ds) <br>val=ds[index] <br>index=ds.index(val) <span class="hljs-comment">#查找，若为找到则返回-1</span><br>cnt=ds.count(index) <span class="hljs-comment">#计数</span><br>ds1.extend(ds2) <span class="hljs-comment">#合并</span><br>ds.clear()<br>ds[left:right]=<span class="hljs-built_in">sorted</span>(ds[left:right],reverse=b)<br><span class="hljs-comment">#局部/整体排序(用sort无效！）</span><br><span class="hljs-keyword">for</span> i/i,j <span class="hljs-keyword">in</span> ds/<span class="hljs-built_in">enumerate</span>(ds):…<br></code></pre></td></tr></table></figure><p>*手搓和库函数一样，都是通过列表直接实现！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lst.append/extend()<br>ele=lst[-<span class="hljs-number">1</span>]<br>lst.pop()<br>ele=lst.popleft()<br></code></pre></td></tr></table></figure><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="手搓"><a href="#手搓" class="headerlink" title="手搓"></a>手搓</h2><p>适当使用Array类方法~</p><h2 id="调包"><a href="#调包" class="headerlink" title="调包"></a>调包</h2><p>Stack类方法（使用时直接tm&#x3D;方法名(…)即可）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br></code></pre></td></tr></table></figure><table><thead><tr><th>1</th><th>boolean empty()   测试堆栈是否为空。</th></tr></thead><tbody><tr><td>2</td><td>Object peek( )  查看堆栈顶部的对象，但不从堆栈中移除它。</td></tr><tr><td>3</td><td>Object pop( )  移除堆栈顶部的对象，并作为此函数的值返回该对象。</td></tr><tr><td>4</td><td>Object push(Object element)  把项压入堆栈顶部。</td></tr><tr><td>5</td><td>int search(Object element)  返回对象在堆栈中的位置，以 1 为基数。</td></tr></tbody></table><p>*PS:Java堆栈Stack类已经过时，Java官方推荐使用Deque（见下）替代Stack使用。</p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>*共性操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Lib_Name&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>[std::]Lib_Name ds[&#123;length[,ele])];<br><span class="hljs-comment">//Lib_Name即DS类型,ds即DS的名称,不加ele时默认为0</span><br>b=ds.<span class="hljs-built_in">empty</span>();<br>len=ds.<span class="hljs-built_in">size</span>();<br>val=*iter;<span class="hljs-comment">//获取迭代器所指元素的值（由此修改）</span><br>*p=<span class="hljs-built_in">find</span>(iter_left,iter_right,target_val); <span class="hljs-comment">//若查找失败，返回iter_right</span><br>sum=ds.<span class="hljs-built_in">count</span>(val);<span class="hljs-comment">//计数</span><br>    <span class="hljs-comment">//合并操作除了要求两个容器都已经排好序的merge函数外无库函数，直接手搓~</span><br>ds.<span class="hljs-built_in">clear</span>();<br>ds.<span class="hljs-built_in">sort</span>(iter_left,iter_right,comp_func);<br><span class="hljs-comment">//逆向排序与其写compare函数调用，不如直接手搓循环~</span><br><span class="hljs-keyword">for</span>(i=ds.<span class="hljs-built_in">begin</span>();i!=ds.<span class="hljs-built_in">end</span>();i++)&#123;…&#125;<span class="hljs-comment">//遍历</span><br></code></pre></td></tr></table></figure><h2 id="手搓（推荐）"><a href="#手搓（推荐）" class="headerlink" title="手搓（推荐）"></a>手搓（推荐）</h2><p>略~</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br>t=s.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//获取栈顶元素</span><br>s.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//弹出栈顶元素，但不返回其值</span><br>s.<span class="hljs-built_in">push</span>(n);<span class="hljs-comment">//入栈</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>语言强化</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E8%AF%AD%E8%A8%80%E5%BC%BA%E5%8C%96/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E8%AF%AD%E8%A8%80%E5%BC%BA%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><ul><li>DS类架构图:</li></ul><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E8%AF%AD%E8%A8%80%E5%BC%BA%E5%8C%96/1688993315426.jpg" alt="1688993315426"></p><ul><li><p>常用内置函数：</p><p><em>记不清具体包名就 import java</em><em>.<strong>util</strong>.*;</em>*</p><p>*min,max</p><p>*最大公约数：（无需调包！）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">BigInteger gcd=x.<span class="hljs-built_in">gcd</span>(y);<br></code></pre></td></tr></table></figure></li><li><p>Hashset：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br>Set_name.size();<br>Set_name.contains(); <span class="hljs-comment">//是否存在</span><br>Set_name.add(…);<br>Set_name.remove();<br>Set_name.clear();<br></code></pre></td></tr></table></figure></li></ul><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="容器-amp-迭代器"><a href="#容器-amp-迭代器" class="headerlink" title="容器&amp;迭代器"></a>容器&amp;迭代器</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li><p>顺序容器</p><p>*排放顺序是与其加入容器时的位置相对应</p><p>*合法语法为&#x3D;&#x3D;、!&#x3D;、&gt;、&lt;</p><p>*勿忘对应头文件（<vector>等等）</vector></p><p>*具体分类：</p><ol><li><p>声明：vector<T>+名称（下同）：动态数组（通常用它）</T></p></li><li><p>list：双向链表，双向顺序访问&#x2F;遍历(链表不支持元素的随机访问），list在任何位置的插入和删除速度都很快，很方便。</p></li><li><p>string：字符串容器</p></li></ol><p>注意：若用的是C++中的功能，调用的库函数必须是&lt;cstring.h&gt;!</p></li><li><p>关联容器</p><p>*元素的位置由相关联的关键字值决定</p><p>*平衡二叉树（查找、修改元素各种操作时间复杂度都为O(n))</p><p>*多为const_…：只能用&#x3D;&#x3D;、!&#x3D;进行比较</p><p>*声明：set<T>+名称（下同）, multiset, map, multimap(有无序、可否有重复元素）</T></p><p>注意：#include&lt;…&gt;头文件勿忘！(）</p><p>*具体分类：</p><ul><li>multiset<T> st;</T></li></ul><p>*存放并自动排序元素(默认为从小到大）</p><p>*multiset&lt;int,greater<int>&gt;:从大到小排序的multiset（也可以是自定义的规则Rule1）</int></p><ul><li><p>set 插入元素可能不成功（因为元素不能重复）</p></li><li><p>map:键值对</p></li></ul><blockquote><p>*pair&lt;T1,T2&gt;类型等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span>&#123;<br>     T1 first/key;<br>     T2 second/value;<br>&#125;;<br><span class="hljs-built_in">make_pair</span>(T1,T2)<span class="hljs-comment">//生成一个pair&lt;T1,T2&gt;变量</span><br><br><span class="hljs-keyword">typedef</span> map&lt;string,<span class="hljs-type">int</span>&gt;MP;<br>MP mp;<br>mp[key]=[value];<br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>*每个种类的容器都有其对应的迭代器类型，且迭代器本身也可以选择定义类型（二者为组合关系，并不冲突）</p><p>*由容器决定的迭代器具体分类：输入&#x2F;输出&#x2F;前向&#x2F;双向(p++或–,不能直接访问p[i]、比大小、互相相减)&#x2F;随机访问(p+或-i)迭代器</p><table><thead><tr><th align="left">array</th><th align="left">随机访问迭代器</th></tr></thead><tbody><tr><td align="left">vector</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">deque</td><td align="left">随机访问迭代器</td></tr><tr><td align="left">list</td><td align="left">双向迭代器</td></tr><tr><td align="left">set &#x2F; multiset</td><td align="left">双向迭代器</td></tr><tr><td align="left">map &#x2F; multimap</td><td align="left">双向迭代器</td></tr><tr><td align="left">forward_list</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_map &#x2F; unordered_multimap</td><td align="left">前向迭代器</td></tr><tr><td align="left">unordered_set &#x2F; unordered_multiset</td><td align="left">前向迭代器</td></tr><tr><td align="left">stack</td><td align="left">不支持迭代器</td></tr><tr><td align="left">queue</td><td align="left">不支持迭代器</td></tr></tbody></table><p>定义类型&amp;整个迭代器的声明方式：</p><table><thead><tr><th align="left">迭代器定义方式</th><th align="left">具体格式</th></tr></thead><tbody><tr><td align="left">正向迭代器</td><td align="left">容器类名::iterator 迭代器名;</td></tr><tr><td align="left">常量正向迭代器</td><td align="left">容器类名:::const_iterator 迭代器名;</td></tr><tr><td align="left">反向迭代器</td><td align="left">容器类名::reverse_iterator 迭代器名;</td></tr><tr><td align="left">常量反向迭代器</td><td align="left">容器类名::const_reverse_iterator 迭代器名;</td></tr></tbody></table><p>*初始化（同指针）（即构造函数）：iter1&#x3D;ivec.begin();&#x2F;&#x2F;指向容器ivec首元素</p><p>*具体功能：</p><ul><li><p>名称.find(v):若找到元素值i,返回一个迭代器，指向key&#x3D;&#x3D;1，若未找到，返回end()</p></li><li><p>名称.count(v):遍历并返回对应元素值i出现的次数</p></li><li><p>名称.insert(i,v)在下标为i处插入元素，值为v（PS：“,v”可省略)</p></li><li><p>名称.erase(i)删除迭代器i指向的元素</p></li></ul><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>strlwr、strupr：字符串全部小写&#x2F;大写</p><h3 id="algorithm库"><a href="#algorithm库" class="headerlink" title="algorithm库"></a>algorithm库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">min/max/<span class="hljs-function">swap</span><br><span class="hljs-function"><span class="hljs-title">gcd</span><span class="hljs-params">(x,y)</span></span><br><span class="hljs-function"><span class="hljs-title">reverse</span><span class="hljs-params">(lst+<span class="hljs-number">1</span>,lst+n+<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">unique</span><span class="hljs-params">(lst+<span class="hljs-number">1</span>,lst+n+<span class="hljs-number">1</span>)</span> <span class="hljs-comment">//返回最后一个数的地址</span></span><br><span class="hljs-function"><span class="hljs-title">partial_sum</span><span class="hljs-params">(vec.begin(),vec.end(),back_inserter(dst) <span class="hljs-comment">//求前缀和</span></span></span><br><span class="hljs-params"><span class="hljs-function">next_permutation(vec.begin(),vec.end()) <span class="hljs-comment">//求全排列</span></span></span><br></code></pre></td></tr></table></figure><h3 id="string库"><a href="#string库" class="headerlink" title="string库"></a>string库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><p>获取长度：length()&#x2F;size()</p></li><li><p>拷贝</p><ol><li><p>一般：直接&#x3D;即可</p></li><li><p>特别的：</p></li></ol><p>*string str2&#x3D;string(str1,index) 从字符串str1第index个字符开始到结束（注：此处str2需为string对象，若为字符数组则变成前index个字符，下同！）</p><p>*string str2&#x3D;string(str1,index,len) 从字符串str1第index个字符开始，拷贝len个字符</p></li><li><p>修改</p><p>*追加：str1.append(str2)</p><p>*插入：str1.insesrt(index,str2) 在str1的index位置插入字符串str2</p><p>*删除：str.erase(index,len)将str1从index开始的len个字符删除</p><p>*替换：str1.replace(index,len,str2)将str1从index开始的len个字符替换成str2</p></li><li><p>比较</p><p>str1.compare(str2) 结果为±1，0</p></li><li><p>交换</p><p>str1.swap(str2)</p></li><li><p>查找位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">str1.<span class="hljs-built_in">find</span>(str2) <span class="hljs-comment">//查找str2在str1中第一次出现的位置</span><br>str1.<span class="hljs-built_in">rfind</span>(str2) <span class="hljs-comment">//查找str2在str1中最后一次出现的位置</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><p>*使用参考顺序：单独的排序&#x2F;查找功能→借助set或者map自动排序</p><p>提醒：勿忘#include以及using namespace std;!</p><ul><li><p>广义的sort函数排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(数组名<span class="hljs-number">1</span>+n1,数组名<span class="hljs-number">2</span>+n2,排序规则结构名())<br><span class="hljs-keyword">struct</span> 结构名<span class="hljs-comment">//(例如：StudentRule1)</span><br>｛<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> 数据类型&amp;a1, <span class="hljs-type">const</span> 数据类型&amp;a2)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">  </span>&#123;<br>   <span class="hljs-comment">//建立一定的排序规则</span><br>   <span class="hljs-comment">//若a1应该放在a2前面，则返回TRUE，反之返回FALSE</span><br>  <span class="hljs-keyword">if</span>...<br>      <span class="hljs-keyword">return</span> True;<br> ｝<br>｝<br></code></pre></td></tr></table></figure></li><li><p>二分查找</p><p>实际上应用于容器返回迭代器，此处为数组返回指针</p><ul><li>binary_search(数组名+n1,数组名+n2,值,（可有可无：排序结构名)</li></ul><p>*在从小到大排好序的基本类型数组上进行二分查找</p><p>*查找区间为左闭右开！</p><p>*仅返回bool值！</p><ul><li>lower_bound(数组名+n1,数组名+n2,值,(排序规则名()))</li></ul><p><em>返回一个指针</em>p</p><p><em>这个</em>p查找区间内下标最小的不小于对应值的元素，若找不到则指向下标为n2的元素</p><ul><li>upper_bound():同理~（下标仍为最小！）</li><li>find(数组名+n1,数组名+n2,值):可以不排好序</li></ul></li><li><p>其他：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*p=<span class="hljs-built_in">find</span>(left,right,target) <br>    <span class="hljs-comment">//left和right相当于sort函数中参数的指针形式，左闭右开，其指向的是在区域内查找到的第一个目标元素；如果查找失败，则该迭代器的指向和right相同</span><br><span class="hljs-built_in">merge</span>(left1,right1,left2,right2,result) <br>    <span class="hljs-comment">//用于合并两个同时升/降序的数组，参数都是迭代器</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><p>就是集合（Python里的set）~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>unordered_set &lt;string&gt; s;<br>s.<span class="hljs-built_in">size</span>();<br>s.<span class="hljs-built_in">empty</span>();<br>s.<span class="hljs-built_in">find</span>(ele);<br>   <span class="hljs-comment">//没找到则返回最后元素之后位置的迭代器（和s.end()相等说明没找到，类似于一般迭代器）</span><br>s.<span class="hljs-built_in">count</span>(ele);<br>s.<span class="hljs-built_in">insert</span>(ele);<br>s.<span class="hljs-built_in">erase</span>(ele);<br>s.<span class="hljs-built_in">clear</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>细心&amp;方法</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%BB%86%E5%BF%83%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88DSA%EF%BC%89/%E7%BB%86%E5%BF%83%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="细心"><a href="#细心" class="headerlink" title="细心"></a>细心</h1><p>*include时勿忘using namespace std!</p><p>*空用例或长度为1的用例格外小心！考虑全面（拒绝想当然！）</p><p>**为防止四舍五入导致精度损失，小数后面+eps&#x3D;1e-9!</p><p>*（Python和Java必看）ACM模式下涉及到类定义程序的实现：除了定义时在class定义的类中定义外，其他（函数和主函数）都在class外定义，调用时顺着需求调用即可</p><p>*树递归函数中需保证若返回树，左右子树都必须有定义（哪怕为空！）</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>*先把I&#x2F;O、库、二叉树定义+两种构建方式+中序遍历+层序遍历+BST的插入&amp;查找的板子都码了！</p><h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><ul><li><p>C[++]&#x2F;Java:全用C[++]</p></li><li><p>C[++]&#x2F;Java&#x2F;Python:</p></li></ul><blockquote><p>AVL：C[++]</p></blockquote><blockquote><p>其他：Python→（只可能是因为超时）C[++]</p></blockquote><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ol start="0"><li><p>（若语言为C++:）万能头文件：**#include &lt;bits&#x2F;stdc++.h&gt;**</p></li><li><p>由题目广阔联想寻找思路，尽量向高效算法靠近（遍历可以试着从右往左遍历，可能更简单！）</p></li><li><p>直接想到的思路不行的话试着换个角度&#x2F;对象&#x2F;操作试试（尤其是滑动窗口!）（看上去好像还需要回溯、非单调时仔细判断！）</p></li><li><p>DSA“对号入座”（典型的几个：BFS&#x2F;DFS,dp，二分查找（慎用！），二叉搜索树，若这些也优化不了考虑线性表变为哈希表）</p></li></ol><p>（很多都能转换成哈希表，多尝试转换成查询的模型，O(n)变成o(1)的利器！）</p><ol start="4"><li>针对目的和支持操作采取不同的数据结构（以下都支持插入、删除的任意操作组合）（再根据具体可用语言情况选择~）：</li></ol><ul><li><p>查找[、求最值]:AVL</p></li><li><p>求最值:二叉堆</p></li><li><p>*求和[、查找]（此时不可能再要求求最值）:线段树、树状数组</p></li></ul><ol start="5"><li><p>实在不行再试试栈、队列、链表、树、堆这几种数据结构！</p></li><li><p>根据题目结合树形、二进制编码等思想自己构造结构！</p></li></ol><p>PS：</p><p>*打表、找规律</p><p>*数组不会可以试着先排序一下&#x2F;强迫自己一遍遍历看看应该怎么实现（是否需要先排序）！</p><p>*判断算法是否可行时尤其注意dp和哈希表的判断，不要轻易放弃！</p><p>*滑动窗口可以两端各设立一个指针！</p><p><em>图论的edge数组尽量就直接开成n</em>n的</p><p>*特殊情况（树退化为链表等）可能会造成TLE的：随机化↓</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;len;i++)<br>&#123;<br>j=<span class="hljs-number">1</span>+<span class="hljs-built_in">rand</span>()%len; <span class="hljs-comment">//rand()函数生成1~MAX（计算机定义）的伪随机数</span><br><span class="hljs-built_in">swap</span>(arr[i],arr[j]); <span class="hljs-comment">//通过交换来随机化</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法（DSA）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MATLAB</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/MATLAB/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/MATLAB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="绘制图像和曲线常需要考虑到的因素"><a href="#绘制图像和曲线常需要考虑到的因素" class="headerlink" title="绘制图像和曲线常需要考虑到的因素"></a>绘制图像和曲线常需要考虑到的因素</h1><ol><li><p>图像窗口：编号、大小</p></li><li><p>图像、曲线本身：曲线颜色、线型、线宽、图例</p></li><li><p>坐标轴：取值范围、间隔、箭头</p></li><li><p>命名、添加文字：坐标轴、整个图像的标题（字体、颜色）、一些批注</p></li><li><p>保存</p></li></ol><h1 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=<span class="hljs-number">1790</span>:<span class="hljs-number">10</span>:<span class="hljs-number">2010</span><br>y=[<span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">18</span> <span class="hljs-number">21</span> <span class="hljs-number">23</span> <span class="hljs-number">37</span> <span class="hljs-number">24</span> <span class="hljs-number">29</span> <span class="hljs-number">30</span> <span class="hljs-number">28</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">36</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">44</span> <span class="hljs-number">42</span>]<br>f=polyfit(x,y,<span class="hljs-number">3</span>) <span class="hljs-comment">%用f记录拟合后的函数,3代表次数</span><br>x1=<span class="hljs-number">1790</span>:<span class="hljs-number">0.2</span>:<span class="hljs-number">2010</span> <span class="hljs-comment">%重新定义自变量x1</span><br>y1=polyval(f,x1) <span class="hljs-comment">%重新定义因变量y1</span><br><span class="hljs-built_in">plot</span>(x,y,<span class="hljs-string">&#x27;r*&#x27;</span> ,x1,y1,<span class="hljs-string">&#x27;b&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><table><thead><tr><th align="center">继型</th><th align="center">说明</th><th align="center">标记等</th><th align="center">说明</th><th align="center">敎色</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-</td><td align="center">实线(默认)</td><td align="center">+</td><td align="center">加号符</td><td align="center">r</td><td align="center">红色</td></tr><tr><td align="center">$\cdots$</td><td align="center">双划线</td><td align="center">$\circ$</td><td align="center">空心匽</td><td align="center">$\mathrm{g}$</td><td align="center">绿色</td></tr><tr><td align="center">:</td><td align="center">虚线</td><td align="center">$\approx$</td><td align="center">星号</td><td align="center">b</td><td align="center">蓝色</td></tr><tr><td align="center">$\therefore$</td><td align="center">点划线</td><td align="center"></td><td align="center">实湜</td><td align="center">c</td><td align="center">青绿色</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">$x$</td><td align="center">叉号符</td><td align="center">$\mathrm{m}$</td><td align="center">洋红色</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">s(square)</td><td align="center">正方形</td><td align="center">$y$</td><td align="center">黄色</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">d</td><td align="center">垩形</td><td align="center">k</td><td align="center">黑色</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">$\wedge$</td><td align="center">上三角形</td><td align="center">w</td><td align="center">白色</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">$v$</td><td align="center">下三角形</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">$&gt;$</td><td align="center">右三角形</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">$&lt;$</td><td align="center">左三角形</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">p(pentagram)</td><td align="center">五角星</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">h(hexagram)</td><td align="center">六边形</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">square</td><td align="center">正方形</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">pentagram</td><td align="center">五角形</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center">hexagram</td><td align="center">六形</td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear,clc <span class="hljs-comment">%clear清除所有变量,clc清屏</span><br>x=<span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">20</span>,<span class="hljs-number">1000</span>); <span class="hljs-comment">%linspace(a,b,k)表示在区间[a,b]中任取k个点（PS:x=0:0.02:20亦可！）</span><br>y1=<span class="hljs-number">2</span>*<span class="hljs-built_in">cos</span>(x);<br>y2=<span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span>*x);<br>y3=<span class="hljs-number">3</span>*<span class="hljs-built_in">sin</span>(x);<br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">%其实可以不写，代表图画框1，但是通常为了标记图像，我一般都会这样写</span><br><span class="hljs-built_in">plot</span>(x,y1,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;LineWidth&#x27;</span>,<span class="hljs-number">1.5</span>); <span class="hljs-comment">%黑色线性曲线，曲线宽度为1.5</span><br><span class="hljs-built_in">hold</span> on <span class="hljs-comment">%只需要一个hold on就可以了</span><br><span class="hljs-built_in">plot</span>(x,y2,<span class="hljs-string">&#x27;Color&#x27;</span>,[<span class="hljs-number">0.700</span>],<span class="hljs-string">&#x27;LineWidth&#x27;</span>,<span class="hljs-number">1.5</span>); <span class="hljs-comment">%RGB的R为0.7即深红</span><br><span class="hljs-built_in">plot</span>(x,y3,<span class="hljs-string">&#x27;r&#x27;</span>);<br>grid on <span class="hljs-comment">%添加分割线</span><br>subplot(a,b,k) <span class="hljs-comment">%命令一般出现于每个plot命令前，代表的意思是绘制a*b的框图，目前绘制第k个图（后常跟plot命令）</span><br><span class="hljs-built_in">plot</span>(x,<span class="hljs-built_in">sin</span>(x),<span class="hljs-string">&#x27;r&#x27;</span>/<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-comment">%改变颜色/颜色及图形形态</span><br>axis([<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-1.5</span>,<span class="hljs-number">1</span>]) <span class="hljs-comment">%用axis([xmin,xmax,ymin,ymax])函数来调整图轴的范围</span><br></code></pre></td></tr></table></figure><p>注解与处理：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">xlabel(<span class="hljs-string">&#x27;x轴&#x27;</span>); <span class="hljs-comment">% x轴注解</span><br>ylabel(<span class="hljs-string">&#x27;y轴&#x27;</span>); <span class="hljs-comment">% y轴注解</span><br>title(<span class="hljs-string">&#x27;x\sim y_1&#x27;</span>); <span class="hljs-comment">% 图形标题为x~y1</span><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;y = cos(x)&#x27;</span>); <span class="hljs-comment">% 图形注解</span><br>gtext(<span class="hljs-string">&#x27;y = cos(x)&#x27;</span>); <span class="hljs-comment">% 图形注解 ,用鼠标定位注解位置 </span><br></code></pre></td></tr></table></figure><p>*有关命名时出现中文可能会出现乱码的解决办法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">set(gca,<span class="hljs-string">&#x27;Fontname&#x27;</span>,<span class="hljs-string">&#x27;Monospaced&#x27;</span>,<span class="hljs-string">&#x27;Fontsize&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;FontWeight&#x27;</span>,<span class="hljs-string">&#x27;bold&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><p>*三维作图：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot3</span>(…)<br>set(gca,<span class="hljs-string">&#x27;XLim&#x27;</span>,[<span class="hljs-number">0</span> <span class="hljs-number">25</span>]); <span class="hljs-comment">%设置x轴的范围为[0,25]</span><br></code></pre></td></tr></table></figure><p>*绘制箭头：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clear,clct=[<span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">20</span>];<br>x=t.*<span class="hljs-built_in">cos</span>(t);<br>y=t.*<span class="hljs-built_in">sin</span>(t);<br>arrowPlot(x,y,<span class="hljs-string">&#x27;number&#x27;</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;LineWidth&#x27;</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p> 效果：</p><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/MATLAB/1688958957414.jpg" alt="1688958957414"></p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>4.数据可视化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>R语言</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/R%E8%AF%AD%E8%A8%80/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/R%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h1><h2 id="核心语句"><a href="#核心语句" class="headerlink" title="核心语句"></a>核心语句</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R">pie<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span> labels <span class="hljs-operator">=</span> <span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> edges <span class="hljs-operator">=</span> <span class="hljs-number">200</span><span class="hljs-punctuation">,</span> radius <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">,</span><br>    clockwise <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> init.angle <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span><span class="hljs-punctuation">(</span>clockwise<span class="hljs-punctuation">)</span> <span class="hljs-number">90</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>    density <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> angle <span class="hljs-operator">=</span> <span class="hljs-number">45</span><span class="hljs-punctuation">,</span> col <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> border <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span><br>    lty <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> main <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> …<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><ul><li><p>x: 数值向量，表示每个扇形的面积。</p></li><li><p>labels:     字符型向量，表示各扇形面积标签。</p></li><li><p>edges:     这个参数用处不大，指的是多边形的边数（圆的轮廓类似很多边的多边形）。</p></li><li><p>radius:     饼图的半径。</p></li><li><p>main:     饼图的标题。</p></li><li><p>clockwise:     是一个逻辑值,用来指示饼图各个切片是否按顺时针做出分割。</p></li><li><p>angle:     设置底纹的斜率。</p></li><li><p>density:     底纹的密度。默认值为 NULL。</p></li><li><p>col: 是表示每个扇形的颜色，相当于调色板。</p></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>3D绘图：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">install.packages<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;plotrix&quot;</span><span class="hljs-punctuation">,</span> repos <span class="hljs-operator">=</span> <span class="hljs-string">&quot; https://mirrors.ustc.edu.cn/CRAN/&quot;</span><span class="hljs-punctuation">)</span><br>pie3D<span class="hljs-punctuation">(</span>info<span class="hljs-punctuation">,</span>labels <span class="hljs-operator">=</span> <span class="hljs-built_in">names</span><span class="hljs-punctuation">,</span>explode <span class="hljs-operator">=</span> <span class="hljs-number">0.1</span><span class="hljs-punctuation">,</span> main <span class="hljs-operator">=</span> <span class="hljs-string">&quot;3D 图&quot;</span><span class="hljs-punctuation">,</span>family <span class="hljs-operator">=</span> <span class="hljs-string">&quot;STHeitiTC-Light&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h1 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h1><p>*核心语句</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">barplot<span class="hljs-punctuation">(</span>H<span class="hljs-punctuation">,</span>xlab<span class="hljs-punctuation">,</span>ylab<span class="hljs-punctuation">,</span>main<span class="hljs-punctuation">,</span> names.arg<span class="hljs-punctuation">,</span>col<span class="hljs-punctuation">,</span>beside<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><ul><li><strong>H</strong> 向量或矩阵，包含图表用的数字值，每个数值表示矩形条的高度。</li><li><strong>xlab</strong> x 轴标签。</li><li><strong>ylab</strong> y 轴标签。</li><li><strong>main</strong> 图表标题。</li><li><strong>names.arg</strong> 每个矩形条的名称。</li><li><strong>col</strong> 每个矩形条的颜色。</li><li><strong>beside&#x3D;FALSE</strong> 时，条形图的高度是矩阵的数值，矩形条是水平堆叠的。</li><li><strong>beside&#x3D;TRUE</strong> 时，条形图的高度是矩阵的数值，矩形条是并列的。</li></ul><h1 id="函数曲线"><a href="#函数曲线" class="headerlink" title="函数曲线"></a>函数曲线</h1><p>核心语句</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">curve<span class="hljs-punctuation">(</span>expr<span class="hljs-punctuation">,</span> from <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> to <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> n <span class="hljs-operator">=</span> <span class="hljs-number">101</span><span class="hljs-punctuation">,</span> add <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span><br>      type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;l&quot;</span><span class="hljs-punctuation">,</span> xname <span class="hljs-operator">=</span> <span class="hljs-string">&quot;x&quot;</span><span class="hljs-punctuation">,</span> xlab <span class="hljs-operator">=</span> xname<span class="hljs-punctuation">,</span> ylab <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-built_in">log</span> <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> xlim <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> …<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># S3 函数的方法</span><br>plot<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> to <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> from <span class="hljs-operator">=</span> y<span class="hljs-punctuation">,</span> xlim <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> ylab <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> …<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>• expr：函数表达式<br>• from 和 to：绘图的起止范围<br>• n：一个整数值，表示 x 取值的数量<br>• add：是一个逻辑值，当为 TRUE 时，表示将绘图添加到已存在的绘图中。<br>• type：绘图的类型，p 为点、l 为直线， o 同时绘制点和线，且线穿过点。<br>• xname：用于 x 轴变量的名称。<br>• xlim 和 ylim 表示x轴和y轴的范围。<br>• xlab，ylab：x 轴和 y 轴的标签名称。</p><h1 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h1><p>核心语句</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">plot<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">,</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;p&quot;</span><span class="hljs-punctuation">,</span> main<span class="hljs-punctuation">,</span> xlab<span class="hljs-punctuation">,</span> ylab<span class="hljs-punctuation">,</span> xlim<span class="hljs-punctuation">,</span> ylim<span class="hljs-punctuation">,</span> axes<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>• x 横坐标 x 轴的数据集合<br>• y 纵坐标 y 轴的数据集合<br>• type：绘图的类型，p 为点、l 为直线， o 同时绘制点和线，且线穿过点。<br>• main 图表标题。<br>• xlab、ylab x 轴和 y 轴的标签名称。<br>• xlim、ylim x 轴和 y 轴的范围（用二维向量表示即可）<br>• axes 布尔值，是否绘制两个 x 轴。</p><p>*type 参数可选择值：<br>• p：点图<br>• l：线图<br>• b：同时绘制点和线<br>• c：仅绘制参数 b 所示的线<br>• o：同时绘制点和线，且线穿过点<br>• h：绘制出点到横坐标轴的垂直线<br>• s：阶梯图，先横后纵<br>• S：阶梯图，先纵后竖<br>n： 空图</p><h1 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R">boxplot<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span> ...<span class="hljs-punctuation">,</span> <span class="hljs-built_in">range</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.5</span><span class="hljs-punctuation">,</span> width <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> varwidth <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span><br>        notch <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> outline <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">names</span><span class="hljs-punctuation">,</span> plot <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span><br>        border <span class="hljs-operator">=</span> par<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;fg&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> col <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">log</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        pars <span class="hljs-operator">=</span> <span class="hljs-built_in">list</span><span class="hljs-punctuation">(</span>boxwex <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span><span class="hljs-punctuation">,</span> staplewex <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span><span class="hljs-punctuation">,</span> outwex <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>         ann <span class="hljs-operator">=</span> <span class="hljs-operator">!</span>add<span class="hljs-punctuation">,</span> horizontal <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> add <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> at <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>x 参数为一个数值向量或者列表，若为列表则对列表中每一个子对象依次作出箱线图。</p><p>formula 为一个公式，比如 y ~ x。</p><p>data 参数为一个数据框或者列表。</p><p>na.action 参数是对NA值的操作，默认为忽略。</p><p>ann 参数为逻辑值，是否绘制坐标轴。</p><p>range 是一个延伸倍数，决定了箱线图的须延伸到什么位置。</p><p>width 设置箱子的宽度。</p><p>varwidth 为逻辑值，若为 TRUE，那么箱子的宽度与样本量的平方根成比例。</p><p>notch 决定了是否在箱子上画凹槽，可以用于比较两组数据的中位数是否有差异。</p><p>horizontal 是否水平放置箱线图。</p><p>add 参数设置是否将箱线图添加到现有图形上。</p><p>at 参数，当add为TRUE时，设置箱线图位置。</p><h1 id="克利夫兰图"><a href="#克利夫兰图" class="headerlink" title="克利夫兰图"></a>克利夫兰图</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs R">ggdotchart<span class="hljs-punctuation">(</span>dfm<span class="hljs-punctuation">,</span> x <span class="hljs-operator">=</span> <span class="hljs-string">&quot;automobiles&quot;</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mpg&quot;</span><span class="hljs-punctuation">,</span><br>           color <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cyl&quot;</span><span class="hljs-punctuation">,</span>                                <span class="hljs-comment"># 按组别配色</span><br>           palette <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;#FF0000&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;#00868B&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;#E066FF&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># 配置调色板</span><br>           sorting <span class="hljs-operator">=</span> <span class="hljs-string">&quot;descending&quot;</span><span class="hljs-punctuation">,</span>                       <span class="hljs-comment"># 降序排列</span><br>           dot.size <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>                                 <span class="hljs-comment"># 点的大小</span><br>           x.text.col <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span>                            <span class="hljs-comment"># x轴上的文字按组别配色</span><br>           ggtheme <span class="hljs-operator">=</span> theme_pubr<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>                        <span class="hljs-comment"># 设置主题</span><br>           <span class="hljs-punctuation">)</span><span class="hljs-operator">+</span><br>  theme_cleveland<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>                                      <span class="hljs-comment"># 加入虚线网格</span><br></code></pre></td></tr></table></figure><h1 id="星图（雷达图）"><a href="#星图（雷达图）" class="headerlink" title="星图（雷达图）"></a>星图（雷达图）</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">stars<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span>full <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span>draw.segments <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span>key.loc<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>xcoord<span class="hljs-punctuation">,</span>ycoord<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>…<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>x为数值矩阵或数据框</p><p>full为图形形状：full &#x3D; TRUE表示圆形，full &#x3D; FALSE表示半圆</p><p>draw.segments控制星相颜色，draw.segments&#x3D;T彩色,draw.segments&#x3D;F黑白</p><p>key.loc是用来调整右下角图例的位置的函数</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>4.数据可视化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matplotlib</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/Matplotlib/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/Matplotlib/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="绘制图像和曲线常需要考虑到的因素"><a href="#绘制图像和曲线常需要考虑到的因素" class="headerlink" title="绘制图像和曲线常需要考虑到的因素"></a>绘制图像和曲线常需要考虑到的因素</h1><ol><li><p>图像窗口：编号、大小</p></li><li><p>图像、曲线本身：曲线颜色、线型、线宽、图例</p></li><li><p>坐标轴：取值范围、间隔、箭头</p></li><li><p>命名、添加文字：坐标轴、整个图像的标题（字体、颜色）、一些批注</p></li><li><p>保存</p></li></ol><h1 id="函数整理"><a href="#函数整理" class="headerlink" title="函数整理"></a>函数整理</h1><h2 id="一般图"><a href="#一般图" class="headerlink" title="一般图"></a>一般图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x=np.linspace(-np.pi,np.pi,<span class="hljs-number">256</span>)<br>y=np.cos(x)<br>plt.figure(num=<span class="hljs-number">3</span>,figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">5</span>)) <span class="hljs-comment">#图像窗口的编号及大小（一个figure可以包含多个绘图区域）</span><br>plt.subplot(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">#分成3行2列，共6个绘图区域，在第4个区域绘图，排序为行优先（逗号可省略！）</span><br><br>plt.plot(x,y,color=<span class="hljs-string">&#x27;red&#x27;</span>,linewidth=<span class="hljs-number">2.5</span>,linestyle=<span class="hljs-string">&#x27;-&#x27;</span>,marker=<span class="hljs-string">&#x27;o/x&#x27;</span>,markersize=<span class="hljs-number">10</span>,label=<span class="hljs-string">r&#x27;$cos(t)$&#x27;</span>…)<br><span class="hljs-comment">#绘制图像本身（如果只有一个list默认其为Y轴，X轴数据为其索引值，从0开始）,后面（即…处）还可以加下一组x和y</span><br><span class="hljs-comment">#线型：实线为&#x27;-&#x27;,虚线为&#x27;:&#x27;,破折线为&#x27;--&#x27;</span><br><span class="hljs-comment">#marker为标记点的形状</span><br><span class="hljs-comment">#label为图例，$中间用LaTeX书写</span><br>plt.legend(loc=<span class="hljs-string">&#x27;upper left&#x27;</span>,frameon=<span class="hljs-literal">False</span>) <span class="hljs-comment">#图例的位置，frameon为图像背景的可见性（？）</span><br><br>plt.xlim(x.<span class="hljs-built_in">min</span>()*<span class="hljs-number">1.1</span>,x.<span class="hljs-built_in">max</span>()*<span class="hljs-number">1.1</span>)<br>plt.ylim(y.<span class="hljs-built_in">min</span>()*<span class="hljs-number">1.1</span>,y.<span class="hljs-built_in">max</span>()*<span class="hljs-number">1.1</span>) <span class="hljs-comment">#坐标轴的最两边值</span><br>plt.axis([-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])<br>    <span class="hljs-comment">#axis函数接收一个list，设定横纵坐标尺度，list各个参数分别代表[X初始刻度，X终止刻度，Y起始刻度，Y终止刻度]</span><br>plt.xticks([-np.pi,-np.pi/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,np/<span class="hljs-number">2</span>,np.pi])<br>plt.yticks([-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]) <span class="hljs-comment">#坐标轴上的刻度（这个跟axis的功能略有重合）</span><br>plt.annotate(s,x=arrow_crd,xtext=text_crd,arrowprops=<span class="hljs-built_in">dict</span>)<br><span class="hljs-comment">#在图形中增加带箭头的注解，s表示要注解的字符串是什么，x对应箭头所在的位置，xtext对应文本所在位置，arrowprops定义显示的属性</span><br>arrowprops=<span class="hljs-built_in">dict</span>(facecolor=‘black’,shrink=<span class="hljs-number">0.1</span>,width=<span class="hljs-number">2</span>)) <span class="hljs-comment">#width表示箭头宽度</span><br><br><span class="hljs-comment">#设置所有标注的字体</span><br>matplotlib.rcParams[‘font.family’] = ‘STSong’ <span class="hljs-comment">#字体名字（此处为华文仿宋）</span><br>matplotlib.rcParams[‘font.style’]=<span class="hljs-string">&#x27;normal&#x27;</span> <span class="hljs-comment">#字体风格（italic为斜体） </span><br>matplotlib.rcParams[‘font.size’] = <span class="hljs-number">20</span><br><br>plt.ylabel(<span class="hljs-string">&quot;x&quot;</span>)<span class="hljs-comment">#注上x轴名称</span><br>plt.ylabel(<span class="hljs-string">&quot;y&quot;</span>)<br>plt.title(<span class="hljs-string">&#x27;余弦函数&#x27;</span>) <span class="hljs-comment">#对图形整体增加文本标签</span><br>plt.text(<span class="hljs-string">&#x27;…&#x27;</span>) <span class="hljs-comment">#在任意位置增加文本</span><br><br>plt.savefig(path,dpi = <span class="hljs-number">600</span>,bbox_inches= <span class="hljs-string">&#x27;tight&#x27;</span>)<br>    <span class="hljs-comment">#savefig函数用来保存图片至path地址，dpi值表示每英寸具有的像素点数，1英寸=2.54cm,bbox_inches= &#x27;tight&#x27;表示将裁剪剩余部分</span><br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="Ploy可绘制图表大全"><a href="#Ploy可绘制图表大全" class="headerlink" title="Ploy可绘制图表大全"></a>Ploy可绘制图表大全</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(x,y , fmt)  <span class="hljs-comment">#绘制坐标图</span><br>plt.boxplot(data, notch, position) <span class="hljs-comment">#绘制箱形图</span><br>plt.bar(left, height, width, bottom) <span class="hljs-comment">#绘制条形图</span><br>plt.barh(width, bottom, left, height) <span class="hljs-comment">#绘制横向条形图</span><br>plt.polar(theta, r) <span class="hljs-comment">#绘制极坐标图</span><br>plt.pie(data, explode) <span class="hljs-comment">#绘制饼图</span><br>plt.scatter(x, y) <span class="hljs-comment">#绘制散点图</span><br>plt.hist(x, bings, normed) <span class="hljs-comment">#绘制直方图</span><br></code></pre></td></tr></table></figure><h2 id="核密度图"><a href="#核密度图" class="headerlink" title="核密度图"></a>核密度图</h2><ol><li><p>先将实测数据保存到 data.txt 中：</p><table><thead><tr><th>x</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>93</td></tr><tr><td>2</td><td>…</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></li><li><p>绘图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">KdePlot</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    <span class="hljs-comment"># 设置中文显示</span><br>    plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]    <span class="hljs-comment"># 中文字体设置-黑体</span><br>    plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>      <span class="hljs-comment"># 解决保存图像是负号&#x27;-&#x27;显示为方块的问题</span><br><br>    <span class="hljs-comment"># 绘制核密度分布直方图</span><br>    plt.figure()<br>    sns.<span class="hljs-built_in">set</span>(style=<span class="hljs-string">&#x27;white&#x27;</span>,          <span class="hljs-comment"># 设置边框颜色</span><br>            font = <span class="hljs-string">&#x27;SimHei&#x27;</span>)        <span class="hljs-comment"># 设置中文字体</span><br>    sns.distplot(x,                 <span class="hljs-comment"># 指定绘图数据</span><br>                 color=<span class="hljs-string">&#x27;orange&#x27;</span>,    <span class="hljs-comment"># 设置绘图颜色</span><br>                 kde=<span class="hljs-literal">True</span>,          <span class="hljs-comment"># 绘制密度曲线</span><br>                 hist=<span class="hljs-literal">True</span>,         <span class="hljs-comment"># 绘制直方图</span><br>                 rug=<span class="hljs-literal">True</span>,          <span class="hljs-comment"># 绘制 rug 图（变量分布）</span><br>                 kde_kws = &#123;<span class="hljs-string">&quot;shade&quot;</span>: <span class="hljs-literal">True</span>,          <span class="hljs-comment"># 进行面积填充</span><br>                            <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&#x27;darkorange&#x27;</span>,  <span class="hljs-comment"># 设置线条颜色</span><br>                            <span class="hljs-comment"># &#x27;linewidth&#x27;: 1.0,     # 设置线条粗细</span><br>                            <span class="hljs-string">&#x27;facecolor&#x27;</span>: <span class="hljs-string">&#x27;gray&#x27;</span>&#125;,   <span class="hljs-comment"># 设置填充颜色</span><br>                 rug_kws = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>,         <span class="hljs-comment"># 设置 rug 颜色</span><br>                            <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">0.1</span>&#125;)         <span class="hljs-comment"># 设置 rug 长度</span><br>                 <span class="hljs-comment"># vertical = True)                 # 颠倒 x-y 轴位置</span><br><br>    plt.title(<span class="hljs-string">&#x27;我是标题&#x27;</span>)               <span class="hljs-comment"># 设置图片标题</span><br>    plt.xlabel(<span class="hljs-string">&#x27;Label&#x27;</span>)                 <span class="hljs-comment"># 设置 x 轴标签</span><br>    plt.ylabel(<span class="hljs-string">&#x27;density&#x27;</span>)               <span class="hljs-comment"># 设置 y 轴标签</span><br>    plt.savefig(<span class="hljs-string">&#x27;out.png&#x27;</span>, dpi=<span class="hljs-number">300</span>)     <span class="hljs-comment"># 存储图片</span><br>    plt.show()<br><br><br><span class="hljs-comment"># 读取数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reader</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>    file = pd.read_csv(data, sep=<span class="hljs-string">&#x27;\s+&#x27;</span>)<br>    data = pd.DataFrame(file, columns=[<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>])<br>    x = data[<span class="hljs-string">&#x27;x&#x27;</span>]<br>    y = data[<span class="hljs-string">&#x27;value&#x27;</span>]<br>    <span class="hljs-keyword">return</span> x, y<br><br><br><span class="hljs-comment"># 代码执行部分</span><br>data = <span class="hljs-string">&#x27;data.txt&#x27;</span><br>x, y = reader(data)<br>KdePlot(y)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>4.数据可视化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件实现</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要软件（Excel勿忘绘图插件！）</p><ul><li><p>流程图：亿图图示（→PPT的SmartArt→Visio）</p></li><li><p>可供选择的图表类型：雷达图（替代饼状图）、环形图、散点图、气泡图、瀑布图</p></li></ul><p>数据可视化视图（除矩阵热力图、三维散点图）：FineBi&#x2F;Origin&#x2F;EXCEL（大数据的各种图）（→SPSS（大数据的基本图）→亿图图示（数据极少的各种图））</p><ul><li><p>自由发挥的关系图&#x2F;（偏艺术）图&#x2F;图表上色（&#x2F;示意图）：AI</p></li><li><p>（相关系数）矩阵热力图：（SPSSPro→SPSSAu→）Origin→Finebi→EXCEL+PPT&#x2F;OneNote</p></li><li><p>坐标曲线图：EXCEL（由点拟合二维曲线）→MATLAB（由点拟合三维曲线）→Origin（各种二&#x2F;三维曲线）（→Geogebra（各种二&#x2F;三维曲线）→**几何画板（二维f(x)））</p></li><li><p>词云图：Wordart（可以自定义形状）（→SPSSAu→FineBi）</p></li><li><p>三维散点图：Origin</p></li><li><p>地图：FineBi（热力图）→SPSS&#x2F;BDS&#x2F;EXCEL（三维）地图（色阶图）→EXCEL-Bing（饼图）（→亿景无忧地图（热力图））</p></li><li><p>*网络图：Gephi（大数据）→Graph Editor&#x2F;Graph（数据较少）</p></li><li><p>*物理示意图：亿图图示（简单图）→AI&#x2F;Axglyph（各种图）（精确图：AutoCAD）</p></li><li><p>等高线图：Origin</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>4.数据可视化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scikit-learn</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Scikit-learn/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Scikit-learn/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*基本用不到，真要用的时候现查I&#x2F;O即可~</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>3.数据挖掘分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>数据挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scipy</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Scipy/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Scipy/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>拟合统计模型，进行统计试验</p><h1 id="笔记整合"><a href="#笔记整合" class="headerlink" title="笔记整合"></a>笔记整合</h1><p>“用时现查现套”型，略~</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>3.数据挖掘分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>数据挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>StatNodels</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/StatNodels/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/StatNodels/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>拟合统计模型，进行统计试验</p><h1 id="笔记整合"><a href="#笔记整合" class="headerlink" title="笔记整合"></a>笔记整合</h1><p>“用时现查现套”型，略~</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>3.数据挖掘分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>数据挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据挖掘聚类算法实现</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="层次聚类、K-Means聚类"><a href="#层次聚类、K-Means聚类" class="headerlink" title="层次聚类、K-Means聚类"></a>层次聚类、K-Means聚类</h1><p>SPSSPro~</p><h1 id="DBSCANS"><a href="#DBSCANS" class="headerlink" title="DBSCANS"></a>DBSCANS</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><br><span class="hljs-comment"># 导入数据,sklearn自带鸢尾花数据集</span><br>iris = load_iris().data<br><span class="hljs-built_in">print</span>(iris)<br><br><span class="hljs-comment">#使用DBSCAN算法</span><br><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> DBSCAN<br>iris_db = DBSCAN(eps=<span class="hljs-number">0.6</span>,min_samples=<span class="hljs-number">4</span>).fit_predict(iris)<br>db = DBSCAN(eps=<span class="hljs-number">10</span>, min_samples=<span class="hljs-number">2</span>).fit(iris)<br>        <span class="hljs-comment">#设置半径为0.6（半径大小影响聚类出的簇的数量），最小样本量为2，建模</span><br>counts = pd.value_counts(iris_db,sort=<span class="hljs-literal">True</span>)<br>        <span class="hljs-comment">#统计每一类的数量</span><br><span class="hljs-built_in">print</span>(counts)<br><br><span class="hljs-comment">#*可视化</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">u&#x27;Microsoft YaHei&#x27;</span>]<br>fig,ax = plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))<br>        <span class="hljs-comment">#画聚类后的结果</span><br>ax1 = ax[<span class="hljs-number">0</span>]<br>ax1.scatter(x=iris[:,<span class="hljs-number">0</span>],y=iris[:,<span class="hljs-number">1</span>],s=<span class="hljs-number">250</span>,c=iris_db)<br>ax1.set_title(<span class="hljs-string">&#x27;DBSCAN聚类结果&#x27;</span>,fontsize=<span class="hljs-number">20</span>)<br>        <span class="hljs-comment">#画真实数据结果</span><br>ax2 = ax[<span class="hljs-number">1</span>]<br>ax2.scatter(x=iris[:,<span class="hljs-number">0</span>],y=iris[:,<span class="hljs-number">1</span>],s=<span class="hljs-number">250</span>,c=load_iris().target)<br>ax2.set_title(<span class="hljs-string">&#x27;真实分类&#x27;</span>,fontsize=<span class="hljs-number">20</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>3.数据挖掘分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>数据挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Pandas/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Pandas/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*科学计算，结合Scipy、Matplotlib使用~</p><p>*底层依然由ndarray实现，但共性操作的语句略有不同。</p><ol><li><p>一维：Series为一列标签和一列对应的值，融合了字典和ndarray的优点</p></li><li><p>二维（大多用到二维就够了，实际上还能更高维，即代替Panel）：</p></li></ol><p>DataFrame为表格型的数据结构，行列都有索引，其中列可以有多层嵌套的索引，由Series构成（相当于≥3个字母的卡诺图）</p><ol start="3"><li>三维（少用）：Panel是具有异构数据的三维数据结构。很难用图形表示面板。但是面板可以说明为DataFrame的容器。</li></ol><p>*相比Numpy中作为同质性数据结构的矩阵，以Series、DataFrame作为主要数据结构，可存放、处理异质型数据。库函数多与Numpy类似。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>*dtype：数据类型，如float64</p><p>*广播：是对不同形状(shape)的ndarray进行数值计算、迭代的方式运算是自动补全（一般为补0）成参与运算的ndarray最小的兼容大小。</p><p>*axis&#x3D;0为行操作，1为列操作，一般可省略</p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><h2 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pandas.Series( data, index, dtype, copy) <span class="hljs-comment">#也可以Series(dtype)</span><br></code></pre></td></tr></table></figure><p>data:数据采用各种形式，例如ndarray，list，常量</p><p>index:索引值必须是唯一且可哈希的，且长度与数据相同。如果未传递索引，则默认为np.arrange(n)。</p><p>dtype:dtype用于数据类型。如果为None，则将推断数据类型</p><p>copy:复制数据。默认为假</p><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pandas.DataFrame( data, index, columns, dtype, copy)<br></code></pre></td></tr></table></figure><p>data:数据采用各种形式，例如ndarray，系列，映射，列表，dict，常量以及另一个DataFrame。</p><p>index:对于行标签，如果没有传递索引，则用于结果帧的索引是Optional Default np.arange(n)。</p><p>columns:对于列标签，可选的默认语法为-np.arange(n)。仅当未传递索引时才如此。</p><p>dtype:每列的数据类型。</p><p>copy:如果默认值为False，则此命令（或任何它的命令）用于复制数据。</p><p>获取值通过df[key]（就跟字典一样）</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>*语句中所有的index实际上都支持index1,…indexn（即多个index同时操作）、:语句切片、…语句（真的’…’!）全选，但以下统一简写为index！（dim同理！！）</p><p>*Series没有索引时默认为从0开始的下标，即同ndarray。</p><p>*Pandas：</p><h2 id="静态（除了运算）"><a href="#静态（除了运算）" class="headerlink" title="静态（除了运算）"></a>静态（除了运算）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">ds.dim() <span class="hljs-comment">#返回维数</span><br>ds.size() <br>ds.empty()<br>ds[key] <span class="hljs-comment">#通过键获取、修改值</span><br>ds.loc[tag]/iloc[<span class="hljs-built_in">int</span>] <span class="hljs-comment">#基于标签/整数索引获取、修改值(与上一行类似)</span><br>ds[ds.index==v].index().tolist()[dim] <span class="hljs-comment">#返回[某一维度的]索引(一般dim=0，返回行索引)</span><br>ds.index()/values() <span class="hljs-comment">#ndarray形式返回，由此遍历</span><br>df.head/tail(num) <span class="hljs-comment">#返回前/后n行(仅限于DataFrame)</span><br></code></pre></td></tr></table></figure><h2 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">ds1.append(ds2[,axis=...]) <br>    <span class="hljs-comment">#若为DataFrame则根据axis取值分别对应添加在下面新行还是每行右边新列</span><br>pd.merge(df1,...,on=<span class="hljs-string">&#x27;key&#x27;</span>,how=<span class="hljs-string">&#x27;left&#x27;</span>) <br>    <span class="hljs-comment">#DataFrame的合并，on表示连接列，how选择连接方式</span><br>    <span class="hljs-comment">#当连接列名不同分别指定left_on,right_on代替原on</span><br>pd.concat([s1,...][,axis=<span class="hljs-number">1</span>]) <span class="hljs-comment">#Series的合并</span><br>Series.drop/<span class="hljs-keyword">del</span>(index[,axis])   <br>    <span class="hljs-comment">#drop函数返回一个删除后的副本（视图），不改变原ds,而del会改变</span><br>ds2=ds1.sort_index([axis=...])/values([...,...],ascending=b) <span class="hljs-comment">#False降序</span><br>Series.rank([axis=...]) <span class="hljs-comment">#Series排序</span><br></code></pre></td></tr></table></figure><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ds.count/<span class="hljs-built_in">sum</span>/mean/std/(axis)<br>ds[index].value_counts(val) <span class="hljs-comment">#统计某一列值的频率</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>3.数据挖掘分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>数据挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Numpy/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Numpy/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*科学计算，结合Scipy、Matplotlib使用~</p><p>*相当于矩阵（但不只能存放数），相比列表只能存放同质型，但因此除了通用基本操作与列表一样外多了各种计算操作。</p><p>*一种索引能力更强的数据结构，支持多种基本操作。</p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> p<br><span class="hljs-comment">#创建</span><br>arr=np.array([[…],…][,dtype]) <br>arr=np.empty([dim1,…dimn][,dtype])<br>arr=np.zeros/eyes/ones((dim1,dim2,…dimn)[,dtype]) <span class="hljs-comment">#ones即eyes</span><br>arr=np.arange(left,right,step[,dtype]) <span class="hljs-comment">#等差数组</span><br>arr.reshape(dim1<span class="hljs-string">&#x27;,…dimn&#x27;</span><span class="hljs-string">&#x27;)</span><br></code></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>*语句中所有的index实际上都支持index1,…indexn（即多个index同时操作）、:语句切片、…语句（真的’…’!）全选，但以下统一简写为index！（dim同理！！）</p><p>*以ndarray为数据结构</p><h2 id="静态（运算除外）"><a href="#静态（运算除外）" class="headerlink" title="静态（运算除外）"></a>静态（运算除外）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr.isnan() <span class="hljs-comment">#判空（Series则为isnull）</span><br>arr.shape() <span class="hljs-comment">#获取维度(即dim1-dimn)</span><br>arr.size() <span class="hljs-comment">#获取元素总个数</span><br>arr[[dim1],…[dimn]] <span class="hljs-comment">#获取n维索引的元素</span><br>arr[x[x&gt;val]) <span class="hljs-comment">#筛选出满足条件的x，返回一个一维列表</span><br>index=np.where(arr&gt;…) <span class="hljs-comment">#筛选出元素索引</span><br>arr[dim1,…dimn] <span class="hljs-comment">#ndarray获取值与列表一样,修改、遍历同理</span><br></code></pre></td></tr></table></figure><h2 id="动态"><a href="#动态" class="headerlink" title="动态"></a>动态</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">np.insert(arr,loc,val,axis) <span class="hljs-comment">#插入，都支持广播（iloc则只能传入数字）</span><br>np.append(arr, values, axis=<span class="hljs-literal">None</span>)<br>        <span class="hljs-comment">#axis默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！</span><br>        <span class="hljs-comment">#axis为0时单独加行，为1时加载每行右边</span><br>np.delete(arr,index/(index1,…indexn),axis=<span class="hljs-number">0</span>) <br>np.extract(condition,arr) <span class="hljs-comment">#根据条件抽取元素</span><br>np.sort(arr,axis) <span class="hljs-comment">#排序 </span><br>np.unique(arr, return_index, return_inverse, return_counts) <span class="hljs-comment">#去重</span><br>        <span class="hljs-comment">#return_index/inverse分别以列表形式返回新/旧列表元素在旧/新列表中的下标</span><br>        <span class="hljs-comment">#return_counts返回去重数组中的元素在原数组中的出现次数</span><br></code></pre></td></tr></table></figure><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">snallest/biggest=arr.amin/amax(index)<br>s/b_index=np.argmin/argmax(arr,axis)    <span class="hljs-comment">#最小索引、最大索引</span><br>arr.count/<span class="hljs-built_in">sum</span>/<span class="hljs-built_in">min</span>/<span class="hljs-built_in">max</span>/mean/std/var(axis) <span class="hljs-comment">#各种 （如果给axis赋值了那么就按相应的行/列分别计算）  </span><br>arr.<span class="hljs-built_in">all</span>/<span class="hljs-built_in">any</span>() <span class="hljs-comment">#检查数组中是否全部/部分为真  </span><br>arr.T <span class="hljs-comment">#转置</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>3.数据挖掘分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>数据挖掘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>R←→容器</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/R%E2%86%90%E2%86%92%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/R%E2%86%90%E2%86%92%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 验证包是否安装</span><br><span class="hljs-built_in">any</span>(grepl(<span class="hljs-string">&quot;xlsx&quot;</span>,installed.packages()))<br><span class="hljs-comment"># 载入包</span><br>library(<span class="hljs-string">&quot;xlsx&quot;</span>)<br><span class="hljs-comment"># 读取 sites.xlsx 第一个工作表数据</span><br>data &lt;- read.xlsx(<span class="hljs-string">&quot;sites.xlsx&quot;</span>, sheetIndex = <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">write.table (x, file =<span class="hljs-string">&quot;&quot;</span>, sep =<span class="hljs-string">&quot;&quot;</span>, row.names =TRUE, col.names =TRUE, quote =TRUE)<br>x：需要导出的数据<br>file：导出的文件路径<br>sep：分隔符，默认为空格（<span class="hljs-string">&quot; &quot;</span>），也就是以空格为分割列<br>row.names：是否导出行序号，默认为TRUE，也就是导出行序号<br>col.names：是否导出列名，默认为TRUE，也就是导出列名<br>quote：字符串是否使用引号表示，默认为TRUE，也就是使用引号表示<br></code></pre></td></tr></table></figure><p>(write.csv类似）</p><h1 id="DataGrip"><a href="#DataGrip" class="headerlink" title="DataGrip"></a>DataGrip</h1><p>更建议直接自身内部操作！</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">install.packages(<span class="hljs-string">&quot;RMariaDB&quot;</span>, repos = <span class="hljs-string">&quot; https://mirrors.ustc.edu.cn/CRAN/&quot;</span>)<br>library(RMySQL)<br><span class="hljs-comment"># dbname 为数据库名，这边的参数请根据自己实际情况填写</span><br>mysqlconnection = dbConnect(MySQL(), user = <span class="hljs-string">&#x27;root&#x27;</span>, password = <span class="hljs-string">&#x27;&#x27;</span>, dbname = <span class="hljs-string">&#x27;test&#x27;</span>,host = <span class="hljs-string">&#x27;localhost&#x27;</span>)<br><span class="hljs-comment"># 查看数据</span><br>dbListTables(mysqlconnection)<br></code></pre></td></tr></table></figure><h2 id="读取数据库的表（dbSendQuery-fetch"><a href="#读取数据库的表（dbSendQuery-fetch" class="headerlink" title="读取数据库的表（dbSendQuery+fetch)"></a>读取数据库的表（dbSendQuery+fetch)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">library(RMySQL)<br><span class="hljs-comment"># 查询 sites 表，增删改查操作可以通过第二个参数的 SQL 语句来实现</span><br>result = dbSendQuery(mysqlconnection, <span class="hljs-string">&quot;select * from sites&quot;</span>)<br><span class="hljs-comment"># 获取前面两行数据</span><br>data.frame = fetch(result, n = <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(data.fame)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>2.数据处理&amp;IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python第三方库←→容器</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/Python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E2%86%90%E2%86%92%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/Python%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E2%86%90%E2%86%92%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.load[txt](<span class="hljs-string">&quot;绝对路径&quot;</span>,arr) <span class="hljs-comment">#读取</span><br>np.save[z](<span class="hljs-string">&quot;绝对路径&quot;</span>,arr) ＃读取、保存文件<br></code></pre></td></tr></table></figure><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> Pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-comment">#导入</span><br>df1=pd.DataFrame(pd.read_Excel(<span class="hljs-string">&#x27;name.xlsx&#x27;</span>),sheet_name=…) <br>    <span class="hljs-comment">#若sheet_name=None, 可读取全部sheet，返回字典，key为sheet名字，value为sheet表内容</span><br>df2=pd.DataFrame(pd.read_csv(<span class="hljs-string">&#x27;name.csv&#x27;</span>,header=<span class="hljs-number">1</span>))<br>… <span class="hljs-comment">#操作见Pandas库笔记</span><br><span class="hljs-comment">#导出</span><br>df1.to_excel/csv(excel/csv_name)<br></code></pre></td></tr></table></figure><h1 id="SO、DataGrip"><a href="#SO、DataGrip" class="headerlink" title="SO、DataGrip"></a>SO、DataGrip</h1><p>都不会用到~</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>2.数据处理&amp;IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python（非Pandas的DataFrame）←→容器</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/Python%EF%BC%88%E9%9D%9EPandas%E7%9A%84DataFrame%EF%BC%89%E2%86%90%E2%86%92%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/Python%EF%BC%88%E9%9D%9EPandas%E7%9A%84DataFrame%EF%BC%89%E2%86%90%E2%86%92%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OS库"><a href="#OS库" class="headerlink" title="OS库"></a>OS库</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cur_path=os.getcwd() <span class="hljs-comment">#查看当前目录（之后可对cur_path进行字符串操作）</span><br>os.chdir(<span class="hljs-string">&quot;E:\...\...&quot;</span>) <span class="hljs-comment">#重新设置当前工作空间</span><br></code></pre></td></tr></table></figure><h1 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h1><p>针对2010及之后版本的、xlsx（数据量相比xls更大）格式的Excel的文件）（其他Excel文件需另学xlwt和xlrd库)</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>首先分清：book对应Excel工作簿，一个book里包含一些sheet（工作表）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#以下操作row[s]和col[umn][s]相对（函数命令为column，命名为col），只展示row的操作~</span><br><span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook,Workbook<br><span class="hljs-comment">#两者操作的核心对象都是workbook(即Excel工作簿），前者一般打开已存在的工作簿，后者一般用于新建空工作簿</span><br><span class="hljs-comment">#还有个专门新建和写入（包括xls文件）的库xlsxwriter，写入速度比此二者略快，但其他差不多，为了少导一个库就不用了，必要时可以学一下</span><br></code></pre></td></tr></table></figure><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">workbook1=load_workbook(<span class="hljs-string">&#x27;[…\]excel_name.xlsx\&#x27;\&#x27;E:\...\excel_name.xlsx&#x27;</span>) <span class="hljs-comment">#打开</span><br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python">sheet_names=workbook1.sheetnames <span class="hljs-comment">#获得所有sheet（工作表）的名称（下标从0开始！）</span><br>table=workbook1[sheet_names[target_index]]<br><span class="hljs-comment">#通过表名获取当前表对象，方便后续进行遍历操作（也可以用workbook.get_sheet_by_name（）方法）</span><br>rows=table.max_row <span class="hljs-comment">#获取行数</span><br>Data=table.cell(row=row,column=col).value <span class="hljs-comment">#获取单元格值（下标从1开始）</span><br>row=<span class="hljs-built_in">list</span>(table.rows) <span class="hljs-comment">#获取全部行（此处row是一个由worksheet迭代对象转换而成的一维列表）</span><br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> table.iter_rows(<span class="hljs-string">&#x27;A1:D4&#x27;</span>/min_row=<span class="hljs-number">1</span>,max_row=<span class="hljs-number">4</span>,min_col=<span class="hljs-number">1</span>,max_col=<span class="hljs-number">4</span>): <br>    <span class="hljs-comment">#遍历表格（数据太多可以考虑后者参数方法）</span><br>    <span class="hljs-comment">#也可以直接用range遍历下标，用cell函数获取单元格值</span><br>    <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> row: <span class="hljs-built_in">print</span>(cell.value) <span class="hljs-comment">#获取值用点运算符.value</span><br>    <span class="hljs-comment">#此处还可以修改（即写入）：cell.value=… !（空单元格value为&quot;&quot;）</span><br></code></pre></td></tr></table></figure><h3 id="新建-amp-写入"><a href="#新建-amp-写入" class="headerlink" title="新建&amp;写入"></a>新建&amp;写入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Python">workbook2=openpyxl.Workbook() <span class="hljs-comment">#新建Excel空表</span><br>sheet2=workbook2.active <span class="hljs-comment">#激活worksheet</span><br>sheet2[<span class="hljs-string">&#x27;A1&#x27;</span>]=<span class="hljs-string">&#x27;python&#x27;</span> <span class="hljs-comment">#写入（若数据量较大可以先将最大下标转换成字符串，批量处理时遍历一样操作）</span><br><span class="hljs-comment">#列数很多时用cell.value</span><br></code></pre></td></tr></table></figure><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">workbook1/<span class="hljs-number">2.</span>save(<span class="hljs-string">&#x27;excel_name.xlsx&#x27;</span>) <span class="hljs-comment">#原表或新表都能保存（导出）</span><br></code></pre></td></tr></table></figure><h2 id="功能概览"><a href="#功能概览" class="headerlink" title="功能概览"></a>功能概览</h2><table><thead><tr><th>库名称</th><th>打开文档</th><th>新建文档</th><th>读取文档</th><th>写入文档</th><th>修改文档</th><th>保存文档</th></tr></thead><tbody><tr><td>xlrd</td><td>√</td><td></td><td>√</td><td></td><td></td><td></td></tr><tr><td>xlwt</td><td>√</td><td>√</td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td>xlutils</td><td></td><td></td><td></td><td>√</td><td>√</td><td>√</td></tr><tr><td>xlwings</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>XlsxWriter</td><td></td><td>√</td><td></td><td>√</td><td></td><td>√</td></tr><tr><td>openpyxl</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>pandas</td><td>√</td><td></td><td>√</td><td>√</td><td></td><td>√</td></tr></tbody></table><h1 id="DataGrip"><a href="#DataGrip" class="headerlink" title="DataGrip"></a>DataGrip</h1><p><strong>更建议直接自身内部操作！</strong></p><h2 id="导入（连接）"><a href="#导入（连接）" class="headerlink" title="导入（连接）"></a>导入（连接）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mysql.connector<br>mydb = mysql.connector.connect(<br>  host=<span class="hljs-string">&quot;localhost&quot;</span>,       <span class="hljs-comment"># 数据库主机地址</span><br>  user=<span class="hljs-string">&quot;yourusername&quot;</span>,    <span class="hljs-comment"># 数据库用户名</span><br>  passwd=<span class="hljs-string">&quot;yourpassword&quot;</span>   <span class="hljs-comment"># 数据库密码</span><br>)<br><span class="hljs-built_in">print</span>(mydb)<br></code></pre></td></tr></table></figure><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>无需导出直接操作了~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 续上</span><br>mycursor = mydb.cursor()<br>mycursor.execute(<span class="hljs-string">&quot;CREATE DATABASE runoob_db&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li><p>多条语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">mycursor.execute(<span class="hljs-string">&quot;SELECT * FROM sites&quot;</span>) <br>myresult = mycursor.fetchall() <span class="hljs-comment"># fetchall() 获取所有记录</span><br></code></pre></td></tr></table></figure></li><li><p>单条语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Python">mycursor.execute(<span class="hljs-string">&quot;SELECT * FROM sites&quot;</span>) <br>myresult = mycursor.fetchone()<br></code></pre></td></tr></table></figure></li></ul><h3 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">mycursor.execute(<span class="hljs-string">&quot;SELECT * FROM sites LIMIT 3 OFFSET 1&quot;</span>) <span class="hljs-comment"># 0 为 第一条，1 为第二条，以此类推</span><br></code></pre></td></tr></table></figure><h3 id="修改（此处仅包括插入）"><a href="#修改（此处仅包括插入）" class="headerlink" title="修改（此处仅包括插入）"></a>修改（此处仅包括插入）</h3><ul><li><p>单条插入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sql = <span class="hljs-string">&quot;INSERT INTO sites (name, url) VALUES (%s, %s)&quot;</span> val = (<span class="hljs-string">&quot;RUNOOB&quot;</span>, <span class="hljs-string">&quot; https://www.runoob.com&quot;</span>) mycursor.execute(sql, val)<br>mydb.commit() <span class="hljs-comment"># 数据表内容有更新，必须使用到该语句</span><br></code></pre></td></tr></table></figure></li><li><p>批量插入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">sql = <span class="hljs-string">&quot;INSERT INTO sites (name, url) VALUES (%s, %s)&quot;</span><br>val = [<br>  (<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;https://www.google.com&#x27;</span>),<br>  (<span class="hljs-string">&#x27;Github&#x27;</span>, <span class="hljs-string">&#x27;https://www.github.com&#x27;</span>),<br>  (<span class="hljs-string">&#x27;Taobao&#x27;</span>, <span class="hljs-string">&#x27;https://www.taobao.com&#x27;</span>),<br>  (<span class="hljs-string">&#x27;stackoverflow&#x27;</span>, <span class="hljs-string">&#x27;https://www.stackoverflow.com/&#x27;</span>)<br>]<br>mycursor.executemany(sql, val)<br>mydb.commit()    <span class="hljs-comment"># 数据表内容有更新，必须使用到该语句</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="SO"><a href="#SO" class="headerlink" title="SO"></a>SO</h1><p>不会用到~</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>2.数据处理&amp;IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器互导</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/%E5%AE%B9%E5%99%A8%E4%BA%92%E5%AF%BC/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/%E5%AE%B9%E5%99%A8%E4%BA%92%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*容器包括：Excel、SPSS&#x2F;Origin（性质相同，后简称SO）、DataGrip</p><p>*方法：</p><ul><li><p>Excel、SO直接复制黏贴~</p></li><li><p>Excel&amp;DataGrip：</p></li></ul><blockquote><p>→：方法同Navicat中导入sql文件</p></blockquote><blockquote><p>←：Navicat可导出xlsx文件</p></blockquote><ul><li>SO&amp;DataGrip：不方便直接导，通过Excel间接完成~</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>2.数据处理&amp;IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据处理</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*数据源统一转成以Excel为基础，必要时用SPSS辅助</p><p>*以下所有步骤均已确定会用Excel和SPSS联合处理</p><h1 id="数据清洗（纠正错误）"><a href="#数据清洗（纠正错误）" class="headerlink" title="数据清洗（纠正错误）"></a>数据清洗（纠正错误）</h1><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>缺失率较高直接删除，否则填充根据分布情况和统计学模型估计出的最可能的值&#x2F;平均值&#x2F;插值算法</p><h2 id="重复值处理"><a href="#重复值处理" class="headerlink" title="重复值处理"></a>重复值处理</h2><p>删去~</p><h2 id="异常值（离群点）处理"><a href="#异常值（离群点）处理" class="headerlink" title="异常值（离群点）处理"></a>异常值（离群点）处理</h2><ol><li>判断是否为真异常：</li></ol><p>*一般用3σ法则、箱线图（四分位数）即可~&#x3D;</p><p>*其他具体方法：</p><ul><li><p>基于绝对离差中位数(MAD)：采用计算各观测值与平均值的距离总和的方法。</p></li><li><p>基于距离：通过定义对象之间的临近性度量，根据距离判断异常对象是否远离其他对象。</p></li><li><p>基于密度：离群点的局部密度显著低于大部分近邻点，适用于非均匀的数据集</p></li><li><p>基于聚类：利用聚类算法，丢弃远离其他簇的小簇。</p></li></ul><ol start="2"><li>处理（若为真异常值）：</li></ol><p>若样本较多可直接删除，也可以视为缺失值处理&#x2F;前后的平均值&#x2F;盖帽法（整行替换数据框里99%以上和1%以下的点，将99%以上的点值&#x3D;99%的点值；小于1%的点值&#x3D;1%的点值）</p><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8EIO/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/1688920498482.jpg" alt="1688920498482"></p><h1 id="数据预处理（更优化）"><a href="#数据预处理（更优化）" class="headerlink" title="数据预处理（更优化）"></a>数据预处理（更优化）</h1><h2 id="更改数据类型"><a href="#更改数据类型" class="headerlink" title="更改数据类型"></a>更改数据类型</h2><p>根据情况转换~</p><h2 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h2><ol><li>统一化（自创名词~）</li></ol><p>*无量纲化：用Xi&#x2F;Max-Xi&#x2F;Xi-Min&#x2F;Xi-μ去<strong>除以</strong>统计量（Max&#x2F;Min&#x2F;Max-Min&#x2F;μ&#x2F;标准差）</p><p>*中心化：Xi-μ</p><p>*归一化：Min-Max法（有一定的变式）、Z-score（又称标准化，即转化为标准正态分布）</p><ol start="2"><li>离散化</li></ol><p>根据四分位（即处在第几分位）、区间宽度、频率、K-means模型聚出的类、与某个值的大小关系（二值&#x2F;01化）等等~</p><ol start="3"><li>稀疏化</li></ol><p>暂无~</p><h2 id="数据重塑（改变数据结构、改变行列分布、对原数据进行变形）"><a href="#数据重塑（改变数据结构、改变行列分布、对原数据进行变形）" class="headerlink" title="数据重塑（改变数据结构、改变行列分布、对原数据进行变形）"></a>数据重塑（改变数据结构、改变行列分布、对原数据进行变形）</h2><p>（DataFrame里面重塑时行索引永远还是行索引）</p><h3 id="stack-列“旋转”成行"><a href="#stack-列“旋转”成行" class="headerlink" title="stack():列“旋转”成行"></a>stack():列“旋转”成行</h3><table><thead><tr><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><td>a</td><td>A0</td><td>B0</td></tr><tr><td>b</td><td>A1</td><td>B1</td></tr></tbody></table><p>​↓</p><table><thead><tr><th>a</th><th>A</th><th>A0</th></tr></thead><tbody><tr><td></td><td>B</td><td>B0</td></tr><tr><td>b</td><td>A</td><td>A1</td></tr><tr><td></td><td>B</td><td>B1</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">stack(self, level=-<span class="hljs-number">1</span>, dropna=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>level：表示操作内层索引。若设为0，表示操作外层索引，默认为-1</p><p>dropna：表示是否将旋转后的缺失值删除，若设为True，则表示自动过滤缺失值，设置False则相反</p><h3 id="unstack-行“旋转”成列（即上面的逆操作）"><a href="#unstack-行“旋转”成列（即上面的逆操作）" class="headerlink" title="unstack():行“旋转”成列（即上面的逆操作）"></a>unstack():行“旋转”成列（即上面的逆操作）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">unstack(self, level=-<span class="hljs-number">1</span>, fill_value=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>level：表示操作内层索引。若设为0，表示操作外层索引，默认为-1</p><p>fill_value：若产生了缺失值，则可以设置这个参数用来替换NaN</p><h3 id="pivot-轴向旋转，会根据给定的行索引或列索引重新组织一个DataFrame对象"><a href="#pivot-轴向旋转，会根据给定的行索引或列索引重新组织一个DataFrame对象" class="headerlink" title="pivot():轴向旋转，会根据给定的行索引或列索引重新组织一个DataFrame对象"></a>pivot():轴向旋转，会根据给定的行索引或列索引重新组织一个DataFrame对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pivot(self, index=<span class="hljs-literal">None</span>, columns=<span class="hljs-literal">None</span>, values=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>index：用于创建新DataFrame对象的行索引 。如果未设置，则使用原DataFrame对象的索引。</p><p>columns：用于创建新DataFrame对象的列索引 。如果未设置，则使用原DataFrame对象的索引。</p><p>values：用于填充新DataFrame对象中的值。</p><h2 id="数据降噪-x2F-平滑化"><a href="#数据降噪-x2F-平滑化" class="headerlink" title="数据降噪&#x2F;平滑化"></a>数据降噪&#x2F;平滑化</h2><p>对数据进行分箱操作，等频或等宽分箱，然后用每个箱的平均数，中位数或者边界值(不同数据分布，处理方法不同)代替箱中所有的数，起到平滑数据的作用。</p><h2 id="数据归约（在保持完整性的基础上减小内存等）"><a href="#数据归约（在保持完整性的基础上减小内存等）" class="headerlink" title="数据归约（在保持完整性的基础上减小内存等）"></a>数据归约（在保持完整性的基础上减小内存等）</h2><ol><li>维度&#x2F;属性&#x2F;特征归约（即数据降维，针对属性）</li></ol><p>PCA、小波变换（WT）、傅里叶变换（FFT）、特征集选择（FSS）</p><ol start="2"><li>数据采样（针对记录&#x2F;样本）</li></ol><p>减少取样的样本</p><ol start="3"><li>特征值归约</li></ol><ul><li>参数方法：用替代的、较小的数据表示替换或估计数据，如参数模型（只需要存放校型参数，而不是实际数据）</li><li>非参数方法，如聚类、选样和使用直方图</li></ul><h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>PCA、独立成分分析（ICA）、线性判别分析（LDA）</p><ul><li><p>PCA:SPSSPro&#x2F;SPSSAU;LDA:SPSSAU</p></li><li><p>ICA:一般处理信号时用它提取信号的主要有效成分</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>2.数据处理&amp;IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作原理与流程</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*数据流的三个路径：</p><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E6%B5%81%E7%A8%8B/1688920126087.jpg" alt="1688920126087"></p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>1.数据爬取</category>
      
      <category>网站系统爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*都在Pycharm底部的终端栏或者cmd中运行</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table><thead><tr><th align="center">命令</th><th align="center">说明</th><th align="center">格式</th></tr></thead><tbody><tr><td align="center">startproject</td><td align="center">创建一个新工程</td><td align="center">scrapy startproject 〈name〉 [dir]</td></tr><tr><td align="center">genspider</td><td align="center">创建一个爬虫</td><td align="center">scrapy genspider [options] 〈name&gt; 〈domain&gt;</td></tr><tr><td align="center">settings</td><td align="center">获得爬中配置信息</td><td align="center">scrapy settings [options]</td></tr><tr><td align="center">crawl</td><td align="center">运行一个爬虫</td><td align="center">scrapy crawl 〈spider〉</td></tr><tr><td align="center">list</td><td align="center">列出工程中所有爬虫</td><td align="center">scrapy list</td></tr><tr><td align="center">shell</td><td align="center">启动URL调试命令行</td><td align="center">scrapy shell [url]</td></tr></tbody></table><h1 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h1><ol><li>建立一个Scrapy爬虫工程</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">scrapy startproject project_name<br></code></pre></td></tr></table></figure><p>生成的工程目录介绍：</p><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E5%91%BD%E4%BB%A4/1688919772550.jpg" alt="1688919772550"></p><ol start="2"><li>在工程中产生一个Scrapy爬虫</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">scrapy genspider spider_name(比如demo) project_name <span class="hljs-comment">#确保此时路径位置在项目目录层</span><br></code></pre></td></tr></table></figure><p>作用：</p><ul><li><p>生成一个名称为demo的spider</p></li><li><p>在spiders目录下增加代码文件demo.py：</p></li></ul><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E5%91%BD%E4%BB%A4/1688919847921.jpg" alt="1688919847921"></p><ol start="3"><li>配置产生的spider爬虫（此处即为demo）</li></ol><p>配置两部分：</p><ul><li><p>初始URL地址</p></li><li><p>获取页面后的解析方式</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoSpider</span>(scrapy.Spider):<br>name = <span class="hljs-string">&quot;demo&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span> requests(self):<br>urls = [<br><span class="hljs-string">&#x27;http://python123.io/ws/demo.html&#x27;</span><br>]<br><span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br><span class="hljs-keyword">yield</span> scrapy.Request(url=url, callback=self.parse)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>fname = response .url.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fname , <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(response.body)<br>self.log(<span class="hljs-string">&#x27;Saved file s.&#x27;</span> %fname)<br></code></pre></td></tr></table></figure><ol start="4"><li>运行爬虫，获取网页</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">scrapy crawl demo <span class="hljs-comment">#demo爬虫被执行，捕获页面存储在demo.htm</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>1.数据爬取</category>
      
      <category>网站系统爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总体架构</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>网站级别（较大）的爬虫框架，命令行操作，爬取大量网页</p><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E7%88%AC%E8%99%AB/%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/1688919542092.jpg" alt="1688919542092"></p><h1 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h1><p>Engine：</p><ul><li><p>控制所有模块之间的数据流，不断获得爬取请求直到请求为空</p></li><li><p>根据条件触发事件</p></li></ul><p>Downloader：根据请求下载网页</p><p>Scheduler：对所有爬取请求进行调度管理</p><p>Spider：</p><ul><li><p>解析Downloader返回的响应（Response）</p></li><li><p>产生爬取项（scraped item）</p></li><li><p>产生额外的爬取请求（Request）</p></li></ul><p>Item Pipelines：</p><ul><li><p>以流水线方式处理Spider产生的爬取项</p></li><li><p>由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型</p></li><li><p>可能操作包括：清理、检验和查重爬取项中的HTML数据、将数据存储到数据</p></li></ul><p>Downloader Middleware：</p><ul><li><p>目的：实施Engine、Scheduler和Downloader 之间进行用户可配置的控制</p></li><li><p>功能：修改、丢弃、新增请求或响应</p></li></ul><p>Spider Middleware</p><ul><li><p>目的：对请求和爬取项的再处理</p></li><li><p>功能：修改、丢弃、新增请求或爬取项</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>1.数据爬取</category>
      
      <category>网站系统爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="常用操作符"><a href="#常用操作符" class="headerlink" title="常用操作符"></a>常用操作符</h2><table><thead><tr><th align="center">操作符</th><th align="center">说明</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">表示任何单个字符</td><td align="center"></td></tr><tr><td align="center">[]</td><td align="center">字符集，对单个字符给出取值范围</td><td align="center">[abc]表示a，b、c，[a-z]表示a到z单个字符</td></tr><tr><td align="center">[\wedge]</td><td align="center">非字符集，对单个字符给出排除范围</td><td align="center">[^abc]表示非a或b或c的单个字符</td></tr><tr><td align="center">*</td><td align="center">前一个字符0次或无限次扩展</td><td align="center">abc*表示ab、abc、abcc、abccc等</td></tr><tr><td align="center">+</td><td align="center">前一个字符1次或无限次扩展</td><td align="center">abc+表示abc、abcc、abccc等</td></tr><tr><td align="center">?</td><td align="center">前一个字符0次或1次扩展</td><td align="center">abc?表示ab、abc</td></tr><tr><td align="center">।</td><td align="center">左右表达式任意一个</td><td align="center">abc|def表示abc、def</td></tr></tbody></table><table><thead><tr><th align="center">操作符</th><th align="center">说明</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">{m}</td><td align="center">扩展前一个字符m次</td><td align="center">ab{2}c表示abbc</td></tr><tr><td align="center">{m,n}</td><td align="center">扩展前一个字符m至n次(含n)</td><td align="center">ab{1,2}c表示abc、abbc</td></tr><tr><td align="center">^</td><td align="center">匹配字符串开头</td><td align="center">^abc表示abc且在一个字符串的开头</td></tr><tr><td align="center">\</td><td align="center">匹配字符串结尾</td><td align="center">abc$表示abc且在一个字符串的结尾</td></tr><tr><td align="center">()</td><td align="center">分组标记，内部只能使用|操作符</td><td align="center">(abc)表示abc，(abc|def)表示abc、def</td></tr><tr><td align="center">ld</td><td align="center">数字，等价于[0-9]</td><td align="center"></td></tr><tr><td align="center">Iw</td><td align="center">单词字符，等价于[A-Za-zo-9_]</td><td align="center"></td></tr></tbody></table><h2 id="最小匹配操作符"><a href="#最小匹配操作符" class="headerlink" title="最小匹配操作符"></a>最小匹配操作符</h2><table><thead><tr><th align="left">操作符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*?</td><td align="left">前一个字符0次或无限次扩展，最小匹配</td></tr><tr><td align="left">+?</td><td align="left">前一个字符1次或无限次扩展，最小匹配</td></tr><tr><td align="left">??</td><td align="left">前一个字符0次或1次扩展，最小匹配</td></tr><tr><td align="left">{m,n}?</td><td align="left">扩展前一个字符m至n次(含n),最小匹配</td></tr></tbody></table><h2 id="表示类型"><a href="#表示类型" class="headerlink" title="表示类型"></a>表示类型</h2><ul><li>rawstring（常用）</li></ul><p>r’…’</p><ul><li>string（少用）</li></ul><p>‘…\…\…’</p><h1 id="正则（Re库）"><a href="#正则（Re库）" class="headerlink" title="正则（Re库）"></a>正则（Re库）</h1><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">re.search()</td><td align="left">在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</td></tr><tr><td align="left">re.match()</td><td align="left">从一个字符串的开始位置起匹配正则表达式，返回match对象</td></tr><tr><td align="left">re.findall()</td><td align="left">搜索字符串，以列表类型返回全部能匹配的子串</td></tr><tr><td align="left">re.split()</td><td align="left">将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td></tr><tr><td align="left">re.finditer()</td><td align="left">搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</td></tr><tr><td align="left">re.sub()</td><td align="left">在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td></tr></tbody></table><p>等价用法（用于重复操作）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">regex=re.<span class="hljs-built_in">compile</span>(pattern,flags=<span class="hljs-number">0</span>)<span class="hljs-comment">#将正则表达式的字符串形式编译成正则表达式对象</span><br>rst=regex.search(string)<span class="hljs-comment">#替换rst=re.search(pattern,string,flags=0)(其他函数同）</span><br></code></pre></td></tr></table></figure><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><ul><li><p>search</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">re.search(pattern,string,flags=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#在一个字符串中搜索匹配正则表达式的第一个位置返回match对象</span><br></code></pre></td></tr></table></figure><p>∙pattern:正则表达式的字符串或原生字符串表示</p><p>∙string:待匹配字符串</p><p>∙flags:正则表达式使用时的控制标记</p><p>注意：match对象不是最后匹配的结果，而是整个函数（包括其中的各个参数、最终的匹配结果）的所有信息都包含！</p></li><li><p>match</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.<span class="hljs-keyword">match</span>(pattern,string,flags=<span class="hljs-number">0</span>)<span class="hljs-comment">#从一个字符串的开始位置起匹配正则表达式返回match对象(和search区别在于match必须从头开始匹配否则为None！)</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>findall</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(pattern,string,flags=<span class="hljs-number">0</span>)<span class="hljs-comment">#搜索字符串，以列表类型返回全部能匹配的子串</span><br></code></pre></td></tr></table></figure></li><li><p>split</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.split(pattern,string,maxsplit=<span class="hljs-number">0</span>,flags=<span class="hljs-number">0</span>)<span class="hljs-comment">#将一个字符串按照正则表达式匹配结果进行分割返回列表类型</span><br></code></pre></td></tr></table></figure><p>参数同上（maxsplit字面意思）</p></li><li><p>finditer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.finditer(pattern,string,flags=<span class="hljs-number">0</span>)<span class="hljs-comment">#搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</span><br></code></pre></td></tr></table></figure></li><li><p>sub</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.sub(pattern,repl,string,count=<span class="hljs-number">0</span>,flags=<span class="hljs-number">0</span>)<span class="hljs-comment">#在一个字符串中替换所有匹配正则表达式的子串返回替换后的字符串</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.string</td><td align="left">待匹配的文本</td></tr><tr><td align="left">.re</td><td align="left">匹配时使用的patter对象(正则表达式)</td></tr><tr><td align="left">.pos</td><td align="left">正则表达式搜索文本的开始位置</td></tr><tr><td align="left">.endpos</td><td align="left">正则表达式搜索文本的结束位置</td></tr></tbody></table><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.\operatorname{group}(\theta)</td><td align="left">获得匹配后的字符串</td></tr><tr><td align="left">.\operatorname{start}()</td><td align="left">匹配字符串在原始字符串的开始位置</td></tr><tr><td align="left">.end()</td><td align="left">匹配字符串在原始字符串的结束位置</td></tr><tr><td align="left">.\operatorname{span}()</td><td align="left">返回(.\operatorname{start}(),.end())</td></tr></tbody></table><p>亦可用[m]:n表示</p><p>即原函数中的string</p><p>即原函数中的pattern</p><p>位置指的是下标</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>1.数据爬取</category>
      
      <category>页面爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息组织与提取方法</title>
    <link href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E4%BF%A1%E6%81%AF%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95/"/>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E4%BF%A1%E6%81%AF%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="信息标记的种类"><a href="#信息标记的种类" class="headerlink" title="信息标记的种类"></a>信息标记的种类</h1><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>即HTML5那种~</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>*有类型的键值对:”key_name”:[“value_name1”,”value_name2”,…]</p><p>*一个键值对可以作为另一个大键值对的值（即嵌套）</p><h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p>*无类型键值对，缩进表达所属关系:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name:<br>newName: 北京理工大学<br>oldName: 延安自然科学院<br></code></pre></td></tr></table></figure><p>*表达并列关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name:<br>-newName: 北京理工大学<br>-oldName: 延安自然科学院<br></code></pre></td></tr></table></figure><p>*表达整块数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">text: | <span class="hljs-comment">#学校介绍</span><br><span class="hljs-meta">... </span><span class="hljs-comment">#具体介绍</span><br></code></pre></td></tr></table></figure><h1 id="信息标记形式的比较"><a href="#信息标记形式的比较" class="headerlink" title="信息标记形式的比较"></a>信息标记形式的比较</h1><ul><li><p>XML：最早的通用信息标记语言，可扩展性好，但繁琐；Internet上的信息交互与传递</p></li><li><p>JSON：信息有类型，适合程序处理(js)，较XML简洁；移动应用云端和节点的信息通信，无注释</p></li><li><p>YAML：信息无类型，文本信息比例最高，可读性好；各类系统的配置文件，有注释易读</p></li></ul><h1 id="内容查找"><a href="#内容查找" class="headerlink" title="内容查找"></a>内容查找</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>*相比于bs4库的标签树遍历这种完整解析信息的标记形式再提取关键信息的方法的另一种方法——无视标记形式，直接搜索关键信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs) <span class="hljs-comment">#返回一个列表类型，存储查找结果</span><br></code></pre></td></tr></table></figure><ul><li><p>name:对<strong>标签名称</strong>的检索字符串</p></li><li><p>attrs:对标签属性值的检索字符串，可标注属性检索（人话就是含有此字符串的标签内容？）</p></li><li><p>recursive:是否对子孙全部检索，默认True</p></li><li><p>string:&lt;&gt;…&lt;&#x2F;&gt;中字符串取与的检索字符串</p></li></ul><p>另：</p><ul><li><p><tag>(..) 等价于<tag>.find all(..)</tag></tag></p></li><li><p>soup(..)等价于soup.find al1(..)</p></li></ul><h2 id="遍历-方法应用"><a href="#遍历-方法应用" class="headerlink" title="遍历+方法应用"></a>遍历+方法应用</h2><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">〈〉.find ()</td><td align="center">揷萦且只返回一个结果，同.find_all()参数</td></tr><tr><td align="center">〈〉.find_parents()</td><td align="center">在先辈节点中搜素，返回列表类型，同.find_all()参数</td></tr><tr><td align="center">〈〉.find_parent()</td><td align="center">在先辈节点中返回一个结果, 同. find ()䢟</td></tr><tr><td align="center">〈〉.find_next_siblings()</td><td align="center">在后续平行节点中搜素，返回列表类型，同，find_all()参数</td></tr><tr><td align="center">〈〉.find_next_sibling ()</td><td align="center">在后续平行节点中返回一个结果, 同. find()玜数</td></tr><tr><td align="center">〈〉.find_previous_siblings()</td><td align="center">在前序平行节点中搜索，返回列表类型，同.find_all()参数</td></tr><tr><td align="center">〈〉.find_previous_sibling()</td><td align="center">在前序平行节点中返回一个结果, 同. find ()参数</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>1.数据爬取</category>
      
      <category>页面爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Beautiful-Soup</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/Beautiful-Soup/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/Beautiful-Soup/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>Beautiful Soup库是解析、遍历、维护“标签树”的功能库：</p><p>HTML←→标签树←→Beautiful Soup</p><h1 id="函数（UTF-8）"><a href="#函数（UTF-8）" class="headerlink" title="函数（UTF-8）"></a>函数（UTF-8）</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;p&gt;data&lt;/p&gt;&#x27;</span>，<span class="hljs-string">&#x27;html.parser&#x27;</span>) <span class="hljs-comment">#data为requests.get()的对象</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">解析器</th><th align="left">使用方法</th><th align="left">条件</th></tr></thead><tbody><tr><td align="left">bs4的HTML解析器</td><td align="left">BeautifulSoup(mk, ‘html.parser’)</td><td align="left">安装bs4库</td></tr><tr><td align="left">lxml的HTML解析器</td><td align="left">BeautifulSoup(mk, ‘lxml’)</td><td align="left">pip install lxml</td></tr><tr><td align="left">lxml的XML解析器</td><td align="left">BeautifulSoup(mk, ‘xml’)</td><td align="left">pip install lxml</td></tr><tr><td align="left">html5lib的解析器</td><td align="left">BeautifulSoup(mk, ‘html5lib’)</td><td align="left">pip install html5lib</td></tr></tbody></table><p>soup（BeautifulSoup类）的基本元素</p><table><thead><tr><th align="center">基本元系</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Tag</td><td align="center">标签，最基本的信息组织单元，分别用 $&lt;&gt;$ 和 $&lt;&#x2F;&gt;$ 标明开头和结尾</td></tr><tr><td align="center">Name</td><td align="center">标签的名字， $\langle p\rangle \ldots\langle&#x2F; p\rangle$ 的名字是 ‘ $p^{\prime}$ ，格式 : 〈tag $\rangle$. name</td></tr><tr><td align="center">Attributes</td><td align="center">标签的属性，字典形式组织，格式 : 〈tag〉.attrs</td></tr><tr><td align="center">NavigableString</td><td align="center">标签内非属性字符串，〈〉..&lt;&#x2F; $&gt;$ 中字符串，格式 : 〈tag〉.string</td></tr><tr><td align="center">Comment</td><td align="center">标签内字符串的注释部分，一种特殊的Comment类型</td></tr></tbody></table><p>*任何存在于HTML语法中的标签都可以用soup.<tag>访问获得</tag></p><p>*当HTML文档中存在多个相同对应内容时，soup.返回第一个</p><h1 id="标签树"><a href="#标签树" class="headerlink" title="标签树"></a>标签树</h1><p>全程都是BeautifulSoup类不变</p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/Beautiful-Soup/1688918183321.jpg" alt="1688918183321"></p><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="下行遍历"><a href="#下行遍历" class="headerlink" title="下行遍历"></a>下行遍历</h3><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">. contents</td><td align="left">子节点的列表，将<tag>所有儿子节点存入列表</tag></td></tr><tr><td align="left">.children</td><td align="left">子节点的迭代类型，与.contents类似，用于循环遍历儿子节点</td></tr><tr><td align="left">.descendants</td><td align="left">子孙节点的迭代类型，包含所有子孙节点，用于循环遍历</td></tr></tbody></table><h3 id="上行遍历"><a href="#上行遍历" class="headerlink" title="上行遍历"></a>上行遍历</h3><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.parent</td><td align="left">节点的父亲标签</td></tr><tr><td align="left">. parents</td><td align="left">节点先辈标签的迭代类型，用于循环遍历先辈节点</td></tr></tbody></table><h3 id="平行遍历"><a href="#平行遍历" class="headerlink" title="平行遍历"></a>平行遍历</h3><p>必须在<strong>同一个父节点</strong>下！</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">. next_sibling</td><td align="left">返回按照HTML文本顺序的下一个平行节点标签</td></tr><tr><td align="left">.previous_sibling</td><td align="left">返回按照HTML文本顺序的上一个平行节点标签</td></tr><tr><td align="left">.next_siblings</td><td align="left">迭代类型，返回按照HTML文本顺序的后续所有平行节点标签</td></tr><tr><td align="left">.previous_siblings</td><td align="left">迭代类型，返回按照HTML文本顺序的前续所有平行节点标签</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>1.数据爬取</category>
      
      <category>页面爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requests</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/requests/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/requests/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="通用代码框架"><a href="#通用代码框架" class="headerlink" title="通用代码框架"></a>通用代码框架</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getHTMLText</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-keyword">try</span>:<br>        r=requests.get(url,timeout=<span class="hljs-number">30</span>)<br>        r.raise_for_status() <span class="hljs-comment">#如果状态不是200，引发HTTPError异常</span><br>        r.encoding=r.apparent_encoding<br>        <span class="hljs-keyword">return</span>  r.text<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;产生异常&quot;</span><br>    <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;main&quot;</span>:<br>    url=<span class="hljs-string">&quot;http://www.——.com&quot;</span><br>    <span class="hljs-built_in">print</span>(getHTMLText(url))<br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><p>7个主要方法：</p><table><thead><tr><th align="center">requests.request ()</th><th align="center">构造一个请求，支撑以下各方法的基础方法</th></tr></thead><tbody><tr><td align="center">requests.get ()</td><td align="center">获取HTML网页的主要方法，对应于HTTP的GET</td></tr><tr><td align="center">requests.head()</td><td align="center">获取HTML网页头信息的方法，对应于HTTP的HEAD</td></tr><tr><td align="center">requests.post ()</td><td align="center">向HTML网页提交POST请求的方法，对应于HTTP的POST</td></tr><tr><td align="center">requests.put ()</td><td align="center">向HTML网页提交PUT请求的方法，对应于HTTP的PUT</td></tr><tr><td align="center">requests.patch()</td><td align="center">向HTML网页提交局部修改请求，对应于HTTP的PATCH</td></tr><tr><td align="center">requests.delete ()</td><td align="center">向HTML页面提交删除请求，对应于HTTP的DELETE</td></tr></tbody></table><table><thead><tr><th align="center">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">GET</td><td align="left">请求获取URL位置的资源</td></tr><tr><td align="center">HEAD</td><td align="left">请求获取URL位置资源的响应消息报告，即获得该资源的头部信息</td></tr><tr><td align="center">POST</td><td align="left">请求向URL位置的资源后附加新的数据</td></tr><tr><td align="center">PUT</td><td align="left">请求向URL位置存储一个资源，覆盖原URL位置的资源</td></tr><tr><td align="center">PATCH</td><td align="left">请求局部更新URL位置的资源，即改变该处资源的部分内容</td></tr><tr><td align="center">DELETE</td><td align="left">请求删除URL位置存储的资源</td></tr></tbody></table><p>PATCH和PUT的区别：</p><p>假设URL位置有一组数据UserInfo，包括UserID、UserName等20个字段,</p><p>需求：用户修改了UserName，其他不变.</p><p>• 采用PATCH，仅向URL提交UserName的局部更新请求</p><p>• 采用PUT，必须将所有20个字段一并提交到URL，未提交字段被删除</p><p>PATCH的最主要好处：节省网络带宽</p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><h3 id="request"><a href="#request" class="headerlink" title="request()"></a>request()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">requests.request(method, url, **kwargs)<br>r = requests.request(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27; http://python123.io/ws&#x27;</span>, params=kv) <span class="hljs-comment">#示例</span><br></code></pre></td></tr></table></figure><p>method : 请求方式，对应get&#x2F;put&#x2F;post等7种</p><p>**kwargs: 12个控制访问的参数,均为可选项</p><p>params : 字典或字节序列，作为参数增加到url中</p><p>data : 字典、字节序列或文件对象，作为Request的内容</p><p>json : JSON格式的数据，作为Request的内容</p><p>headers : 字典，HTTP定制头</p><p>cookies : 字典或CookieJar，Request中的cookie</p><p>auth : 元组，支持HTTP认证功能</p><p>files : 字典类型，传输文件</p><p>timeout : 设定超时时间，秒为单位</p><p>proxies : 字典类型，设定访问代理服务器，可以增加登录认证</p><p>cert : 本地SSL证书路径</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">r=requests.get(url, params=<span class="hljs-literal">None</span>, **kwargs) <span class="hljs-comment">#构造一个向服务器请求资源的Request对象，返回一个包含服务器资源的Response对象</span><br></code></pre></td></tr></table></figure><ul><li><p>params : url中的额外参数，字典或字节流格式，可选（如href，则对应选取出超链接的网址内容）</p></li><li><p>response对象的属性</p></li></ul><table><thead><tr><th align="center">r.status_code</th><th align="center">HTTP请求的返回状态，200表示连接成功，404表示失败</th></tr></thead><tbody><tr><td align="center">r.text</td><td align="center">HTTP响应内容的字符串形式，即，url对应的页面内容</td></tr><tr><td align="center">r.encoding</td><td align="center">从HTTP header中猜测的响应内容编码方式</td></tr><tr><td align="center">r.apparent_encoding</td><td align="center">从内容中分析出的响应内容编码方式 ( 备选编码方式 )</td></tr><tr><td align="center">r.content</td><td align="center">HTTP响应内容的二进制形式</td></tr></tbody></table><p>*若为404则没有后三项</p><p>*kwargs参数同上~</p><p>*可能出现的异常情况:</p><table><thead><tr><th align="center">requests.ConnectionError</th><th align="center">网络连接错误异常，如DNS查询失败、拒绝连接等</th></tr></thead><tbody><tr><td align="center">requests.HTTPError</td><td align="center">HTTP错误异常</td></tr><tr><td align="center">requests.URLRequired</td><td align="center">URL缺失异常</td></tr><tr><td align="center">requests.TooManyRedirects</td><td align="center">超过最大重定向次数，产生重定向异常</td></tr><tr><td align="center">requests.ConnectTimeout</td><td align="center">连接远程服务器超时异常</td></tr><tr><td align="center">requests.Timeout</td><td align="center">请求URL超时，产生超时异常</td></tr></tbody></table><table><thead><tr><th align="left">r.raise_for_status()</th><th align="left">如果不是200，产生异常 requests.HTTPError</th></tr></thead></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">requests.get(url, params=<span class="hljs-literal">None</span>, **kwargs)<br>requests.head(url, **kwargs)<br>requests.post(url, data=<span class="hljs-literal">None</span>, json=<span class="hljs-literal">None</span>, **kwargs)<br>requests.put(url, data=<span class="hljs-literal">None</span>, **kwargs)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>1.数据爬取</category>
      
      <category>页面爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总体架构</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/1688913989806.jpg" alt="1688913989806"></p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>1.数据爬取</category>
      
      <category>页面爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BDA题库</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E4%B8%9A%E5%8A%A1/BDA%E9%A2%98%E5%BA%93/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E4%B8%9A%E5%8A%A1/BDA%E9%A2%98%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*下单转化率是指(确认订单客户数&#x2F;该商品的总访问数)×100%1</p><p>*客户浏览网站页面的次数是指PV</p><p>*SKU是最细的（区别SPU）</p><p>*用户满意度不属于AARRR模型</p><p>*RFM中M是指最近3次消费总金额</p><p>*周全不属于smart原则</p><p>*通过对国内各城市人均GDP与商品住宅成交均价的分析来了解两者直接的联系，适合用相关分析</p><p>*ARPU、ARPPU指的是平均用户收入  平均每用户付费收入</p><p>*流量价值更高：看转化率</p><p>*高质量流量是指页面停留时间超过6分钟</p><p>*性价比较高，低毛利，需求量大的单品，根据产品分级，这样的单品称为引流款</p><table><thead><tr><th>*GMV的定义：网站成交金额</th></tr></thead><tbody><tr><td>*一个新的产品在推广中最关注的的推广数据指标是注册率</td></tr><tr><td>*百度推广属于SEM渠道</td></tr></tbody></table><p>*cpc：…click</p><p>*一款移动端应用（免费），主打短视频拍摄、娱乐和分享：UGC</p><p>*拼团红包：引流</p><p>*0元下单开团 分享好友 好友以拼团价购买 是为了复购</p><p>*每千克200000元的定成每克200元：分割定价法</p><p>*采用会员制为基本销售和服务方式的零售店：仓储式商店</p><p>*CTR：点击量&#x2F;展现量</p><p>*现金周转期&#x3D;应收账款周转期+平均存货期限-应付账款的平均付款天数</p><p>*销售导向型广告投放任务最需要关注，最能衡量投放的效果的指标：ROI</p><p>*产品热度、受欢迎程度：产品交易指数</p><p>*下载量能一定程度反映产品的市场契合度，但下载量越高并不说明产品越受欢迎</p><p>*直接发广告不属于病毒式营销的要素</p><p>*CRM研究的是信赖类型的忠诚</p><p>*为企业带来效率提升属于企业级TOB产品的最核心价值</p><p>*移动互联网目前处于生命周期的成熟期</p><p>**当消费某种商品的边际效用为零时，则这时消费者该商品所得到的总效用达到最大</p><p>*基础特征标签属于交叉标签</p><p>*网络推广的访问者访问5个页面以上才是有效流量</p><p>*在产品成熟期通过市场调研找到用户痛点是不正确的</p><p>*最常用的微信公众号第三方内容编辑排版工具有秀米、135编辑器</p><p>*常用的第三方数据统计平台有友盟  百度统计 talkingdata</p><p>*MECE原则包括相互独立  完全穷尽</p><p>*经纬度  年龄  性别不属于用户标识</p><p>*影响PV的因素包括编辑手段  偶然因素  访问周期</p><p>*银行在对客户的汇款频次进行分析时,该变量的异常值可能属于：除了重复值都选</p><p>*以下属于指数工具的有：除了云词都选</p><p>*消费者旅程包括：都选</p><p>*地推活动会使用的地推渠道有商圈  社区  高校</p><p>*提升小程序流量留存和二次唤醒：除了降低价格都选</p><p>*B2C电子商务网站的收益模式包括：除了收取信息流量费都选</p><p>*To B产品定价时的影响因素：友商定价  产品成本  产品利润率</p><p>*应用市场上常见的免费推广方式有首发  换量  专题</p><p>*对于soul，探探等交友类产品，以下哪些数据是核心数据：打开频率 消息发送量；平价每个用户的好友数量</p><p>*某电商公司的渠道运营人员，平时工作中最关注的指标有roi  新增用户数</p><p>*用户画像：除了姓名都选</p><p>*叮咚  盒马不属于社区团购</p><p>*DAU &lt; MAU但二者不以一月的天数为倍数关系</p><p>*要目的为了提升用户留存率：除了邀请好友送优惠券都选</p><p>*在分析购物车页面的漏斗数据时，不需要考虑用户登录&#x2F;注册页面</p><p>*可以用来衡量产品用户粘性的指标：用户在线时长  核心行为频次 用户次日留存率</p><p>*属于百度指数功能模块的有：注意定位不是</p><p>*做拉新相关的需求分析时，应该考虑：注意购买率不是</p><p>*AB测试：注意全流量不是</p><p>*漏斗分析法一般用于分析用户增长率 用户转化率</p><p>*下列关于产品成熟期的说法正确的是：需要提高效率，减少成本，选择关键行为或时间长度、需要洞察市场痛点不是</p><p>*关于互联网企业以下描述中，正确的有：亚马逊、微信</p><p>*在广告中根据不同目标市场的特点，采取相应的宣传手段和方法，用了无差异性 差异化  集中性营销策略</p><p>*知乎内容冷启动方法：邀请网红大v~</p><p>*用户画像研究：5w2h</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-2.业务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>业务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>业务知识</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E4%B8%9A%E5%8A%A1/%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E4%B8%9A%E5%8A%A1/%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RFM分析：用来对用户进行价值分类，从重要价值用户到一般挽留用户，识别有价值的用户，进</p><p>行精细化运营，不断将用户转化为重要价值用户</p><ul><li><p>R（价值）：离年底的时间（流失时间）</p></li><li><p>F（频次）：下单次数</p></li><li><p>RFM分析三大流程</p></li></ul><ol><li>选取正确的指标</li><li>选取合适的评分方式</li><li>选取适当的分组数量</li></ol><p>*AARRR模型：用来分析用户行为，为产品运营制定决策，实现用户增长。</p><p>*PEST分析方法：指宏观环境的分析，P是政治(politics)，E是经济(economy)，S是社会(society)，T</p><p>是技术(technology)</p><p>*根据分类标准打分（实际写if函数的时候区间都是左闭右开，还可以用lookup函数）：</p><p>*国内电商行业业务模式</p><ul><li><p>企业卖家-企业买家(B2B)</p></li><li><p>企业卖家-个人买家(B2C) </p></li><li><p>个人卖家-个人买家(C2C) </p></li><li><p>卖家线上售卖-买家线下门店提货&#x2F;换货(O2O)</p></li></ul><p>*国内电商老用户定义</p><p>法一：累计计算.</p><p>对于新店铺(3年以下)，一般可以采取累计，首次交易就算新用户，再次交易的就算老用户</p><p>法二：某一时期起计算至今</p><p>对于开店较久的店铺(3年以上)，由于持续累计会使老用户数量不断增大，而忽略了用户的流失，不利于长期监控，这时采用滚动周期累计更好。</p><p>*回购率</p><ul><li><p>回购率和复购率最大的区别在于使用场景。复购率是一个衡量较长时间段，或者作为周期性(逐月、逐年)监测用户忠诚度的指标；而回购率是分析短期促销活动(简称大促)对用户吸引力的指标。</p></li><li><p>例：在电商中有很多大促节日，例如618，双11，每次大促持续1~5天，这种情况下使用购率作为指标：</p></li><li><p>回购率&#x3D;回购人数（大促活动期间购买的用户数）&#x2F;基数（某段时间内的购买用户数）</p></li></ul><p>*用户交易指标</p><ul><li><p>访客数UV:商品所在页面的独立访问数</p></li><li><p>GMV：Gross Merchandise Volume，主要是指网站的成交总金额，这里的成交金额包括：付款金额和未付款金额。即：</p></li><li><p>gmv&#x3D;销售额+取消订单金额+拒收订单金额+退货订单金额</p></li><li><p>客单价：即人均消费</p></li><li><p>折扣率：GMV&#x2F;吊牌总额，吊牌总额&#x3D;吊牌价×销量</p></li><li><p>售卖比&#x2F;售罄率:GMV&#x2F;备货值</p></li></ul><p>*SPU、SKU</p><ul><li><p>SPU：款号，例如iPhone8</p></li><li><p>SKU：某SPU的具体货号，具体到颜色、尺寸</p></li><li><p>针对SPU、SKU常用的指标分别是SPU数量、SKU数量和备货值(吊牌价×库存数)。</p></li><li><p>动销率：有销量的SKU数量&#x2F;在售SKU数量。</p></li></ul><p>*ARPU(Average Revenue per User)即人均付费，反应用户的价值，ARPU值越高，平台的业发展前景越好。</p><p>*ARPPU(Average Revenue per Paid User)即付费用户的人均付费，反映付费用户的消费能力，ARPPU越高，付费用户的消费意愿越强烈，业务总收入越多。</p><p>*STP营销战略：</p><ul><li><p>STP营销是现代市场营销战略的核心。</p></li><li><p>S、T、P三个字母分别是Segmenting、Targeting、Positioning三个英文单词的缩写，即市场细分、目标市场和市场定位的意思。</p></li></ul><p>*SEM推广：Search Engine Marketing，中文意思是搜索引擎营销，如百度推广</p><p>*SEO推广：是指在搜索引擎自然排名的规则下，对网站（站内和站外）进行优化，提升网站关键词自然排名，获得更多流量，最终达成网站某种转化的目的。简而言之，SEO是指从自然搜索结果获得网站流量。</p><p>*C?C</p><ul><li>CPC&#x3D;Cost Per Click，</li></ul><p>这一种推广是按照点击量来进行收费的，可以是点击链接、图片 等。</p><ul><li>CPM&#x3D;Cost Per Mille，</li></ul><p>是一种按照千次曝光进行计算收费的，假设收费方式为10元&#x2F;CPM，那么每一千个人看见推广广告，你就需要给推广商支付10元。这是目前比较流行的推广方式之一，可以有效增加曝光率。</p><ul><li>CPA&#x3D;Cost Per Action</li></ul><p>通过推广之后的用户行为进行收费，投放广告之后按照订单数量等方式进行统计，此种方法推广风险较高，但是成功之后的效果比CPM更好。</p><ul><li>CPS&#x3D;Cost Per Sales</li></ul><p>是通过实际的销售量进行收费的，更适合购物类APP进行推广，但是需要精确的流量进行数据统计转换，很多软件都通过此类方式成功推广。</p><ul><li>CPT&#x3D;Cost Per Time</li></ul><p>这一类方法主要通过时间进行收费，多数以包月、星期进行计算。</p><p>*RMF模型：衡量客户价值和客户创利能力的重要工具和手段。</p><p>*CRM管理：一般指客户关系管理。主要对客户信赖忠诚进行研究。</p><p>*做活动运营时常用甘特图做活动管理。</p><p>*访问参数</p><ul><li><p>页面访问深度&#x3D;PV&#x2F;UV</p></li><li><p>VV（Visit view）&#x3D;所有访客1天内访问网站的次数</p></li><li><p>点击率CTR</p></li></ul><p>*ROI&#x3D;投资回报率，一般在进行销售导向型运营、渠道运营时需要特别关注。</p><p>*ARPU的全称是Average Revenue Per User，也就是每用户平均收入，是评估应用变现有效性的指标</p><p>*ARPPU&#x3D;收益&#x2F;付费用户ARPPU全称为Average Revenue Per Paying User，也就是每付费用户平均收入。</p><p>*UGC：User-generated Content的缩写，用户生产内容。又作UCC。</p><p>*引流款：需求量大，价格不高，毛利率低，性价比高</p><p>*一些模型</p><ul><li><p>3C战略模型&#x3D;公司自身（Corporation）+公司顾客（Customer）+竞争对手（Competitor）</p></li><li><p>卡诺模型（KANO模型）是对用户需求分类和优先排序的有用工具，以分析用户需求对用户满意的影响为基础，体现了产品性能和用户满意之间的非线性关系。</p></li><li><blockquote><p>其中的期望属性：当提供此需求，用户满意度会提升，当不提供此需求，用户满意度会降低；或者产品这种属性的表现越好，消费者就越满意；反之则越不满意</p></blockquote></li><li><p>SWOT模型在战略分析中，它是最常用的方法之一对内，研究：优势（strength），劣势（weakness）；对外，研究：机会（opportunity），威胁（threat）。</p></li><li><p>MECE原则&#x3D;Mutually Exclusive Collectively Exhaustive，“相互独立，完全穷尽”</p></li></ul><p>*平行竞争者：是提供能满足同一种需求的不同产品的竞争者</p><p>*商业分析方法：</p><p>当实际购买用户数上升+用户购买率上升时可以考虑扩张市场，因为此时市场容量在增加</p><p>*定价方法</p><ul><li><p>随行就市定价法：是指按同行竞争者的产品价格定价的方法。</p></li><li><p>竞争价格定价法：竞争导向定价法是指企业对竞争对手的价格保持密切关注，以对手的价格作为自己产品定价的主要依据。</p></li><li><p>撇脂定价：是指在产品生命周期的最初阶段把产品价格定得很高，以求最大利润，尽快收回投资。比如苹果手机。</p></li><li><p>渗透定价：就是以低价进入市场，把价量之秤的砝码，尽量加到量的极致，获得极高的销售和占有率，又导致成本降低，价格接着降的定价方法。</p></li><li><p>分割定价法：是指推销人员在报价时,用较小的单位商品的价格进行比较,造成买方心理上的价格便宜感,从而促成交易的一种方法。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-2.业务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>业务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/MATLAB/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/MATLAB/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*一个标量也可以和矩阵进行加减运算，这时把标量和矩阵的每一个元素进行加减运算。</p><p>框1：A＝［<del>，</del>，~；…］(一行中的各个元素之间用空格间隔亦可）</p><p>（接下面）</p><p><img src="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/MATLAB/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/1688912588200.jpg" alt="1688912588200"></p><p>*sub2ind函数：将矩阵中指定元素的行、列下标转换成存储的序号 。 调用格式为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; A=[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>;<span class="hljs-number">4</span>:<span class="hljs-number">6</span>]<br>A =<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br>&gt;&gt; D=<span class="hljs-built_in">sub2ind</span>(<span class="hljs-built_in">size</span>(A),[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>])<span class="hljs-comment">%转换矩阵（A）的行、列下标</span><br>D =<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">6</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>*获得子矩阵</p><ul><li><p>A(i,:):第i行的全部元素</p></li><li><p>A(end,k:k+m):最好一行k-k+m列中的所有元素（适合行数未知时）</p></li><li><p>A(:,[2,4])&#x3D;[]:将第二列和第四列清掉（完全不留那种）</p></li></ul><p><em>点运算符： .</em>  .&#x2F;  .\  .^</p><p>*两矩阵进行点运算是指它们的对应元素进行相关运算，要求两矩阵同型。</p><ul><li>例：当x&#x3D;0.1 、 0.4 、 0.7 、 1 时，分别求 y&#x3D;sin x cos x 的值:</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">\&gt;&gt; x=<span class="hljs-number">0.1</span>:<span class="hljs-number">0.3</span>:<span class="hljs-number">1</span>;<br>\&gt;&gt; y=<span class="hljs-built_in">sin</span>(x).*<span class="hljs-built_in">cos</span> (x);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-6.MATLAB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本语法</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/MATLAB/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/MATLAB/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数值数据"><a href="#数值数据" class="headerlink" title="数值数据"></a>数值数据</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A=input(提示信息,选项);<br></code></pre></td></tr></table></figure><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>*取余：rem(N,q)</p><p>*如果是以角度为单位的函数 就 在函数名后面加“ d ”，以示区别。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">\&gt;&gt; <span class="hljs-built_in">sind</span>(<span class="hljs-number">90</span>)<br><span class="hljs-built_in">ans</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>*取整运算</p><ul><li><p>round():四舍五入</p></li><li><p>ceil():向上取整</p></li><li><p>floor():向下取整</p></li><li><p>fix():舍去小数取整</p></li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>*who&#x2F;whos:查看变量名&#x2F;各变量对应的值</p><p>*length()</p><p>*find()函数：</p><p>k&#x3D;find(ch &gt;&#x3D;’ ch &lt;&#x3D;’z’)：返回串ch中满足条件的一串下标</p><p>*rand(1):0-1随机数</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>*disp(输出项);</p><p>*format格式符：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">\&gt;&gt; format/format long<br>\&gt;&gt; <span class="hljs-number">50</span>/<span class="hljs-number">3</span><br><span class="hljs-built_in">ans</span><br><span class="hljs-number">16.6667</span>/<span class="hljs-number">16.666666666666668</span><br></code></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">if</span> …<br>   …;<br><span class="hljs-keyword">elseif</span><br>   …;<br><span class="hljs-keyword">else</span><br>   …;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">switch</span><br>  <span class="hljs-keyword">case</span> …<br>     …;<br>  ……<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> … : … : … <br>    …;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">while</span> …<br>   ……;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>break&#x2F;continue:不用分号！</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>function 输出形参表&#x3D;函数名(输入形参表) 注释说明部分 函数体语句</p><p>当输出形参多于一个时，应该用方括号括起来，构成一个输出矩阵。</p><p>*例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[s,p]</span>=<span class="hljs-title">fcircle</span><span class="hljs-params">(r)</span></span><br> s=<span class="hljs-built_in">pi</span>*r*r;<br> p=<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*r;<br></code></pre></td></tr></table></figure><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>调用格式： [输出实参表]&#x3D;函数名(输入实参表)</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-6.MATLAB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MATLAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件操作</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="读"><a href="#读" class="headerlink" title="读"></a>读</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">readLines<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;…&quot;</span><span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p>*txt文件的读取</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs R">read.table<span class="hljs-punctuation">(</span>file<span class="hljs-punctuation">,</span> header <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> sep <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">quote</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\&quot;&#x27;&quot;</span><span class="hljs-punctuation">,</span><br>           dec <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.&quot;</span><span class="hljs-punctuation">,</span> numerals <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;allow.loss&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;warn.loss&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;no.loss&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>           row.names<span class="hljs-punctuation">,</span> col.names<span class="hljs-punctuation">,</span> as.is <span class="hljs-operator">=</span> <span class="hljs-operator">!</span>stringsAsFactors<span class="hljs-punctuation">,</span><br>           na.strings <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NA&quot;</span><span class="hljs-punctuation">,</span> colClasses <span class="hljs-operator">=</span> <span class="hljs-literal">NA</span><span class="hljs-punctuation">,</span> nrows <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>           skip <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span> check.names <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span> fill <span class="hljs-operator">=</span> <span class="hljs-operator">!</span>blank.lines.skip<span class="hljs-punctuation">,</span><br>           strip.white <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> blank.lines.skip <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span><br>           comment.char <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#&quot;</span><span class="hljs-punctuation">,</span><br>           allowEscapes <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> flush <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span><br>           stringsAsFactors <span class="hljs-operator">=</span> default.stringsAsFactors<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>           fileEncoding <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> encoding <span class="hljs-operator">=</span> <span class="hljs-string">&quot;unknown&quot;</span><span class="hljs-punctuation">,</span> text<span class="hljs-punctuation">,</span> skipNul <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">file</th><th align="center">$\begin{array}{l}\text { 文件名（包在””内, 或使用一个子符型变量）, 可能需要全路径 } \\text { （注意即使是在Windows下, 符号〉也不允许包含在内, 必须用&#x2F;替 } \\text { 换）, 或者一个URL链接（http:&#x2F;&#x2F;…）（用URL对文件远程访问） }\end{array}$</th></tr></thead><tbody><tr><td align="center">header</td><td align="center">$\begin{array}{l}\text { 一个逻辑值(FALSE or TRUE), 用来反映这个文件的第一行是否包含 } \\text { 变量名 }\end{array}$</td></tr><tr><td align="center">sep</td><td align="center">文件中的字段分离符, 例如对用制表符分隔的文件使用 $s e p&#x3D;” \backslash t “$</td></tr><tr><td align="center">quote</td><td align="center">指定用于包国字符型数据的字符</td></tr><tr><td align="center">dec</td><td align="center">用来表示小数点的字符</td></tr><tr><td align="center">row.names</td><td align="center">$\begin{array}{l}\text { 保存着行名的向量,或文件中一个变量的序号或名子, 缺省时行号取 } \\text { 为 } 1,2,3, \ldots \text {. }\end{array}$</td></tr><tr><td align="center">col.names</td><td align="center">指定列名的字符型向量(缺省值是：V1, V2, V3, …)</td></tr><tr><td align="center">as.is</td><td align="center">$\begin{array}{l}\text { 控制是否将字符型变量转化为因子型变量(如果值为FALSE), 或者仍 } \\text { 将其保留为子符型 (TRUE)。as.is可以是逻辑型, 数值型或者子字符 } \\text { 型向量, 用来判断变量是否被保留为字符。 }\end{array}$</td></tr><tr><td align="center">na.strings</td><td align="center">代表缺失数据的值(转化为NA)</td></tr><tr><td align="center">colClasses</td><td align="center">指定各列的数据类型的一个子符型向量</td></tr><tr><td align="center">nrows</td><td align="center">可以读取的最大行数(忽略负值)</td></tr><tr><td align="center">skip</td><td align="center">在读取数据前跳过的行数</td></tr><tr><td align="center">check.names</td><td align="center">如果为TRUE, 则检查变量名是否在R中有效</td></tr><tr><td align="center">fill</td><td align="center">如果为TRUE且非所有的行中变量数目相同, 则用空白填补</td></tr><tr><td align="center">strip.white</td><td align="center">$\begin{array}{l}\text { 在sep已指定的情况下, 如果为TRUE, 则測除子符型变量前后多余的 } \\text { 空格 }\end{array}$</td></tr><tr><td align="center">blank.lines.skip</td><td align="center">如果为TRUE, 忽略空白行</td></tr><tr><td align="center">comment.char</td><td align="center">$\begin{array}{l}\text { 一个子符用来在数据文件中写注释, 以这个子符开头的行将被忽略 } \\text { (要禁用这个参数, 可使用comment.char }&#x3D;” n \text { ) }\end{array}$</td></tr></tbody></table><p>*read.fwf （file, widths,sep&#x3D;”\t”, as.is &#x3D; FALSE, …）相比read.table,其获取的是指定宽度的文件数据</p><p>*read.csv(file, header, sep, dec) 用于读取“comma separated value”文件。它以 DataFrame 的形式导入数据</p><p>file :包含要导入到R 中的数据的文件的路径。</p><p>header:逻辑值。如果为 TRUE，则 read.csv() 假定您的文件具有标题行，因此第 1 行是每列的名称。如果不是这种情况，您可以添加参数 header &#x3D; FALSE。</p><p>sep:字段分隔符</p><p>dec:文件中用于小数点的字符。</p><p>*scan 通常用于在 R 语言中将数据读入向量或列表或文件中</p><p>scan(“data.txt”, what &#x3D; “character”)</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>略~</p><h1 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs R">cat<span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">,</span>file<span class="hljs-operator">=</span><span class="hljs-string">&quot;…&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#覆盖写入操作，会将输出文件的原有数据清除</span><br>cat<span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">,</span>file<span class="hljs-operator">=</span><span class="hljs-string">&quot;…&quot;</span><span class="hljs-punctuation">,</span>append<span class="hljs-operator">=</span>True<span class="hljs-punctuation">)</span> <span class="hljs-comment"># 想&quot;追加写入&quot;，请不要忘记设置 append 参数</span><br>sink<span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">)</span> <span class="hljs-comment">#可以把控制台输出的文字直接输出到文件中去(这个操作也是&quot;覆盖写入&quot;操作，会直接清除原有的文件内容)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-5.R语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>R语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">函数名<span class="hljs-operator">&lt;-</span><span class="hljs-keyword">function</span><span class="hljs-punctuation">(</span>参数<span class="hljs-punctuation">)</span><br><span class="hljs-punctuation">&#123;</span>…<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-5.R语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>R语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流程控制</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-keyword">if</span><span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">)</span><br><span class="hljs-punctuation">&#123;</span>…<span class="hljs-punctuation">&#125;</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">)</span><br><span class="hljs-punctuation">&#123;</span>…<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>*将case和对应的处理结果都放在括号里</p><p>*例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs R">you.like<span class="hljs-operator">&lt;-</span><span class="hljs-string">&quot;runoob&quot;</span><br><span class="hljs-built_in">switch</span><span class="hljs-punctuation">(</span>you.like<span class="hljs-punctuation">,</span> google<span class="hljs-operator">=</span><span class="hljs-string">&quot;www.google.com&quot;</span><span class="hljs-punctuation">,</span> runoob <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;a href=&quot;</span>http<span class="hljs-operator">:</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>www.runoob.com<span class="hljs-string">&quot;&gt;www.runoob.com&lt;/a&gt;&quot;</span><span class="hljs-punctuation">,</span> taobao <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;a href=&quot;</span>http<span class="hljs-operator">:</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>www.taobao.com<span class="hljs-string">&quot;&gt;www.taobao.com&lt;/a&gt;&quot;</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment"># &quot;www.runoob.com&quot;</span><br></code></pre></td></tr></table></figure><p>PS:若case为整数，则可以省略：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs R">x <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">switch</span><span class="hljs-punctuation">(</span><br>   <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-string">&quot;google&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-string">&quot;runoob&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-string">&quot;taobao&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-string">&quot;weibo&quot;</span><br><span class="hljs-punctuation">)</span><br>print<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span><br><span class="hljs-comment"># &quot;taobao&quot;</span><br></code></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>辅助词next：相当于continue</p><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><p>相当于while(true){…}</p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>略~</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>也可以像python一样：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-keyword">for</span><span class="hljs-punctuation">(</span>i <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>…<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-5.R语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>R语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*下标从1开始</p><p>*NA存在但是值缺失（占位符），NULL是不存在</p><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs R">a<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>m<span class="hljs-punctuation">,</span>n<span class="hljs-punctuation">)</span><br>seq<span class="hljs-punctuation">(</span>l<span class="hljs-punctuation">,</span>r<span class="hljs-punctuation">,</span>d<span class="hljs-punctuation">)</span> <span class="hljs-comment">#生成以l为首，r为尾，间隔为d的向量</span><br><span class="hljs-built_in">rep</span><span class="hljs-punctuation">(</span>a<span class="hljs-punctuation">,</span>n<span class="hljs-punctuation">)</span> <span class="hljs-comment">#产生重复出现的数字序列</span><br></code></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">a<span class="hljs-punctuation">[</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-built_in">c</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-comment"># 取出第 1, 3, 5 项</span><br> a<span class="hljs-punctuation">[</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-built_in">c</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-operator">-</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-comment"># 去掉第 1 和第 5 项</span><br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs R">sort<span class="hljs-punctuation">(</span>向量名<span class="hljs-punctuation">)</span><br>rev<span class="hljs-punctuation">(</span>向量名<span class="hljs-punctuation">)</span><br>order<span class="hljs-punctuation">(</span>向量名<span class="hljs-punctuation">)</span> <span class="hljs-comment">#返回的是一个向量排序之后的下标向量</span><br></code></pre></td></tr></table></figure><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">which<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#筛选我们需要的数据的下标</span><br><span class="hljs-comment">#例：</span><br>a <span class="hljs-operator">=</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-built_in">c</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-punctuation">(</span><span class="hljs-number">11</span><span class="hljs-punctuation">,</span> <span class="hljs-number">12</span><span class="hljs-punctuation">,</span> <span class="hljs-number">13</span><span class="hljs-punctuation">)</span><br>b <span class="hljs-operator">=</span> a <span class="hljs-operator">&gt;</span> <span class="hljs-number">12</span><br>which<span class="hljs-punctuation">(</span>b<span class="hljs-punctuation">)</span><br><span class="hljs-comment"># 1 3</span><br></code></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R">vector<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">6</span><span class="hljs-punctuation">)</span><br>matrix<span class="hljs-punctuation">(</span>vector<span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#按列填充</span><br>matrix<span class="hljs-punctuation">(</span>vector<span class="hljs-punctuation">,</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span>，byrow<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#按行填充</span><br>colnames<span class="hljs-punctuation">(</span>m1<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;x&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;y&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;z&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-comment">#设定行列名称</span><br>rownames<span class="hljs-punctuation">(</span>m1<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;a&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;b&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><h3 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h3><p>m[x,y]</p><h3 id="乘除"><a href="#乘除" class="headerlink" title="乘除"></a>乘除</h3><p>*、&#x2F;</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">A<span class="hljs-operator">=</span>matrix<span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">)</span><br>apply<span class="hljs-punctuation">(</span>A<span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">sum</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 第二个参数为 1 按行操作，2则按列操作，用 sum() 函数</span><br></code></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">lst<span class="hljs-operator">&lt;-</span><span class="hljs-built_in">list</span><span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">)</span>  <span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>列表名<span class="hljs-punctuation">)</span><span class="hljs-operator">&lt;-</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">,</span>…<span class="hljs-punctuation">)</span>  <span class="hljs-comment"># 命名 </span><br></code></pre></td></tr></table></figure><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">list_data<span class="hljs-punctuation">[</span>index<span class="hljs-punctuation">]</span> <span class="hljs-operator">&lt;-</span> <span class="hljs-string">&quot;新元素&quot;</span><br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">list_data<span class="hljs-punctuation">[</span>index<span class="hljs-punctuation">]</span> <span class="hljs-operator">&lt;-</span> <span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>略~</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">merged.list <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>list1<span class="hljs-punctuation">,</span>list2<span class="hljs-punctuation">)</span> <span class="hljs-comment">#合并列表</span><br>v1 <span class="hljs-operator">&lt;-</span> unlist<span class="hljs-punctuation">(</span>list1<span class="hljs-punctuation">)</span> <span class="hljs-comment"># 列表转化为向量</span><br></code></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">array<span class="hljs-punctuation">(</span>data <span class="hljs-operator">=</span> <span class="hljs-literal">NA</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">dim</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">length</span><span class="hljs-punctuation">(</span>data<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">dimnames</span> <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><ul><li><p>dim 数组的维度，默认是一维数组。（一般是三个参数——向量长度（默认为列向量）、矩阵的另一个维度（即向量的个数）、矩阵的个数）</p></li><li><p>dimnames 维度的名称，必须是个列表，默认情况下是不设置名称的。</p></li></ul><p>例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R">vector1 <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span><span class="hljs-number">9</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span><br>vector2 <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">10</span><span class="hljs-punctuation">,</span><span class="hljs-number">11</span><span class="hljs-punctuation">,</span><span class="hljs-number">12</span><span class="hljs-punctuation">,</span><span class="hljs-number">13</span><span class="hljs-punctuation">,</span><span class="hljs-number">14</span><span class="hljs-punctuation">,</span><span class="hljs-number">15</span><span class="hljs-punctuation">)</span><br>row.names <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;ROW1&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;ROW2&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;ROW3&quot;</span><span class="hljs-punctuation">)</span><br>result <span class="hljs-operator">&lt;-</span> array<span class="hljs-punctuation">(</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>vector1<span class="hljs-punctuation">,</span>vector2<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><span class="hljs-built_in">dim</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span>，<span class="hljs-built_in">dimnames</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">list</span><span class="hljs-punctuation">(</span>row.names<span class="hljs-punctuation">,</span>column.names<span class="hljs-punctuation">,</span>matrix.names<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h2 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h2><h3 id="访问-2"><a href="#访问-2" class="headerlink" title="访问"></a>访问</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">print<span class="hljs-punctuation">(</span>result<span class="hljs-punctuation">[</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 显示数组第一个矩阵中第一行第二列的元素  </span><br></code></pre></td></tr></table></figure><h1 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h1><h2 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs R">data.frame<span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">,</span> row.names <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> check.rows <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span><br>           check.names <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span> fix.empty.names <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span><br>           stringsAsFactors <span class="hljs-operator">=</span> default.stringsAsFactors<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment"># 例：</span><br>table <span class="hljs-operator">=</span> data.frame<span class="hljs-punctuation">(</span><br>    姓名 <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;张三&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;李四&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>    工号 <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;001&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;002&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>    月薪 <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1000</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2000</span><span class="hljs-punctuation">)</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><ul><li><strong>…</strong>: 列向量，可以是任何类型（字符型、数值型、逻辑型），一般以 tag &#x3D;     value 的形式表示，也可以是 value。</li><li><strong>row.names</strong>: 行名，默认为 NULL，可以设置为单个数字、字符串或字符串和数字的向量。</li><li><strong>check.rows</strong>: 检测行的名称和长度是否一致。</li><li><strong>check.names</strong>: 检测数据框的变量名是否合法。</li><li><strong>fix.empty.names</strong>: 设置未命名的参数是否自动设置名字。</li><li><strong>stringsAsFactors</strong>: 布尔值，字符是否转换为因子，factory-fresh 的默认值是     TRUE，可以通过设置选项（stringsAsFactors&#x3D;FALSE）来修改。</li></ul><h2 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h2><h3 id="访问-3"><a href="#访问-3" class="headerlink" title="访问"></a>访问</h3><ul><li>下标访问</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">result <span class="hljs-operator">&lt;-</span> table<span class="hljs-punctuation">[</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-comment"># 读取第 2 、3 行的第 1 、2 列数据： </span><br></code></pre></td></tr></table></figure><ul><li>列名访问</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">…<span class="hljs-operator">&lt;-</span> data.frame<span class="hljs-punctuation">(</span>表名<span class="hljs-operator">$</span>列名，表名<span class="hljs-operator">$</span>列名…<span class="hljs-punctuation">)</span>   <br></code></pre></td></tr></table></figure><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>将向量组合成数据框 </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">… <span class="hljs-operator">&lt;-</span> cbind<span class="hljs-punctuation">(</span>v1<span class="hljs-punctuation">,</span>v2<span class="hljs-punctuation">,</span>v3<span class="hljs-punctuation">)</span>  <br></code></pre></td></tr></table></figure><p>合并数据框（所有列名需一致）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">result <span class="hljs-operator">&lt;-</span> rbind<span class="hljs-punctuation">(</span>table1<span class="hljs-punctuation">,</span>table2<span class="hljs-punctuation">)</span>  <br></code></pre></td></tr></table></figure><p>*merge函数亦可：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R">merge<span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span> y<span class="hljs-punctuation">,</span> by <span class="hljs-operator">=</span> intersect<span class="hljs-punctuation">(</span><span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>y<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>    by.x <span class="hljs-operator">=</span> by<span class="hljs-punctuation">,</span> by.y <span class="hljs-operator">=</span> by<span class="hljs-punctuation">,</span> <span class="hljs-built_in">all</span> <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> all.x <span class="hljs-operator">=</span> <span class="hljs-built_in">all</span><span class="hljs-punctuation">,</span> all.y <span class="hljs-operator">=</span> <span class="hljs-built_in">all</span><span class="hljs-punctuation">,</span><br>    sort <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span> suffixes <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;.x&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;.y&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> no.dups <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span><br>    incomparables <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">,</span> …<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><ul><li>x, y： 数据框</li><li>by, by.x,     by.y：指定两个数据框中匹配列名称，默认情况下使用两个数据框中相同列名称。</li><li>all：逻辑值; all &#x3D; L 是     all.x &#x3D; L 和 all.y &#x3D; L 的简写，L 可以是 TRUE 或 FALSE。</li><li>all.x：逻辑值，默认为     FALSE。如果为 TRUE, 显示 x 中匹配的行，即便 y 中没有对应匹配的行，y 中没有匹配的行用 NA 来表示。</li><li>all.y：逻辑值，默认为     FALSE。如果为 TRUE, 显示 y 中匹配的行，即便 x 中没有对应匹配的行，x 中没有匹配的行用 NA 来表示。</li><li>sort：逻辑值，是否对列进行排序。</li></ul><p>PS: merge() 函数和 SQL 的 JOIN 功能很相似</p><h3 id="提取概要"><a href="#提取概要" class="headerlink" title="提取概要"></a>提取概要</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">summary<span class="hljs-punctuation">(</span>table<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><p>‘…’&#x2F;“…”</p><h2 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a>操作</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs R">nchar<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;string&quot;</span><span class="hljs-punctuation">,</span> type<span class="hljs-operator">=</span><span class="hljs-string">&quot;char&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 总计字符数量</span><br>substr<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;123456789&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 截取字符串，从 1 到 5（只有两个参数则第二个为尾部）</span><br><span class="hljs-built_in">as.numeric</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;12&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 将字符串转换为数字</span><br><span class="hljs-built_in">as.character</span><span class="hljs-punctuation">(</span><span class="hljs-number">12.34</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 将数字转换为字符串</span><br>strsplit<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;2019;10;1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;;&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 分隔符拆分字符串</span><br>gsub<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;/&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;2019/10/1&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 替换字符串</span><br>paste<span class="hljs-punctuation">(</span>...<span class="hljs-punctuation">,</span> sep <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span><span class="hljs-punctuation">,</span> collapse <span class="hljs-operator">=</span> <span class="hljs-literal">NULL</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment">#sep ： 分隔符，默认为空格</span><br><span class="hljs-comment">#collapse ： 两个或者更多字符串对象根据元素对应关系拼接到一起，在字符串进行连接后，再使用 collapse 指定对连接符进行连接（？）</span><br>toupper<span class="hljs-operator">/</span>tolower<span class="hljs-punctuation">(</span>…<span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-5.R语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>R语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本语法</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/R%E8%AF%AD%E8%A8%80/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>*R语言是S语言的一种实现</p><p>*R包：</p><ul><li>安装：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">install.packages<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;要安装的包名&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><ul><li>使用：</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">library<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;包名&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>*定义——因子的创建</p><p>因子：表示用于分类的类型的数据称为因子（男女等等）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">write.table <span class="hljs-punctuation">(</span>x<span class="hljs-punctuation">,</span> file <span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> sep <span class="hljs-operator">=</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> row.names <span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span> col.names <span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">quote</span> <span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>x：需要导出的数据</p><p>file：导出的文件路径</p><p>sep：分隔符，默认为空格（” “），也就是以空格为分割列</p><p>row.names：是否导出行序号，默认为TRUE，也就是导出行序号</p><p>col.names：是否导出列名，默认为TRUE，也就是导出列名</p><p>quote：字符串是否使用引号表示，默认为TRUE，也就是使用引号表示</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>*变量赋值：&#x3D;、&lt;-、-&gt;</p><p>*数学运算：</p><p>%%整除求余</p><p>%&#x2F;%整除</p><p>log(a,b) b为底数</p><p>head (mtcars) 仅显示数据集mtcars中前7个观测值</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">print<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment"># 格式输出</span><br>format<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 转化为字符串</span><br>format<span class="hljs-punctuation">(</span>num<span class="hljs-punctuation">,</span> digits <span class="hljs-operator">=</span> len<span class="hljs-punctuation">)</span> <span class="hljs-comment"># 显示len位，最后一位四舍五入</span><br>format<span class="hljs-punctuation">(</span>num<span class="hljs-punctuation">,</span> scientific <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 科学计数法</span><br>format<span class="hljs-punctuation">(</span>num<span class="hljs-punctuation">,</span> width <span class="hljs-operator">=</span> len<span class="hljs-punctuation">)</span> <span class="hljs-comment"># 宽度为len，不够的在开头添加空格</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-5.R语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>R语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间处理</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="时间的表示"><a href="#时间的表示" class="headerlink" title="时间的表示"></a>时间的表示</h1><h2 id="正常表示"><a href="#正常表示" class="headerlink" title="正常表示"></a>正常表示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-built_in">print</span>(datetime.now())<br><span class="hljs-comment"># 2021-02-26 08:31:01.552689</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-built_in">print</span>(datetime.now()year)<br><span class="hljs-comment"># 2021</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span>(time.localtime().tm_year)<br><span class="hljs-comment"># 2021</span><br></code></pre></td></tr></table></figure><p>ctime即asctime:</p><p>time.ctime(x):格式为Thu Jan 1 08:00:01 1970，x为与1970年1月1日8点总共的秒数</p><p>localtime：“时间无组”（2020，10，1，9，10，20（即2020-10-01，09：10：20））</p><p>gmtime:返回格林威治的时间元组信息</p><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>*与1970年1月1日0点总共的秒数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span>(time.time())<br></code></pre></td></tr></table></figure><h2 id="星期几"><a href="#星期几" class="headerlink" title="星期几"></a>星期几</h2><h3 id="从0开始表示周一"><a href="#从0开始表示周一" class="headerlink" title="从0开始表示周一"></a>从0开始表示周一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br>today=datetime.now()<br><span class="hljs-built_in">print</span>(today.weekday())<br></code></pre></td></tr></table></figure><h3 id="从1开始表示周一"><a href="#从1开始表示周一" class="headerlink" title="从1开始表示周一"></a>从1开始表示周一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br>today=datetime.now()<br><span class="hljs-built_in">print</span>(today.isoweekday())<br></code></pre></td></tr></table></figure><h3 id="当前年第几周的星期几"><a href="#当前年第几周的星期几" class="headerlink" title="当前年第几周的星期几"></a>当前年第几周的星期几</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br>today=datetime.now()<br><span class="hljs-built_in">print</span>(today.isocalendar())<br></code></pre></td></tr></table></figure><h2 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> calendar<br><span class="hljs-built_in">print</span>(calendar.month(<span class="hljs-number">2021.2</span>))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">(一个日历的样子）</span><br><span class="hljs-string">       February 2021</span><br><span class="hljs-string">         Mo  Tu……</span><br><span class="hljs-string">         1       2  …….</span><br><span class="hljs-string">        ……</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="时间的转换"><a href="#时间的转换" class="headerlink" title="时间的转换"></a>时间的转换</h1><h2 id="时间戳→标准格式时间"><a href="#时间戳→标准格式时间" class="headerlink" title="时间戳→标准格式时间"></a>时间戳→标准格式时间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-built_in">print</span>(datetime.fromtimestamp(time.time()))<br></code></pre></td></tr></table></figure><h2 id="标准格式时间→时间戳"><a href="#标准格式时间→时间戳" class="headerlink" title="标准格式时间→时间戳"></a>标准格式时间→时间戳</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br>parint(datetime(<span class="hljs-number">2020</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)timestamp())<br></code></pre></td></tr></table></figure><h1 id="时间的输出"><a href="#时间的输出" class="headerlink" title="时间的输出"></a>时间的输出</h1><h2 id="中文格式（需增地理区域设置）"><a href="#中文格式（需增地理区域设置）" class="headerlink" title="中文格式（需增地理区域设置）"></a>中文格式（需增地理区域设置）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> locale<br>locale.setlocale(locale.LC.CTYPE,<span class="hljs-string">&#x27;chinese&#x27;</span>)<br>today=datetime.now()<br><span class="hljs-built_in">print</span>(today.strftime(<span class="hljs-string">&#x27;%Y年%m月%d日%H小时%M分钟%s秒&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="特定格式"><a href="#特定格式" class="headerlink" title="特定格式"></a>特定格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br>today=datetime.now()<br><span class="hljs-built_in">print</span>(today.strftime(<span class="hljs-string">&#x27;%Y/%m/%d %H:%M:%S&#x27;</span>,today)<br></code></pre></td></tr></table></figure><h2 id="解析成时间类型"><a href="#解析成时间类型" class="headerlink" title="解析成时间类型"></a>解析成时间类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-built_in">print</span>(datetime.strptime(<span class="hljs-string">&#x27;2021/02/26 09:10:20&#x27;</span>,<span class="hljs-string">&#x27;%Y/%.../%d%H:%M:%S&#x27;</span>))<br><span class="hljs-comment"># 2021-02-26 09:10:20</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E5%BC%82%E5%B8%B8/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="try-exception"><a href="#try-exception" class="headerlink" title="try-exception"></a>try-exception</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">EOF：<br><span class="hljs-keyword">try</span>:<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>...=<span class="hljs-built_in">input</span>()<br><span class="hljs-keyword">except</span> EOFError:<br><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>assert expression[, reason]</p><ul><li><p>当判断表达式expression为真时，什么都不做;如果表达式为假，则抛出异常。</p></li><li><p>assert语句一般用于开发程序时对特定必须满足的条件进行验证，仅当_debug_为True时有效。当Python脚本以-O选项编译为字节码文件时，assert语句将被移除以提高运行速度。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件IO</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E6%96%87%E4%BB%B6IO/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E6%96%87%E4%BB%B6IO/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h2><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">file.closed</td><td align="left">返回true如果文件已被关闭，否则返回false。</td></tr><tr><td align="left">file.mode</td><td align="left">返回被打开文件的访问模式。</td></tr><tr><td align="left">file.name</td><td align="left">返回文件的名称。</td></tr><tr><td align="left">file.softspace</td><td align="left">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td></tr></tbody></table><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, mode, encoding) <span class="hljs-keyword">as</span> file: <br>... <span class="hljs-comment">#with关键字解决程序崩溃导致文件无法正常关闭的问题</span><br>file <span class="hljs-built_in">object</span> = <span class="hljs-built_in">open</span>(file_name, mode, encoding)<br><span class="hljs-comment">#mode中常用有&#x27;r&#x27;,&#x27;w[+]&#x27;,&#x27;a[+]&#x27;(+代表读&amp;写)</span><br><span class="hljs-comment">#读</span><br>string=file.read([count]) <span class="hljs-comment">#count为读取的字节数</span><br>strings=file.readlines()<br><span class="hljs-comment">#写</span><br>file.write(string)<br><span class="hljs-comment">#关闭</span><br>file.close()<br><span class="hljs-comment">#删除</span><br>os.remove(file_name)<br></code></pre></td></tr></table></figure><ul><li><p>Word（.doc、.docx）文件操作：</p><ul><li>.doc文件需先转换成.docx文件：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> win32com.client <span class="hljs-keyword">import</span> Dispatch <span class="hljs-comment">#需先安装pywin32</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">doc2docx</span>(<span class="hljs-params">old_file_path, word</span>):<br>    <span class="hljs-comment"># 打开原始文档</span><br>    doc = word.Documents.Open(old_file_path)<br>    <span class="hljs-comment"># 将文档另存为docx格式</span><br>    new_file_path = os.path.splitext(file_path)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;.docx&quot;</span><br>    doc.SaveAs(new_file_path, <span class="hljs-number">16</span>)<br>    doc.Close()<br>    os.remove(old_file_path)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;old_file_path&#125;</span>已经被成功转换为<span class="hljs-subst">&#123;new_file_path&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">docs2docxs</span>():<br>    <span class="hljs-comment"># 定义文件夹路径和Word应用程序对象</span><br>    folder_path = [r]<span class="hljs-string">&#x27;...&#x27;</span> <span class="hljs-comment">#Windows路径常加r</span><br>    word = Dispatch(<span class="hljs-string">&quot;Word.Application&quot;</span>)<br>    <span class="hljs-comment"># 遍历文件夹中所有的.doc文件，并将其转换为.docx格式</span><br>    <span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(folder_path):<br>        <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>            <span class="hljs-keyword">if</span> file.endswith(<span class="hljs-string">&quot;.doc&quot;</span>):<br>                file_path = os.path.join(root, file)<br>                doc_to_docx(file_path, word)<br>    <span class="hljs-comment"># 关闭Word应用程序</span><br>    word.Quit()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;全部doc文件已经全部转换为docx!&quot;</span>)<br>    <br> docs2docxs()<br></code></pre></td></tr></table></figure></li><li><p>.docx文件操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docx <span class="hljs-keyword">import</span> Document <span class="hljs-comment">#需先安装python-docx</span><br><span class="hljs-comment">#打开</span><br>file = Document(file_path)<br><span class="hljs-comment">#读</span><br>text = [par.text <span class="hljs-keyword">for</span> par <span class="hljs-keyword">in</span> file.paragraphs] <span class="hljs-comment">#获取文件中的所有文本</span><br>string = <span class="hljs-string">&#x27;&#x27;</span>.join(text) <span class="hljs-comment">#将文本连成一个字符串</span><br>string = <span class="hljs-built_in">str</span>(string).replace(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-comment">#写</span><br>doc.add_paragraph(par)<br><span class="hljs-comment">#保存关闭</span><br>doc.save(save_path)<br></code></pre></td></tr></table></figure></li></ul><h1 id="文件夹-x2F-目录"><a href="#文件夹-x2F-目录" class="headerlink" title="文件夹&#x2F;目录"></a>文件夹&#x2F;目录</h1><ul><li>常用方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">os.getcwd() <span class="hljs-comment">#显示当前文件夹的目录</span><br>os.mkdir(dir_name) <span class="hljs-comment">#创建文件夹</span><br>os.chdir(path) <span class="hljs-comment">#切换文件夹路径</span><br>os.rmdir(dir_name) <span class="hljs-comment">#删除文件夹</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/OOP/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/OOP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*类和对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    __init__(self,...):<br>        self.B=...<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self,...</span>):<br>            ...<br><br>a=A() <span class="hljs-comment">#实例</span><br>a.B=...<br>a.func(...)<br></code></pre></td></tr></table></figure><p>*成员类型：</p><ul><li>_…:受保护成员</li></ul><ul><li><p><strong>…</strong>:系统定义的特殊成员</p></li><li><p>_<em>…:私有成员，只有类对象自己能访问，子类对象不能直接访问，但在对象外部可以通过“对象名.<em>类名</em></em>…”这样的特殊方式来访问</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod </span><span class="hljs-comment">#修饰器，声明类方法</span><br><span class="hljs-meta">@staticmethod </span><span class="hljs-comment">#修饰器，声明静态方法（二者内都无self参数）</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E5%87%BD%E6%95%B0/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*有输入值的放无输入值的的前面！</p><p>*关键字参数：demo(a&#x3D;7,b-2,c&#x3D;3),即形参实参顺序可不必一一对应）</p><p>*functools中的recude函数：</p><p>functools.recude(function,lst)将一个接受2个参数的函数从左到右依次作用到应该序列上</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串与正则</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>去掉某类字符：string.strip(char)</p><p>.join</p><p>查询、替换类函数见Re库</p><h1 id="正则-amp-Match类"><a href="#正则-amp-Match类" class="headerlink" title="正则&amp;Match类"></a>正则&amp;Match类</h1><p>见爬虫分区:</p><p><a href="../../../../10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lst.remove(n) <span class="hljs-comment">#删除第一次出现的n</span><br></code></pre></td></tr></table></figure><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a=(<span class="hljs-number">3</span>,) <span class="hljs-comment">#单元素元组定义</span><br></code></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">data.pop(<span class="hljs-string">&#x27;height&#x27;</span>) <span class="hljs-comment">#删除（PS：popitem():删除并返回一个元素）</span><br>data.update(&#123;…&#125;) <span class="hljs-comment">#添加另一个字典的键值对</span><br>x=collections.OrderedDict() <span class="hljs-comment">#import collections</span><br>defaultdict(<span class="hljs-built_in">int</span>/<span class="hljs-built_in">list</span>/<span class="hljs-built_in">set</span>/<span class="hljs-built_in">str</span>) <span class="hljs-comment">#缺省为空的字典（from collections import defultdict!）</span><br></code></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">data.add(<span class="hljs-number">10</span>) <span class="hljs-comment">#增</span><br>data.remove(<span class="hljs-number">8</span>) <span class="hljs-comment">#删</span><br>data.discard(<span class="hljs-number">8</span>) <span class="hljs-comment">#也是删，但相比remove而言删除集合中不存在的元素不会抛出异常</span><br></code></pre></td></tr></table></figure><p>pop:弹出并删除其中一个元素</p><p>clear:清空集合</p><p>del:删除整个集合</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本语法</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/Python/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*第三方库安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pip install name <span class="hljs-literal">-i</span> https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><p>取对数：log(base,num)</p><p>字符→、←整数：odr、chr</p><p>最大公约数：gcd(a,b)</p><p>返回商和余数：divmod(n,i)</p><p>进制转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">format</span>**(**num**,**base**)** <span class="hljs-comment">#base为&#x27;b&#x27;,&#x27;o&#x27;,&#x27;d&#x27;,&#x27;x&#x27;</span><br></code></pre></td></tr></table></figure><p>@：矩阵相乘</p><p>~:位求反</p><h1 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h1><p>*collections.Counter(nums):构造有关nums数组的哈希表（字典），键和值分别是数组中出现的元素（不重复）及其出现的次数</p><p>*按字典的值的大小对键值对进行排序：（注：字典不能用sort排序，只能用sorted！）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">list1= <span class="hljs-built_in">sorted</span>(dict1.items(),key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">intertools.combinations(lst,k) <span class="hljs-comment">#返回lst中选取k个元素的所有组合（二维列表形式，即每个元素都为单个元素）</span><br>functools.recude(function,lst) <span class="hljs-comment">#将一个接受2个参数的函数从左到右依次作用到应该序列上</span><br></code></pre></td></tr></table></figure><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:.nf&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(num)) <span class="hljs-comment">#输出n位小数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:.ne&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(num)) <span class="hljs-comment">#输出n位小数点科学记数法（10为底）</span><br><span class="hljs-built_in">print</span>(“%0nd”%num) <span class="hljs-comment">#用0补齐，位数n位</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-3.Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问网络资源</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*读取网页数据：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> scrab()<br>    <span class="hljs-keyword">Dim</span> oHtml <span class="hljs-keyword">As</span> <span class="hljs-type">Object</span><br>    <span class="hljs-keyword">Set</span> oHtml = VBA.CreateObject(<span class="hljs-string">&quot;WinHttp.WinHttpRequest.5.1&quot;</span>)<br>    <span class="hljs-keyword">Dim</span> sUrl <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    sUrl = <span class="hljs-string">&quot;https://blog.csdn.net/tylm22733367/article/details/52596990&quot;</span><br>    <span class="hljs-keyword">With</span> oHtml<br>        .Open <span class="hljs-string">&quot;GET&quot;</span>, sUrl, <span class="hljs-literal">False</span><br>        .send<br>        Debug.Print .ResponseText<br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br>    <span class="hljs-keyword">Set</span> oHtml = <span class="hljs-literal">Nothing</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br></code></pre></td></tr></table></figure><p>QueryTables.Add (<em>Connection</em>、<em>Destination、</em><em>Sql</em>) </p><p><img src="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/1688905668911.jpg" alt="1688905668911"></p><p>QueryTable.Refresh(BackgroundQuery) 更新SQL语句查询的结果</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-4.VBA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADO对象</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/ADO%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/ADO%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>ADO是基于OLE DB的数据访问技术。它不直接与数据交互，而是把这个任务交给了OLE DB，这么做带来了相当好的可扩展性和适应性。它提供了编程语言和统一数据访问方式；它允许开发人员编写访问数据的代码而不用关心数据库是如何实现的，而只用关心数据库的连接。由于ADO是基于COM实现的，所以基本上任何语言都可以使用这种数据访问技术，VBA也不例外。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>ADO对象库中主要有9个对象，即：Connection、Command、Recordset、Record、Field、Error、Property、Parameter和Stream。呈现的形式基本是5大可以独立创建的基本对象，4大对象集合，如下图所示。</p><p><img src="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/ADO%E5%AF%B9%E8%B1%A1/1688903475632.jpg" alt="1688903475632"></p><p>Connection：代表与数据源的连接与操作环境，基本任何的操作都是针对特定的Connection完成的。</p><p>Command：代表执行的添加、修改，删除、查询数据源的命令。</p><p>Recordset：代表执行查询命令后的结果集。</p><p>Parameter与Parameters：代表基于参数化查询或存储过程的 Command 对象相关联的参数或自变量，Parameters是Command对象的属性。</p><p>Field与Fields：代表使用普通数据类型的数据的列，Fields是Recordset对象的属性。</p><p>Property与Properties： 代表ADO 对象的描述或控制对象的行为，分为内置属性(通过对象直接调用)和动态属性(通过集合使用 MyObject.Properties(0) 或 MyObject.Properties(“Name”) 语法来引用)。</p><p>Record：代表记录集中的一行、或文件系统的一个文件或一个目录。</p><p>Stream：用于读写以及处理二进制数据或文本流。</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="Excel"><a href="#Excel" class="headerlink" title="Excel"></a>Excel</h2><p>*用ADO访问Excel：</p><ol><li>导入ADO</li></ol><p>工具–&gt;应用–&gt;Microsoft ActiveX Data Objects 6.1 （最好选最新版）</p><ol start="2"><li>创建对象</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Dim conn <span class="hljs-keyword">As</span> <span class="hljs-built_in">New</span> ADODB.<span class="hljs-keyword">Connection</span><br></code></pre></td></tr></table></figure><ol start="3"><li>打开数据库连接</li></ol><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vb">conn.open connStr<br></code></pre></td></tr></table></figure><h2 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h2><p>*Access数据导入导出：未查到</p><p>*创建Access数据库：</p><p>CreateDatabase(Name, Locale, Option)</p><p><img src="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/ADO%E5%AF%B9%E8%B1%A1/1688903585448.jpg" alt="1688903585448"></p><p>*用ADO访问Access：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Set</span> Conn = CreateObject(ADODB.Connection)<br>strPath = ThisWorkbook.Path &amp; <span class="hljs-string">&quot;\mydata.accdb&quot;</span><br>Conn.Open <span class="hljs-string">&quot;Provider=Microsoft.ACE.OLEDB.12.0;Data Source=&quot;</span> &amp; strPath<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-4.VBA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件读写&amp;操作</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h1><h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p>Open+Line input：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Private</span> <span class="hljs-keyword">Sub</span> txt_read()<br>       <span class="hljs-keyword">Dim</span> txt <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>        Open <span class="hljs-string">&quot;D:\dzh.txt&quot;</span> <span class="hljs-keyword">For</span> Input <span class="hljs-keyword">As</span> #<span class="hljs-number">1</span> <span class="hljs-comment">&#x27;</span><br>        <span class="hljs-comment">&#x27;打开文件作为数据输入用，文件号为#1</span><br>        <span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span> <span class="hljs-built_in">Not</span> EOF(<span class="hljs-number">1</span>)<br>            Line Input #<span class="hljs-number">1</span>, txt  <br>            <span class="hljs-comment">&#x27;Line Input # 语句一次只从文件中读出一个字符，直到遇到回车符 (Chr(13))</span><br>            <span class="hljs-comment">&#x27;或回车–换行符 (Chr(13) + Chr(10)) 为止。回车–换行符将被跳过，而不会被附加到字符串上</span><br>            MsgBox txt<br>        <span class="hljs-keyword">Loop</span><br>        Close #<span class="hljs-number">1</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br></code></pre></td></tr></table></figure><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vb">Write <span class="hljs-comment">&#x27;文件名，写入的东西</span><br>Print <span class="hljs-comment">&#x27;输出的东西</span><br></code></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>*Dir [ (pathname, [ attributes ] ) ]</p><p>表示与指定模式或文件属性或驱动器的卷标匹配的文件、目录或文件夹的名称</p><p>*attibutes参数设置：</p><table><thead><tr><th align="left">常量</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">vbNormal</td><td align="left">0</td><td align="left">(默认) 指定没有属性的文件。</td></tr><tr><td align="left">vbReadOnly</td><td align="left">1</td><td align="left">指定只读文件以及不带属性的文件。</td></tr><tr><td align="left">vbHidden</td><td align="left">2</td><td align="left">指定隐藏文件以及不带属性的文件。</td></tr><tr><td align="left">vbSystem</td><td align="left">4</td><td align="left">指定系统文件以及不带属性的文件。在 Macintosh 上不可用。</td></tr><tr><td align="left">vbVolume</td><td align="left">8</td><td align="left">指定卷标; 如果指定任何其他属性，则忽略 vbVolume。在 Macintosh 上不可用。</td></tr><tr><td align="left">vbDirectory</td><td align="left">16</td><td align="left">指定目录或文件夹以及不带属性的文件。</td></tr><tr><td align="left">vbAlias</td><td align="left">64</td><td align="left">指定文件名为别名。仅在 Macintosh 上可用。</td></tr></tbody></table><p>*Name … As …</p><p>*FileCopy … 复制时此文件不能打开</p><p>*Kill … 从磁盘中删除文件</p><p>*GerAttr … 获取一个文件、目录或文件夹的属性</p><p>*SetAttr … 设置文件属性</p><p>*FileLen…获取文件长度</p><p>*FileDateTime … 获取一个文件被创建或最后修改后的日期和时间</p><p>*RmDir 路径 用于标识要删除的目录或文件夹</p><p>*CurDir [ (drive) ] 返回表示当前路径的 Variant (String)</p><p>*ChDir path 更改当前目录或文件夹</p><p>*ChDrive</p><p>*MkDir 新建目录或文件夹</p><h1 id="文件系统对象FSO"><a href="#文件系统对象FSO" class="headerlink" title="文件系统对象FSO"></a>文件系统对象FSO</h1><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vb">FSO.BuildPath(Path,Name) <span class="hljs-comment">&#x27;将文件夹路径和文件夹或文件的名称组合在一起，并返回与有效路径分隔符的组合</span><br>FSO.CopyFile/Folder Source/destination /[OverWirte(<span class="hljs-string">&quot;布尔值，选择是否覆盖现有文件&quot;</span>)]<br>FSO.CreateFolder(FolderName) <span class="hljs-comment">&#x27;创建文件夹</span><br>FSO.DeleteFile/Folder filespec,[ force ] <span class="hljs-comment">&#x27;选择是否要删除带有只读属性集的文件[夹]）</span><br>FSO.DriveExists(drivespec),FileExists,FolderExists <span class="hljs-comment">&#x27;驱动器，文件，文件夹是否存在</span><br>FSO.GetFile/Folder(filespec) <span class="hljs-comment">&#x27;返回与指定路径中的文件对应的file 对象</span><br>FSO.MoveFile/Folder Source,destination<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>*TextStream对象：</p><p>是用于访问文本文件的对象，它是FileSystemObject一个独立的附属对象，但在使用TextStream对象时，我们仍要借助FileSystemObject 对象或其附属对象来创建一个 TextStream 对象并访问磁盘文件的内容</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-4.VBA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>窗口、菜单栏及工具栏设置</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E7%AA%97%E5%8F%A3%E3%80%81%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%8F%8A%E5%B7%A5%E5%85%B7%E6%A0%8F%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E7%AA%97%E5%8F%A3%E3%80%81%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%8F%8A%E5%B7%A5%E5%85%B7%E6%A0%8F%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="屏蔽"><a href="#屏蔽" class="headerlink" title="屏蔽"></a>屏蔽</h1><h2 id="屏蔽菜单栏（中的子项）"><a href="#屏蔽菜单栏（中的子项）" class="headerlink" title="屏蔽菜单栏（中的子项）"></a>屏蔽菜单栏（中的子项）</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vb">Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;文件(&amp;F)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽文件菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;编辑(&amp;E)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽编辑菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;视图(&amp;V)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽视图菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;插入(&amp;I)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽插入菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;格式(&amp;O)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽格式菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;工具(&amp;T)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽工具菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;数据(&amp;D)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽数据菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;窗口(&amp;W)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽窗口菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;帮助(&amp;H)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽帮助菜单</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;编辑(&amp;E)&quot;</span>).Controls(<span class="hljs-string">&quot;填充(&amp;I)&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;屏蔽“编辑”菜单中的“填充”项</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;工具(&amp;T)&quot;</span>).Controls(<span class="hljs-string">&quot;选项(&amp;O)...&quot;</span>).Visible = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;去除工具-选项</span><br>Application.CommandBars(<span class="hljs-number">1</span>).Controls(<span class="hljs-string">&quot;工具(&amp;T)&quot;</span>).Controls(<span class="hljs-string">&quot;选项(&amp;O)...&quot;</span>).Enabled = <span class="hljs-literal">False</span> <span class="hljs-comment">&#x27;工具-选项变灰色</span><br></code></pre></td></tr></table></figure><h2 id="屏蔽工具栏、右键菜单"><a href="#屏蔽工具栏、右键菜单" class="headerlink" title="屏蔽工具栏、右键菜单"></a>屏蔽工具栏、右键菜单</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vb">Application.CommandBars(<span class="hljs-string">&quot;Standard&quot;</span>).Visible = <span class="hljs-literal">False</span>              <span class="hljs-comment">&#x27;屏蔽常用工具栏，右键可选</span><br>Application.CommandBars(<span class="hljs-string">&quot;Formatting&quot;</span>).Visible = <span class="hljs-literal">False</span>            <span class="hljs-comment">&#x27;屏蔽格式工具栏，右键可选</span><br>Application.CommandBars(<span class="hljs-string">&quot;Standard&quot;</span>).Enabled = <span class="hljs-literal">False</span>              <span class="hljs-comment">&#x27;去除常用工具栏，右键也删掉</span><br>Application.CommandBars(<span class="hljs-string">&quot;Formatting&quot;</span>).Enabled = <span class="hljs-literal">False</span>            <span class="hljs-comment">&#x27;去除格式工具栏，右键也删掉</span><br>Application.CommandBars(<span class="hljs-string">&quot;Toolbar list&quot;</span>).Enabled = <span class="hljs-literal">False</span>          <span class="hljs-comment">&#x27;屏蔽右键工具栏</span><br><span class="hljs-keyword">With</span> Application<br>        <span class="hljs-comment">&#x27;屏蔽单元格右键菜单中的剪切、复制、粘贴命令</span><br>        .CommandBars(<span class="hljs-string">&quot;Cell&quot;</span>).Controls(<span class="hljs-string">&quot;剪切(&amp;T)&quot;</span>).Enabled = <span class="hljs-literal">False</span><br>        .CommandBars(<span class="hljs-string">&quot;Cell&quot;</span>).Controls(<span class="hljs-string">&quot;复制(&amp;C)&quot;</span>).Enabled = <span class="hljs-literal">False</span><br>        .CommandBars(<span class="hljs-string">&quot;Cell&quot;</span>).Controls(<span class="hljs-string">&quot;粘贴(&amp;P)&quot;</span>).Enabled = <span class="hljs-literal">False</span><br>        <span class="hljs-comment">&#x27;屏蔽列右键菜单中的剪切、复制、粘贴命令</span><br>        .CommandBars(<span class="hljs-string">&quot;Column&quot;</span>).Controls(<span class="hljs-string">&quot;剪切(&amp;T)&quot;</span>).Enabled = <span class="hljs-literal">False</span><br>        .CommandBars(<span class="hljs-string">&quot;Column&quot;</span>).Controls(<span class="hljs-string">&quot;复制(&amp;C)&quot;</span>).Enabled = <span class="hljs-literal">False</span><br>        .CommandBars(<span class="hljs-string">&quot;Column&quot;</span>).Controls(<span class="hljs-string">&quot;粘贴(&amp;P)&quot;</span>).Enabled = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="屏蔽快捷键"><a href="#屏蔽快捷键" class="headerlink" title="屏蔽快捷键"></a>屏蔽快捷键</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">With</span> Application<br>        <span class="hljs-comment">&#x27;屏蔽键盘剪切、复制、粘贴键（^符号代替Ctrl键）</span><br>        .OnKey <span class="hljs-string">&quot;^x&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br>        .OnKey <span class="hljs-string">&quot;^c&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br>        .OnKey <span class="hljs-string">&quot;^v&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h1><h2 id="自定义工具栏"><a href="#自定义工具栏" class="headerlink" title="自定义工具栏"></a>自定义工具栏</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Set</span> MyCommandBar = Application.CommandBars.Add() <span class="hljs-comment">&#x27;创建工具栏(空白)</span><br>    <span class="hljs-keyword">With</span> MyCommandBar<br>        .Visible = <span class="hljs-literal">True</span><br>        .Name = CommandBarName <span class="hljs-comment">&#x27;工具栏的名字</span><br>        .Position = msoBarTop <span class="hljs-comment">&#x27;msoBarMenuBar &#x27;工具栏的Position</span><br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br></code></pre></td></tr></table></figure><h2 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-comment">&#x27;顶层菜单CommandB rPopup,不支持图标(只有最后一级菜单才支持图标)</span><br><span class="hljs-keyword">Set</span> TopMenuItem = MyCommandBar.Controls.Add(Type:=msoControlPopup)<br>    <span class="hljs-keyword">With</span> TopMenuItem<br>        .Caption = TopMenuName <span class="hljs-comment">&#x27;顶层菜单名</span><br>        .TooltipText = <span class="hljs-string">&quot;TopMenuItem TooltipText&quot;</span> <span class="hljs-comment">&#x27;菜单提示文字</span><br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br><span class="hljs-comment">&#x27;二级菜单CommandBarButton,支持图标(只有最后一级菜单才支持图标)</span><br><span class="hljs-keyword">Set</span> SecondMenuItem = FirstMenuItem.Controls.Add(Type:=msoControlButton)<br>    <span class="hljs-keyword">With</span> SecondMenuItem<br>        .Caption = <span class="hljs-string">&quot;SecondMenuItem(&amp;S)&quot;</span> <span class="hljs-comment">&#x27;二级菜单名</span><br>        .TooltipText = <span class="hljs-string">&quot;SecondMenuItem TooltipText&quot;</span> <span class="hljs-comment">&#x27;菜单提示文字</span><br>        .Style = msoButtonIconAndCaption <span class="hljs-comment">&#x27;菜单样式(图标加文字)</span><br>        .FaceId = <span class="hljs-number">263</span> <span class="hljs-comment">&#x27;图标代号</span><br>        .ShortcutText = <span class="hljs-string">&quot;Ctrl+Shift+S&quot;</span><br>        .OnAction = <span class="hljs-string">&quot;Macro&quot;</span> <span class="hljs-comment">&#x27;要执行的子程序</span><br>        .BeginGroup = <span class="hljs-literal">True</span> <span class="hljs-comment">&#x27;添加分割线</span><br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-4.VBA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E5%87%BD%E6%95%B0/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*自定义函数：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Function</span> functioName()<br><span class="hljs-comment">&#x27;自定义函数代码</span><br>functionName= <span class="hljs-string">&quot;自定义函数运算结果&quot;</span>  <span class="hljs-comment">&#x27;相当于return</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span><br></code></pre></td></tr></table></figure><p>*worksheetfunction和application的区别:</p><p>WorksheetFunction是对Application里面部分工作表函数的再封装，本质仍然是一个函数，但是调用的方式有不同之处.</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-4.VBA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流程控制</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">If</span>(…) <span class="hljs-keyword">Then</span>…<br><span class="hljs-keyword">ElseIf</span>(…) <span class="hljs-keyword">Then</span>…<br><span class="hljs-keyword">Else</span> …<br><span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span> <br></code></pre></td></tr></table></figure><h2 id="Select-Case"><a href="#Select-Case" class="headerlink" title="Select Case"></a>Select Case</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Select</span> <span class="hljs-keyword">Case</span> tm<br><span class="hljs-keyword">Case</span> … …<br>…<br><span class="hljs-keyword">Case</span> <span class="hljs-keyword">Else</span> …<br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Select</span><br></code></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul><li><pre><code class="vb">For …=…to…    …Next <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><br><span class="hljs-operator">-</span> <span class="hljs-operator">```</span><span class="hljs-variable">vb</span><br>  <span class="hljs-built_in">For</span> <span class="hljs-variable">Each</span> …<span class="hljs-built_in">In</span>…<br>          …<br>  <span class="hljs-built_in">Next</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h2 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h2><h3 id="先执行再判断（类似于do-while）"><a href="#先执行再判断（类似于do-while）" class="headerlink" title="先执行再判断（类似于do-while）"></a>先执行再判断（类似于do-while）</h3><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Do</span> <span class="hljs-keyword">While</span>/<span class="hljs-keyword">Until</span> 循环条件<br>    …<br><span class="hljs-keyword">Loop</span><br></code></pre></td></tr></table></figure><h3 id="先判断再执行（类似于while）"><a href="#先判断再执行（类似于while）" class="headerlink" title="先判断再执行（类似于while）"></a>先判断再执行（类似于while）</h3><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Do</span> <br>        …<br><span class="hljs-keyword">Loop</span> <span class="hljs-keyword">While</span>/<span class="hljs-keyword">Until</span> 循环条件<br></code></pre></td></tr></table></figure><h3 id="While"><a href="#While" class="headerlink" title="While"></a>While</h3><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">While</span> …<br>        …<br>Wend <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-4.VBA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本操作</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>*窗体：UI；控件：小工具</p><p>*常量和变量的定义：Const&#x2F;Dim .. As 数据类型（常&#x2F;变量）</p><p>*常见数据类型：</p><ul><li><p>Integer 整数</p></li><li><p>String 字符串</p></li></ul><p>*日期型数据类型：January 1, year</p><p>*Applicaton:最高级的对象，相当于Excel程序本身</p><p>*Debug对象的两种方法：Print和Assert（计算 expression，如果 为 False，则计算调试器中的断点）</p><p>*Dim NewArray(10) as Integer：定义11个整型数构成的数组NewArray</p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>*MsgBox：函数显示一个消息框，并等待用户点击一个按钮，然后根据用户点击的按钮执行相关的操作。</p><ul><li><em>prompt</em> - 必需的参数。在对话框中显示为消息的字符串。提示的最大长度大约为1024个字符。     如果消息扩展为多行，则可以使用每行之间的回车符(Chr(13))或换行符(Chr(10))来分隔行。</li><li><em>buttons</em> - 可选参数。一个数字表达式，指定要显示的按钮的类型，要使用的图标样式，默认按钮的标识以及消息框的形式。如果留空，则按钮的默认值为0。</li><li><em>title</em> - 可选参数。     显示在对话框的标题栏中的字符串表达式。 如果标题留空，应用程序名称将被放置在标题栏中。</li><li><em>helpfile</em> - 可选参数。一个字符串表达式，标识用于为对话框提供上下文相关帮助的帮助文件。</li><li>Context - 可选参数。一个数字表达式，用于标识由帮助作者分配给相应帮助主题的帮助上下文编号。 如果提供上下文，则还必须提供helpfile。</li></ul><p>Buttons参数：</p><ul><li><em>0 vbOKOnly</em> - 仅显示<em>“<strong>确定</strong>”</em> 按钮。</li><li><em>1     vbOKCancel</em> - 显示<em>“<strong>确定</strong>”</em> 和<em>“<strong>取消</strong>”</em> 按钮。</li><li><em>2     vbAbortRetryIgnore</em>     - 显示<em>“<strong>中止</strong>”</em>，<em>“<strong>重试</strong>”</em>和<em>“<strong>忽略</strong>”</em> 按钮。</li><li><em>3     vbYesNoCancel</em> - 显示<em>“<strong>是</strong>”</em>，<em>“<strong>否</strong>”</em>和<em>“<strong>取消</strong>”</em> 按钮。</li><li><em>4 vbYesNo</em> - 显示<em>“<strong>是</strong>”</em>和<em>“<strong>否</strong>”</em>按钮。</li></ul><p>MsgBox函数可以返回以下值之一，可用于标识用户在消息框中单击的按钮。</p><ul><li><em>vbOK</em> - <em>确定</em>     按钮被点击。</li><li><em>vbCancel</em> - <em>取消</em>     按钮被点击。</li><li><em>vbAbort</em> - <em>中止</em>     按钮被点击。</li><li><em>vbIgnore</em> - <em>忽略</em>     按钮被点击。</li><li><em>vbYes</em> - <em>是</em>     按钮被点击。</li><li>vbNo - 否 按钮被点击。</li></ul><p>*内置文件对话框：Application.Dialogs(对话框名称（内置的）).Show</p><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><h2 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h2><p>Join(str1,str2)</p><p>str1&amp;str2 同上，为字符串拼接</p><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><p>指信息函数中Is开头的函数</p><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><p>Cdate 强制转换为日期</p><p>CStr</p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="书写"><a href="#书写" class="headerlink" title="书写"></a>书写</h2><p>*行末无分号作结尾</p><p>*注释：单引号开头即可</p><p>*长代码换行：空格+_</p><h2 id="单元格操作"><a href="#单元格操作" class="headerlink" title="单元格操作"></a>单元格操作</h2><p>*Range对象：Range(字符串格式的单元格范围).Value&#x3D;… 给单元格范围赋值</p><p>禁止编辑单元格：Range(“A1”）.Locked&#x3D;True</p><p>删除单元格：Range().Delete[ Shift:&#x3D;xlUp&#x2F;xlToLeft]*删除[后下方单元格上移&#x2F;右方单元格左移]</p><p>清除单元格：Clear全部清除，ClearContents清除内容，ClearFormats清除格式</p><p>*Cells(row,column)索引到单元格</p><h2 id="工作表操作"><a href="#工作表操作" class="headerlink" title="工作表操作"></a>工作表操作</h2><p>*判断工作表是否已存在：If … Is Nothing Then…</p><p>*插入工作表：Sheets.Add(Before, After, Count, Type)</p><ul><li>before或after可分别设置增加的sheet在某个工作表前或表后，一般不用同时指定。如果同时指定则不要造成矛盾。</li><li>count,指增加的工作表个数。</li><li>type指增加的工作表类别。</li></ul><p>*获取工作表名称、为工作表命名：Sheets(index).Name[&#x3D;…]</p><p>*获取工作表数量：Sheets.Count</p><p>*工作表的隐藏：Sheet(index).Visible&#x3D;xlSheetHidden</p><p>*工作表的复制：SheetName.Copy after:&#x3D;Sheet(index) 复制的表在Sheet(index)之后的一张新工作表中出现</p><p>*工作表的移动：Sheet(index).Move before:&#x3D;…</p><p>*工作表的保护：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-comment">&#x27;设定可编辑区域</span><br>ActiveSheet.Protection.AllowEditRanges.Add Title:=<span class="hljs-string">&quot;区域1&quot;</span>, Range:=Range(<span class="hljs-string">&quot;E5:H12&quot;</span>)<br><span class="hljs-comment">&#x27;保护工作表，但允许上面设定的区域可以编辑</span><br>ActiveSheet.Protect DrawingObjects:=<span class="hljs-literal">True</span>, Contents:=<span class="hljs-literal">True</span>, Scenarios:=<span class="hljs-literal">True</span>, Password:=<span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-comment">&#x27;撤销工作表保护</span><br>ActiveSheet.Unprotect<br></code></pre></td></tr></table></figure><p>*工作表的删除：Sheet(idnex).Delete</p><p>*屏蔽删除工作表时弹出的确认对话框：Application.DisplayAlerts &#x3D; False</p><p>*隐藏工作表行列：Sheet(indexsheet).Rows(indexrow).Hidden&#x3D;True</p><h2 id="工作簿操作"><a href="#工作簿操作" class="headerlink" title="工作簿操作"></a>工作簿操作</h2><p>*工作簿的新建：Workbooks.Add</p><p>*工作簿的打开：Workbooks.Open</p><p>*工作簿的保存：Workbooks.Save</p><p>*工作簿的另存：Workbooks.SaveAs</p><p>*判断工作簿是否已经打开：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Option</span> <span class="hljs-keyword">Explicit</span><br><span class="hljs-keyword">Sub</span> WbIsOpen()<br>    <span class="hljs-keyword">Dim</span> Wb <span class="hljs-keyword">As</span> Workbook<br>    <span class="hljs-keyword">Dim</span> WbName <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    WbName = <span class="hljs-string">&quot;abc.xlsx&quot;</span><br>    <span class="hljs-keyword">On</span> <span class="hljs-keyword">Error</span> <span class="hljs-keyword">GoTo</span> line<br>    <span class="hljs-keyword">Set</span> Wb = Application.Workbooks(WbName)<br>    MsgBox <span class="hljs-string">&quot;工作簿&quot;</span> &amp; WbName &amp; <span class="hljs-string">&quot;已经被打开!&quot;</span><br>    <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Sub</span><br><span class="hljs-symbol">line:</span><br>    MsgBox <span class="hljs-string">&quot;工作簿&quot;</span> &amp; WbName &amp; <span class="hljs-string">&quot;没有被打开!&quot;</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br></code></pre></td></tr></table></figure><p>*设置工作簿保护密码：Workbook.Protect Password:&#x3D;”…”</p><p>*工作簿的关闭：Workbook.Close</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>*事件过程概念：在VBA中，当执行“打开工作簿”、“选择工作表”、“改变单元格的内容”等操作时，可以由此为触发条件（事件）自动执行某些过程。把由这些特定的操作触发并且自动被执行的过程，叫做事件过程。</p><p>*变量赋值：[Let] 变量&#x3D;值</p><p>*子程序（相当于void类型的函数）过程：</p><ul><li>不需要有返回一个值，而函数可能会或可能不会有返回一个值。</li><li>子程序可以不用call关键字来调用。</li><li>子程序总是包含在Sub和End     Sub语句中（与Function的区别在于它没有返回值）</li></ul><p>*With语句：语句中无需重复写某一变量，省略</p><p>*例：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">With</span> Sheet2<br>.Range(<span class="hljs-string">&quot;A1&quot;</span>) = <span class="hljs-number">2</span><br>.Range(<span class="hljs-string">&quot;A5&quot;</span>) = <span class="hljs-number">6</span><br>.Range(<span class="hljs-string">&quot;B6&quot;</span>) = <span class="hljs-number">7</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span> <span class="hljs-comment">&#x27;上面每行的Sheet2都省略了</span><br></code></pre></td></tr></table></figure><p>*错误跳转语句On Error Goto +错误处理代码</p><p>*MODE(NA)返回值？</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-4.VBA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Excel函数与操作</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/EXCEL%E5%87%BD%E6%95%B0%E4%B8%8E%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/VBA/EXCEL%E5%87%BD%E6%95%B0%E4%B8%8E%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="软件操作、快捷键"><a href="#软件操作、快捷键" class="headerlink" title="软件操作、快捷键"></a>软件操作、快捷键</h1><p>动态链接：复制表格+选择性黏贴中选中黏贴链接</p><p>F4：重复上一步操作</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="分类、统计函数"><a href="#分类、统计函数" class="headerlink" title="分类、统计函数"></a>分类、统计函数</h2><ul><li><p>求和类</p><p>*Count(… : …)统计数字的个数</p><p>*Counta统计非空单元格个数</p><p>*Countif(条件范围，条件)根据条件统计个数、Countifs(条件范围，条件，条件范围，条件…)多条件统计函数</p><p>*Sumproduct、Sumif(条件范围,条件,[求和数值的范围])</p></li><li><p>其他</p><p>*Averageif(s)</p><p>*Max(ifs)&#x2F;Min(ifs)</p><p>*Large&#x2F;Small(…,N)返回第N个最大&#x2F;小值</p><p>*Trimmean(…,m&#x2F;N)从N个数中按比例（默认1：1）去掉m个最大和最小值后计算平均值</p><p>*Rank(单元格，范围）</p><p>*Mode返回出现最多的数字</p><p>*Quartile(范围，i)上i分位数</p></li></ul><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="查询类"><a href="#查询类" class="headerlink" title="查询类"></a>查询类</h3><p>*LEFT&#x2F;RIGHT(text,len)从text的第一个&#x2F;最后一个字符开始返回len个字符</p><p>*MID(text,start_num,num_chars)</p><ul><li><p>text: 字符串</p></li><li><p>start_num: text中从左数起的位数</p></li><li><p>num_chars: 字符的个数</p></li></ul><p>*Find&#x2F;Search(tm,base)字符串匹配，返回所处的位置，若无查找值则返回error型</p><h3 id="操作类"><a href="#操作类" class="headerlink" title="操作类"></a>操作类</h3><p>Upper&#x2F;Lower&#x2F;Proper（首字母大写）</p><h3 id="连接类"><a href="#连接类" class="headerlink" title="连接类"></a>连接类</h3><p>*Trim移除多余的空格（超过一个变为一个）</p><p>*Concatenate(str1,str2…)将多个字符串连接成一个</p><h3 id="替换类"><a href="#替换类" class="headerlink" title="替换类"></a>替换类</h3><p>REPLACE(old_test,start_num,num_chars,new_test)</p><ul><li><p>old_text: 待替换的字符</p></li><li><p>start_num: old_text中从左数起的位数</p></li><li><p>num_chars: 所需要替换的字符的个数</p></li><li><p>new_text: 待替换进旧字符串的新字符串</p></li></ul><p>SUBSTITUTE(test,old_text,new_text,instance_num)</p><ul><li><p>text: 包含待替换字符串的字符串</p></li><li><p>old_text: 待替换字符串</p></li><li><p>new_text: 新字符串</p></li><li><p>instance_num: 所需要替换的字符串在所有字符串的位置，不填该参数则表示全部替换</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Len计算长度</p><p>Lenb计算字节数（一个汉字两个字节）</p><h2 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h2><h3 id="获取现在时间"><a href="#获取现在时间" class="headerlink" title="获取现在时间"></a>获取现在时间</h3><p>now()、today()返回系统的日期和时间&#x2F;日期</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>timevalue将文本格式的时间转换为序列号</p><p>year&#x2F;month&#x2F;day(date)返回年&#x2F;月&#x2F;日</p><p>date(year,month,day)返回日期</p><p>hour&#x2F;minute&#x2F;second返回小时&#x2F;分钟&#x2F;秒钟数值（0-23或0-59）</p><p>time(hout,minute,second)返回时间</p><h3 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h3><p>weeknum&#x2F;weekday(date,set)返回日期是一年&#x2F;一周的第几周&#x2F;第几天（set常设为2，意为星期一是一周的第一天）</p><p>datedif(date1,date2,type) type为”MD”表示忽略日期的年份和月份，求间隔天数；”YD”表示忽略日期年份，求间隔天数；”YM”表示忽略日期年份，求年间隔月数</p><p>edate(日期，几个月)计算保质期、工龄</p><p>workday(开始日期，工作日数量，[需要减掉的节假日]) 计算n个工作日后的日期（已减去周末）</p><p>networkdays(开始日期，结束日期，[需要减掉的节假日]）计算工作日天数（已减去周末）</p><h2 id="查找-amp-引用"><a href="#查找-amp-引用" class="headerlink" title="查找&amp;引用"></a>查找&amp;引用</h2><p>match(查找值，查找区域或数组，[配备类型]) 返回查找值在查找区域或数组的相对位置</p><p>vlookup(查找值，查找区域（区域中第一列须为查找值所在的列），区域内第几列，[匹配类型])</p><p>lookup(查找值，查找区域，[结果区域]) 从单行&#x2F;列中查找一个值，采用二分查找算法（即要数据先排序）</p><p>index(区域，行号，列号) 返回给定区域中特定行列单位格的交叉值或引用（PS：当不能满足vlookup查找值在查找区域第一列的要求时可考虑match+index！）</p><p>index((区域1，区域2，…)，行号，列号，第几个区域) 返回给定区域中特定行列单位格的交叉值或引用</p><p>indirect(引用区域，[引用格式]) 返回文本字符串所指定的引用（引用区域加””，为直接引用文本；引用区域不加””,为应用那个该文本表示的位置）</p><p>offset(基准位置，几行(正下负上)，几列(正右负左)，[返回几行]，[返回几列]) 将指定的位置作为参照系，偏移特定的行列返回引用</p><p>Row&#x2F;Column返回引用的行标&#x2F;列标（若有多行&#x2F;列则返回第一行&#x2F;列）</p><p>Rows&#x2F;Columns返回引用的行数&#x2F;列数</p><h2 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数"></a>信息函数</h2><h3 id="信息类型"><a href="#信息类型" class="headerlink" title="信息类型"></a>信息类型</h3><p>CELL(info_type，引用区域) 返回某一引用区域的左上角单元格的格式、位置或内容等信息，该函数主要用于保持与其它电子表格程序的兼容性（info_type指定所需要的单元格信息的类型）  </p><p>ERROR.TYPE(error_val) 返回具体的错误类型</p><p>INFO(type_text) 返回有关当前操作环境的的信息（Type_text是一文本，指明所要返回的信息类型）</p><p>Sheet 返回指定工作表的编号</p><p>Sheets 返回引用中的工作表数目</p><p>Type 以整数形式返回值的数据类型，其中1为数值、2为文字、4为逻辑值、16为错误值、64位数组、128位复合数据</p><h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h3><p>Isblank、Iserr（检查是否为#N&#x2F;A之外的错误）、Iserror、Isformula（是否包含公式）、Islogical、Isna（是否为#N&#x2F;A）、Isref（是否为引用值）</p><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>N(…)转换为数值形式（转换不了的变成0）</p><p>Na转换为#N&#x2F;A</p><h2 id="数学和三角函数"><a href="#数学和三角函数" class="headerlink" title="数学和三角函数"></a>数学和三角函数</h2><h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><p>CEILING 将数字舍入为最接近的整数</p><p>FLOOR 沿绝对值减小方向去尾舍入</p><p>ROUNDUP 沿绝对值增大的方向舍入一个数字</p><p>EVEN 返回沿绝对值增大方向，将一个数值取整为最接近的偶数</p><p>INT向下取整</p><p>ROUND 按指定位数四舍五入</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>ACOS 反余弦值</p><p>BASE 将一个数转换为具有给定基数的文本表示</p><p>DEGREES 将弧度转换为度</p><p>LOG(N,base）</p><p>MOD取余</p><p>QUOTIENT返回商的整数部分</p><p>RAND返回[0,1)的随机数</p><p>RANDBETWEEN</p><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><p>VALUE转为数值类型</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-4.VBA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>Excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习十大算法及应用</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">coe=polyfit(X,Y,<span class="hljs-number">2</span>) <span class="hljs-comment">#X,Y为列表，coe为长度为2的系数向量（即分别为k和b）</span><br></code></pre></td></tr></table></figure><h2 id="直接实现"><a href="#直接实现" class="headerlink" title="直接实现"></a>直接实现</h2><p>直接套公式：</p><p>$$<br>k&#x3D;\frac{\sum x y-n \overline{x y}}{\sum x^2-n \bar{x}^2}<br>$$</p><h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>逻辑回归（Logistic regression） 与<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92&spm=1001.2101.3001.7020">线性回归</a>类似，但它是用于输出为二进制的情况（即，当结果只能有两个可能的值）。一般用于需要明确输出的场景，如某些事件的发生（预测是否会发生降雨）。通常，逻辑回归使用某种函数将概率值压缩到某一特定范围。对最终输出的预测是一个非线性的 S 型函数，称为 logistic function, g()。</p><p>这个逻辑函数将中间结果值映射到结果变量 Y，其值范围从 0 到 1。然后，这些值可以解释为 Y 出现的概率。S 型逻辑函数的性质使得逻辑回归更适合用于分类任务</p><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p>*决策树（Decision tree） 是一种特殊的树结构，由一个决策图和可能的结果（例如成本和风险）组成，用来辅助决策。决策树仅有单一输出，通常该算法用于解决回归和分类问题。</p><p>机器学习中，决策树是一个预测模型，树中每个节点表示某个对象，而每个分叉路径则代表某个可能的属性值，而每个叶节点则对应从根节点到该叶节点所经历的路径所表示的对象的值。在每个节点上，我们根据可用的特征询问有关数据的问题。左右分支代表可能的答案。最终节点（即叶节点）对应于一个预测值。每个特征的重要性是通过自顶向下方法确定的。节点越高，其属性就越重要。</p><p>*三种算法：</p><table><thead><tr><th align="center">生成篢法</th><th align="center">划分标准</th></tr></thead><tbody><tr><td align="center">ID3</td><td align="center">信息增益</td></tr><tr><td align="center">C4. 5</td><td align="center">信息增益率</td></tr><tr><td align="center">CART</td><td align="center">基尼指数</td></tr></tbody></table><p><img src="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/1689153897125.jpg" alt="1689153897125"></p><h1 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h1><p><strong>支持向量机（Support <a href="https://so.csdn.net/so/search?q=Vector&spm=1001.2101.3001.7020">Vector</a> Machine，SVM）</strong>是一种用于分类问题的监督算法。SVM模型将实例表示为空间中的点，将使用一条直线（超平面）分隔数据点，且是两类数据间隔（边距：超平面与最近的类点之间的距离）最大。只通过几个支持向量就确定了超平面，说明它不在乎细枝末节，所以不容易过拟合，但不能确保一定不会过拟合。可以处理复杂的非线性问题。</p><h1 id="K邻近算法"><a href="#K邻近算法" class="headerlink" title="K邻近算法"></a>K邻近算法</h1><p>K近邻算法通过在整个训练集中搜索 K个最相似的实例（欧氏距离最近的k个），并为所有这些K个实例分配一个公共输出变量，来对预测对象进行分类。属于有监督学习，是一种基于实例的学习，是局部近似和将所有计算推迟到分类之后的惰性学习。用最近的邻居（k）来预测未知数据点。</p><p>k 值是预测精度的一个关键因素，无论是分类还是回归，衡量邻居的权重都非常有用，较近邻居的权重比较远邻居的权重大。</p><h1 id="K-Means算法"><a href="#K-Means算法" class="headerlink" title="K-Means算法"></a>K-Means算法</h1><p>K-均值是通过对数据集进行分类来聚类的，属于无监督学习，为聚类问题提供了一种解决方案。在数据集没有标注的情况下，便于对数据进行分群。而K-Means中的K即指将数据集分成K个子集合。算法把 n 个点（可以是样本的一次观察或一个实例）划分到 k 个集群（cluster），使得每个点都属于离他最近的均值（即聚类中心，centroid）对应的集群。重复上述过程一直持续到重心不改变。</p><h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>朴素贝叶斯算法是一种有监督的分类算法，可以进行二分类，或者多分类。基于概率论的贝叶斯定理，应用非常广泛，从文本分类、垃圾邮件过滤器、医疗诊断等等。朴素贝叶斯适用于特征之间的相互独立的场景，例如利用花瓣的长度和宽度来预测花的类型。“朴素”的内涵可以理解为特征和特征之间独立性强。</p><h1 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h1><p>随机森林是一个高度灵活的机器学习方法，利用多个决策树对样本进行训练、分类并预测，主要应用于回归和分类场景。在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择（即引入随机特征选择）。</p><p>简单来说，随机森林就是对决策树的集成，但随机森林中决策树的分类特征是在所有特征中随机选择的。</p><p>随机森林中有许多的分类树。我们要将一个输入样本进行分类，我们需要将输入样本输入到每棵树中进行分类，森林中的每棵树都是独立的，学习器根据每棵树的预测结果来得出最终的结果，99.9%不相关的树做出的预测结果涵盖所有的情况，这些预测结果将会彼此抵消。</p><h1 id="降维算法"><a href="#降维算法" class="headerlink" title="降维算法"></a>降维算法</h1><p>通常情况下，在收集数据集时会有很多的特征，这代表着数据是高冗余的表示，但是对于某个工程来说其实可能并不需要那么多的特征。所以就需要给数据进行降维（Dimensionality Reduction）。降维可以简化数据，使数据集更易使用，降低时间开销，而且能减少一部分噪音的影响，使最后的效果变好。</p><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><p>主成分分析将多个有一定相关性的指标进行线性组合，以最少的维度解释原数据中尽可能多的信息为目标进行降维，降维后的各变量间彼此线性无关，最终确定的新变量是原始变量的线性组合，且越往后主成分在方差中的比重也小，综合原信息的能力越弱，与因子分析不同的是，因子分析是利用少数几个公共因子去解释较多个要观测变量中存在的关系，它不是对原始变量的重新组合。</p><h2 id="因子分析"><a href="#因子分析" class="headerlink" title="因子分析"></a>因子分析</h2><ul><li>因子分析(factor analysis)是由英国心理学家Spearman在1904年提出来的，他成功地解决了智力测验得分的统计分析，长期以来，教育心理学家不断丰富、发展了因子分析理论和方法，并应用这一方法在行为科学领域进行了广泛的研究。因子分析可以看成主成分分析的推广，它也是多元统计分析中常用的一种降维方式，因子分析所涉及的计算与主成分分析也很类似，但差别也是很明显的:</li></ul><ol><li><p>主成分分析把方差划分为不同的正交成分，而因子分析则把方差划归为不同的起因因子</p></li><li><p>因子分析中特征值的计算只能从相关系数矩阵出发，且必须将主成分转换成因子。</p></li></ol><ul><li><p>因子分析有确定的模型，观察数据在模型中被分解为公共因子、特殊因子和误差三部分。初学因子分析的最大困难在于理解它的模型，我们先看如下几个例子。</p></li><li><p>因子分析(factor analysis)是一种数据简化的技术。它通过研究众多变量之间的内部依赖关系，探求观测数据中的基本结构，并用少数几个假想变量来表示其基本的数据结构。这几个假想变量能够反映原来众多变量的主要信息。原始的变量是可观测的显在变量，而假想变量是不可观测的潜在变量，称为因子。</p></li><li><p>因子分析与回归分析不同，因子分析中的因子是一个比较抽象的概念，而回归因子有非常明确的实际意义。</p></li><li><p>主成分分析分析与因子分析也有不同，主成分分析仅仅是变量变换，而因子分析需要构造因子模型。</p></li><li><p>主成分分析:原始变量的线性组合表示新的综合变量，即主成分。</p></li><li><p>因子分析:潜在的假想变量和随机影响变量的线性组合表示原始变量</p></li></ul><h2 id="独立成分分析-Independent-Component-Analysis-ICA"><a href="#独立成分分析-Independent-Component-Analysis-ICA" class="headerlink" title="独立成分分析(Independent Component Analysis, ICA)"></a>独立成分分析(Independent Component Analysis, ICA)</h2><p>*是一种利用统计原理进行计算的方法，它是一个线性变换，这个变换把数据或信号分离成统计独立的非高斯的信号源的线性组合</p><p>*是从多元(多维)统计数据中寻找潜在因子或成分的一种方法</p><h1 id="梯度增强算法Gradient-Boost和Adaboost算法"><a href="#梯度增强算法Gradient-Boost和Adaboost算法" class="headerlink" title="梯度增强算法Gradient Boost和Adaboost算法"></a>梯度增强算法Gradient Boost和Adaboost算法</h1><h2 id="梯度增强算法（Gradient-Boosting）"><a href="#梯度增强算法（Gradient-Boosting）" class="headerlink" title="梯度增强算法（Gradient Boosting）"></a>梯度增强算法（Gradient Boosting）</h2><p>*使用多个弱算法来创建更强大的精确算法。它与使用单个估计量不同，而是使用多个估计量创建一个更稳定和更健壮的算法，梯度增强算法的特点是精度较高。</p><ul><li><p>XGBoost -使用线性和树算法</p></li><li><p>LightGBM-只使用基于树的算法</p></li><li><p>GBDT（Gradient Boosting Decision Tree）</p></li></ul><p>集成算法中的一种，它的最基本分类器为CART二分类回归树，集成方式为梯度提升。</p><h2 id="Adaboost算法"><a href="#Adaboost算法" class="headerlink" title="Adaboost算法"></a>Adaboost算法</h2><p>Adaboost是一种用于分类的迭代算法，其核心思想是针对同一个训练集训练不同的分类器（弱分类器），然后把这些弱分类器集合起来，构成一个更强的最终分类器（强分类器）。Adaboost算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次得到的分类器最后融合起来，作为最后的决策分类器。</p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-1.理论基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据挖掘之聚类算法</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%8B%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%8B%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h1><p>*优点: 速度快</p><p>*缺点:</p><ul><li>必须提前知道”k”， 也就是有多少个簇</li><li>容易陷入局部最优</li><li>数据必须符合“数据之间的相似度可以使用欧式距离衡量”，这个是什么意思呢，看下图，这种数据的分布，样本点的距离不能简单地用欧式距离来衡量，否则分类效果会非常差。这里的距离衡量应该是“测地距离”，也就是样本沿着曲面到达另一个样本点的距离。如果在这种数据空间想要使用kmeans，必须先进行空间的转化</li></ul><p>*有一些改进算法，多是针对k-means会受异常点的影响这一点来改进的，比如K-Means++, K-Medians…</p><h1 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h1><p>*基于密度的算法，要求聚类空间的一定区域所包含的对象的数目不小于某一给定阈值</p><p>*核心思想是从某个核心点出发，不断向密度可达的区域扩张，从而得到一个包含核心点和边界点的最大化区域，区域中任意两点密度相连</p><p>*优点：</p><ul><li>不需要指定簇的数目（不需要     k）</li><li>可以发现任意形状的聚类簇</li><li>对噪声不敏感</li></ul><p>*缺点：</p><ul><li>需要设置半径Eps和MinPts,     空间聚类密度不均匀时难以设置参数，所以有一个问题就是，在数据集A上挑好的参数很可能到数据集B上就不能用了</li><li>随着数据量的增大，计算量显著增大，反正大规模数据集用DBSCAN很可能会崩的</li></ul><h1 id="HDBSCAN"><a href="#HDBSCAN" class="headerlink" title="HDBSCAN"></a>HDBSCAN</h1><p>*层次密度聚类</p><p>*这是一个对DBSCAN的改进算法，结合了密度聚类和层次聚类。它的优化点主要如下：</p><ul><li>使用相互可达距离替换欧氏距离，该距离可以使得密度低的点离密度高的区域更远，减少dbscan对Eps阈值的依赖性</li><li>使用最小生成树构建层次聚类模型，引入层次聚类思想</li><li>对最小生成树的最小子树做了限制，减少计算量，同时保证生成的类簇不要过小</li><li>使用“簇稳定性”的度量方式自动划分类簇，不需要自行设定阈值</li></ul><p>（具体解释：<a href="https://zhuanlan.zhihu.com/p/78382376">常用聚类算法综述 - 知乎 (zhihu.com)</a>）</p><p>*优点：</p><ul><li><p>不需要自行设置阈值，只需定义最小簇的数量</p></li><li><p>计算消耗相对小，速度较快（使用最小生成树建图，并使用了簇压缩)</p></li><li><p>参数敏感度较低</p></li></ul><h1 id="Chinese-Whisper"><a href="#Chinese-Whisper" class="headerlink" title="Chinese Whisper"></a>Chinese Whisper</h1><p>*基于Graph的聚类算法</p><p>*优点：不用设定k，只需指定相似度阈值</p><p>*缺点：</p><ul><li><p>对向量的要求度较高，需要向量能够增大类间距离，减小类内距离</p></li><li><p>由于随机初始化，每次聚类的结果有可能不一致</p></li></ul><p>*改进：CW需要自行设置相似度阈值，且该阈值敏感度较高，后续优化方向是自动选择阈值，有兴趣可以参考下面这篇论文：</p><p><a href="https://arxiv.org/abs/1903.11306">Linkage Based Face Clustering via GCN（CVPR2019）</a></p><h1 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h1><p>*它解决的问题是kmeans中无法对非欧式空间的分布进行聚类的问题，主要原理是对聚类数据进行变换，然后进行k-means聚类，之后再还原到原空间</p><p>*它的主要思想是把所有的数据看做空间中的点，这些点之间可以用边连接起来。距离较远的两个点之间的边权重值较低，而距离较近的两个点之间的边权重值较高，通过对所有数据点组成的图进行切图，让切图后不同的子图间边权重和尽可能的低，而子图内的边权重和尽可能的高，从而达到聚类的目的。</p><p>*优点：在算法中使用了降维，对于高维空间效果较好</p><p>*缺点：</p><ul><li><p>如果向量维度过高，而降维的幅度不够，则最后的聚类效果与运行速度均不好</p></li><li><p>需要提前知道k</p></li><li><p>不同的领接矩阵的聚类结果可能不一样</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-1.理论基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据分析</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*算术平均值易受到极端值影响</p><p>*中位数不受极端值的影响</p><p>*四分位差IQR：上四分位数与下四分位数之差</p><p>*上截断点:<br>$$<br>Q_{0.75}+1.5 \times  \mathrm{IQR}<br>$$<br>大于上截断点的数据为特大值</p><p>*离散系数：标准差与均值绝对值之比</p><p>*异众比率：非众数的次数与全部变量值总次数的比率</p><p>*偏度（偏态的量度）</p><ul><li>意义：当统计数据为右偏分布时，Sk&gt; 0，且Sk值越大，右偏程度越高</li></ul><p>$$<br>S_k&#x3D;\frac{\mu_3}{\mu_2^{\frac{3}{2}}}&#x3D;\frac{\mu_3}{\sigma^3}<br>$$</p><ul><li>常用简化计算公式：</li></ul><p>$$<br>\begin{aligned}<br>\operatorname{Skew}(X) &amp; &#x3D;E\left[\left(\frac{X-\mu}{\sigma}\right)^3\right] \<br>&amp; &#x3D;\frac{E X^3-3 \mu E X^2+3 u^2 E X-\mu^3}{\sigma^3} \<br>&amp; &#x3D;\frac{E X^3-3 \mu\left(E X^2-\mu E X\right)-\mu^3}{\sigma^3} \<br>&amp; &#x3D;\frac{E X^3-3 \mu \sigma^2-\mu^3}{\sigma^3}<br>\end{aligned}<br>$$</p><p>*峰度</p><ul><li><p>意义：是描述总体中所有取值分布形态陡缓程度的统计量。这个统计量需要与正态分布相比较，峰度为0表示该总体数据分布与正态分布的陡缓程度相同；峰度大于0表示该总体数据分布与正态分布相比较为陡峭，为尖顶峰；峰度小于0表示该总体数据分布与正态分布相比较为平坦，为平顶峰。</p></li><li><p>计算公式：</p></li></ul><p>$$<br>\text { Kurtosis }&#x3D;\frac{1}{n-1} \sum_{i&#x3D;1}^n\left(x_i-\bar{x}\right)^4 &#x2F; S D^4-3<br>$$</p><p>*相关系数</p><table><thead><tr><th align="center">相关系数评诂</th><th align="center">$0-0.1$</th><th align="center">$0.1-0.3$</th><th align="center">$0.3-0.5$</th><th align="center">$0.5-1$</th></tr></thead><tbody><tr><td align="center">相关理度</td><td align="center">不柏关</td><td align="center">23相芙</td><td align="center">中筹柏芙</td><td align="center">38相关</td></tr></tbody></table><ul><li>总体相关系数：</li></ul><p>$$<br>\rho&#x3D;\frac{\operatorname{cov}(X, Y)}{\sqrt{\operatorname{Var}(X)} \sqrt{\operatorname{Var}(X)}}<br>$$</p><ul><li>样本相关系数：</li></ul><p>$$<br>r_{X \bar{X}}&#x3D;\frac{\sum\left(x_i-\bar{x}\right)\left(y_{\mathrm{f}}-\bar{y}\right)}{\sqrt{\sum\left(x_i-\bar{x}\right)^2 \sum\left(y_i-\bar{y}\right)^2}}<br>$$</p><p>*季节比率：</p><p><img src="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1688891420325.jpg" alt="1688891420325"></p>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-1.理论基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据采集</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="随机抽样"><a href="#随机抽样" class="headerlink" title="随机抽样"></a>随机抽样</h1><p>*系统随机抽样：每隔m个取一个</p><p>*整群抽样&#x3D;集团抽样：取一些集体中的某几个集体</p><p>*二重抽样是指在抽样时按两步进行：第一步，从总体N中抽取一个较大的样本，对其进行调查以</p><p>获得总体的某些辅助信息；第二步，进行第二重抽样，这次抽取的样本量较小，一般是从第一重</p><p>样本中抽取的，第二重抽样的结果是最终样本。</p><h1 id="非随机抽样"><a href="#非随机抽样" class="headerlink" title="非随机抽样"></a>非随机抽样</h1><ul><li>任意抽样&#x2F;便利抽样&#x2F;偶遇抽样:指调查者在抽取样本时依据方便原则，以达到最大限</li></ul><p>度降低调查成本的目的。</p><ul><li>立意抽样、判断抽样：是指在对所研究总体中个体的一般情况已有相当了解的基础上，选</li></ul><p>择出一个或少数几个比较具有代表性的典型个体作为样本，进行更深人细致的调机查，比较适合</p><p>于总体构成差异较大而样本量较小的抽样调查。同时，如果调查者对总体特征非常了解，那么这</p><p>种抽样方法也适用于特殊类型的调查。</p><ul><li>配额抽样&#x2F;定额抽样：是将总体中的个体按照一定的标准划分为若干类型，将样本数额分配到</li></ul><p>各个类型中，再从各个类型中抽取个体，最终得到所需的样本。</p><blockquote><p>例：调研对象为18-24岁的女性，已经确定样本量为100人，现在要根据“经济收入”和“职业”，要求高低收入各占50%，体力职业和脑力职业各占50%。</p></blockquote><ul><li>滚雪球抽样：是指先找到最初的样本单位，然后根据其提供的信息去获得新的样本单位，这种过程不断继续，直到完成规定的样本容量为止。</li></ul><blockquote><p>例：先访问了7名保姆，然后请她们再提供其他保姆名单</p></blockquote><blockquote><p>*多阶段抽样不属于这一类！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-1.理论基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ambari</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/Ambari/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/Ambari/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>针对集群系统的部署、管理以及监控工具</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>1.数据管理&amp;调度</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Azkaban</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/Azkaban/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/Azkaban/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*任务工作流调度框架</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>1.数据管理&amp;调度</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Oozie</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/Oozie/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/Oozie/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*组织各种工作流（包括Pig、Hive等），以规定方式执行工作流（包括定时任务、定数任务、数据促发任务等），托管工作流（包括命令行接口，任务失败时的通知机制，如邮件通知等）</p><p>*为了管理不同类型的作业在Hadoop系统中处理。</p><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>它由两部分组成：</p><ul><li>工作流引擎：一个工作流引擎的职责是存储和运行工作流程，由 Hadoop 作业组成：MapReduce, Pig, Hive.</li><li>协调器引擎：它运行基于预定义的时间表和数据的可用性工作流程作业。</li></ul><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/Oozie/1688866937313.jpg" alt="1688866937313"></p><h1 id="配置-amp-调度"><a href="#配置-amp-调度" class="headerlink" title="配置&amp;调度"></a>配置&amp;调度</h1><p><a href="https://www.cnblogs.com/ronnieyuan/p/11823061.html">Oozie笔记 - wellDoneGaben - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>1.数据管理&amp;调度</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ZooKeeper</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/ZooKeeper/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/ZooKeeper/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。</p><p>*一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>zookeeper中的所有存储的数据是由znode组成的，节点也称为znode，并以key&#x2F;value形式存储数据。</p><h1 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ls2 path <span class="hljs-comment">//查看某个路径下目录列表</span><br>get path[watch] <span class="hljs-comment">//用于获取节点数据和状态信息,watch表示对节点进行事件监听</span><br>stat path [watch] <span class="hljs-comment">//查看节点状态信息（与上句类似）</span><br>create [-s] [-e] path data acl <span class="hljs-comment">//创建节点并赋值（path必须是全路径！）</span><br>        <span class="hljs-comment">//[-s] [-e]：-s 和 -e 都是可选的，-s 代表顺序节点，-e代表临时节点，注意其中-s和-e可以同时使用，并且临时节点不能再创建子节点。</span><br>        <span class="hljs-comment">//data：要在此节点存储的数据。</span><br>        <span class="hljs-comment">//acl：访问权限相关，默认是 world，相当于全世界都能访问。</span><br>set path data [version] <span class="hljs-comment">//修改（version：版本号）</span><br>delete path [version] <span class="hljs-comment">//删除（只能一层一层删除，新版本可以通过deleteall递归删除~）</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>1.数据管理&amp;调度</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/07/09/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*数据分类：</p><ul><li><p>（按计量尺度）分类数据、顺序数据（反映优劣或顺序）、数值数据</p></li><li><p>观测数据（没有人为）、实验数据</p></li><li><p>截面数据（某一时间关于不同对象的数据）、时间序列数据、面板数据&#x2F;平行数据（时空）</p></li><li><p>结构化数据（一般表现为具有二维表结构的数据集）、半结构化数据、非结构化数据</p></li><li><p>定类数据、定序数据（数据的中间级，用数字表示个体在某个有序状态中所处的位置，如给优良中差评等级分）、定距数据（只能加减不能乘除）、定比数据（能乘除）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析&amp;挖掘</category>
      
      <category>0-1.理论基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YARN</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/YARN/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/YARN/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*分布式资源管理框架（Yet Another Resource Negotiato）</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">yarn init <span class="hljs-comment">//初始化一个新项目</span><br><span class="hljs-comment">//添加依赖包</span><br>yarn add [package]<br>yarn add [package]@[version]<br>yarn add [package]@[tag]<br>yarn [install] <span class="hljs-comment">//安装项目的全部依赖</span><br><span class="hljs-comment">//将依赖项分别添加到 devDependencies、peerDependencies 和 optionalDependencies 这三个依赖项类别中</span><br>yarn add [package] --dev<br>yarn add [package] --peer<br>yarn add [package] --optional<br><span class="hljs-comment">//升级依赖包</span><br>yarn upgrade [package]<br>yarn upgrade [package]@[version]<br>yarn upgrade [package]@[tag]<br><span class="hljs-comment">//移除依赖包</span><br>yarn remove [package]<br><span class="hljs-comment">//更新Yarn本体</span><br>yarn set version latest<br>yarn set version <span class="hljs-keyword">from</span> sources<br></code></pre></td></tr></table></figure><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p><a href="https://blog.csdn.net/u010730126/article/details/107857940">https://blog.csdn.net/u010730126/article/details/107857940</a></p><p>PS：需在具体的项目中升级此YARN依赖！</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>1.数据管理&amp;调度</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataX</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/DataX/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/DataX/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>*异构数据源离线同步工具</p><p>*设计理念：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/DataX/1688866473434.jpg" alt="1688866473434"></p><h1 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/DataX/1688866498219.jpg" alt="1688866498219"></p><h1 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/DataX/1688866526499.jpg" alt="1688866526499"></p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>2.数据采集、传输与同步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sqoop</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Sqoop/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Sqoop/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>是关系数据库服务器和Hadoop之间传送数据的一种工具。</p><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Sqoop/1688866080911.jpg" alt="1688866080911"></p><h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>*功能：创建并保存导入和导出命令。它指定参数来识别并调用已保存的工作。这种重新调用或重新执行用在增量导入，可以从RDBMS表到HDFS导入更新的行。</p><p>*命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建作业（--create）</span><br>sqoop [-]job (generic-args) (job-args) [-- [subtool-name] (subtool-args)]<br><span class="hljs-comment">//创建一个名为myjob，这可以从RDBMS表的数据导入到HDFS作业</span><br>sqoop job --create myjob \ --<span class="hljs-keyword">import</span> \ --connect jdbc:mysql:<span class="hljs-comment">//localhost/db \ --username root \ --table employee --m 1</span><br><span class="hljs-comment">//验证作业（--list）</span><br>sqoop job --list<br><span class="hljs-comment">//检查作业（--show）</span><br>sqoop job --show myjob<br><span class="hljs-comment">//执行作业 (--exec)</span><br>sqoop job --exec myjob<br></code></pre></td></tr></table></figure><h2 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将数据导入HDFS</span><br>sqoop [-]<span class="hljs-keyword">import</span> (generic-args) (<span class="hljs-keyword">import</span>-args)<br><span class="hljs-comment">//从MySQL数据库服务器中的emp表导入HDFS</span><br>sqoop <span class="hljs-keyword">import</span> \ --connect jdbc:mysql:<br><span class="hljs-comment">//localhost/userdb \ --username root \ --table emp --m 1</span><br><span class="hljs-comment">//验证在HDFS导入的数据</span><br>HADOOP_HOME/bin/hadoop fs -cat /emp/part-m-*<br><span class="hljs-comment">//指定目标目录选项的Sqoop导入命令</span><br>sqoop <span class="hljs-keyword">import</span> \ --connect jdbc:mysql: <br><span class="hljs-comment">//localhost/userdb \ --username root \ --table emp_add \ --m 1 \ --target-dir /queryresult</span><br><span class="hljs-comment">//验证 /queryresult 目录中 emp_add表导入的数据形式</span><br>HADOOP_HOME/bin/hadoop fs -cat /queryresult/part-m-*<br><span class="hljs-comment">//增量导入</span><br>        <span class="hljs-comment">//仅导入新添加的表中的行的技术。它需要添加&#x27;incremental&#x27;， &#x27;check-column&#x27;， 和 &#x27;last-value&#x27;选项来执行增量导入</span><br>--incremental  --check-column  --last value <br>        <span class="hljs-comment">//在EMP表执行增量导入</span><br>    sqoop <span class="hljs-keyword">import</span> \ --connect jdbc:mysql:<br><span class="hljs-comment">//localhost/userdb \ --username root \ --table emp \ --m 1 \ --incremental append \ --check-column id \ -last value 1205</span><br>        <span class="hljs-comment">//从emp表导入HDFS emp/ 目录的数据验证</span><br>HADOOP_HOME/bin/hadoop fs -cat /emp/part-m-*<br>        <span class="hljs-comment">//从表emp 用来查看修改或新添加的行</span><br>    HADOOP_HOME/bin/hadoop fs -cat /emp/part-m-*<span class="hljs-number">1</span><br><span class="hljs-comment">//导入所有表</span><br>sqoop <span class="hljs-keyword">import</span>-all-tables (generic-args) (<span class="hljs-keyword">import</span>-args) <br></code></pre></td></tr></table></figure><h1 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">sqoop <span class="hljs-title function_">codegen</span> <span class="hljs-params">(generic-args)</span> (codegen-args) <br>#以USERDB数据库中的表emp来生成Java代码<br>sqoop codegen \ --connect jdbc:mysql:<br><span class="hljs-comment">//localhost/userdb \ --username root \ --table emp</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>2.数据采集、传输与同步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Kafka/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Kafka/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>消息系统&#x2F;队列，离、在线消息传递，中间件框架，负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，而不必担心如何共享数据。</p><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>可用的消息传递模式有两种：</p><ul><li><p>点对点；</p></li><li><p>发布-订阅（pub-sub），大多数消息传递模式为此。</p></li></ul><p>群集图：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Kafka/1688841776184.jpg" alt="1688841776184"></p><p>Broker（代理）：Kafka集群通常由多个代理组成，以保持负载平衡。 Kafka代理是无状态的，因此他们使用ZooKeeper来维护其集群状态。</p><h2 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h2><p>消息将保留在队列中。一个或多个使用者可以使用队列中的消息，但是特定消息最多只能由一个使用者使用。使用者读取队列中的消息后，该消息将从该队列中消失。<br>$$<br>发送者→消息队列→接受者<br>$$</p><h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布-订阅"></a>发布-订阅</h2><p>消息保留在<strong>主题</strong>中。</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Kafka/1688841878650.jpg" alt="1688841878650"></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Kafka/1688841907797.jpg" alt="1688841907797"></p><p>topics（主题）：属于特定类别的消息流称为主题。数据存储在主题中。 主题分为多个分区。对于每个主题，Kafka都会保留一个分区的最小值。每个此类分区都包含不可变有序序列的消息。分区被实现为一组大小相等的段文件。</p><p>Leader（领导）：Leader是负责给定分区的所有读取和写入的节点。每个分区都有一个充当领导者的服务器。</p><p>brokers（代理）：代理是简单的系统，负责维护发布的数据。每个代理每个主题可以有零个或多个分区。</p><p>Follower（追随者）：遵循领导者指令的节点称为跟随者（follower）。如果领导者失败，则跟随者之一将自动成为新领导者。关注者充当普通使用者，提取消息并更新其自己的数据存储。</p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p>以下是发布-订阅消息的分步工作流程：</p><ul><li>生产者定期向主题发送消息。</li><li>Kafka代理将所有消息存储在为特定主题配置的分区中。它确保消息在分区之间平均共享。如果生产者发送了两个消息，并且有两个分区，Kafka将在第一个分区中存储一个消息，在第二个分区中存储第二个消息。</li><li>消费者订阅特定主题。</li><li>消费者订阅主题后，Kafka将向消费者提供该主题的当前偏移量，并将偏移量保存在Zookeeper集合中。</li><li>消费者将定期（例如100 ms）向Kafka请求新消息。</li><li>一旦Kafka从生产者那里收到消息，它将把这些消息转发给消费者。</li><li>消费者将收到消息并进行处理。</li><li>消息处理后，消费者将向Kafka代理发送确认。</li><li>一旦Kafka收到确认，它将偏移量更改为新值并在Zookeeper中对其进行更新。由于在Zookeeper中保留了偏移量，因此即使在服务器出现故障时，使用者也可以正确读取下一条消息。</li><li>以上流程将重复进行，直到消费者停止请求为止。</li><li>消费者可以选择随时倒退&#x2F;跳至所需的主题偏移量并阅读所有后续消息。</li></ul><h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><p>*笔记补充（尚硅谷笔记）：<a href="https://www.cnblogs.com/yyq1/p/15523995.html">Kafka学习笔记_尚硅谷 - 一代肝帝 - 博客园 (cnblogs.com)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动ZooKeeper</span><br>bin/zookeeper-server-start.sh<br>config/zookeeper.properties<br><span class="hljs-comment">#启动Kafka Broker</span><br>bin/kafka-server-start.sh config/server.properties<br></code></pre></td></tr></table></figure><h2 id="单节点-单代理"><a href="#单节点-单代理" class="headerlink" title="单节点-单代理"></a>单节点-单代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#单节点-单代理配置</span><br>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1  --partitions 1 --topic topic-name<br><span class="hljs-comment">#获取Kafka服务器中的主题列表</span><br>bin/kafka-topics.sh --list --zookeeper localhost:2181<br><span class="hljs-comment">#启动生产者（Producer）发送消息</span><br>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic-name<br><span class="hljs-comment">#根据以上语法，producer命令行客户端需要两个主要参数-broker-list - 我们要将消息发送到的代理列表。在这种情况下，我们只有一个代理。config/server.properties文件包含代理端口ID，因为我们知道我们的代理正在侦听端口9092，因此您可以直接指定它。</span><br><span class="hljs-comment">#topic - 这是主题名称</span><br>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka<br><span class="hljs-comment">#生产者将等待来自stdin的输入，然后发布到Kafka集群。默认情况下，每行都将发布为新消息，然后在config/producer.properties文件中指定默认的生产者属性。现在，您可以在终端中键入几行消息，如下所示。</span><br><span class="hljs-comment">#输出量</span><br>bin/kafka-console-producer.sh --broker-list localhost:9092<br><span class="hljs-comment">#启动消费者以接收消息</span><br><span class="hljs-comment">#与生产者相似，默认代理者属性在config/consumer.proper-ties文件中指定。打开一个新终端，然后输入以下语法来使用消息。</span><br>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic topic-name  --from-beginning<br><span class="hljs-comment">#最后，您可以从生产者的终端输入消息，并看到它们出现在消费者的终端中。</span><br></code></pre></td></tr></table></figure><h2 id="单节点多代理（基于单代理的基础上）"><a href="#单节点多代理（基于单代理的基础上）" class="headerlink" title="单节点多代理（基于单代理的基础上）"></a>单节点多代理（基于单代理的基础上）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#在继续进行多个代理群集设置之前，请先启动ZooKeeper服务器。</span><br><span class="hljs-comment">#创建多个Kafka代理-在config/server.properties中已经有一个Kafka代理实例。现在我们需要多个代理实例，因此将现有的server.properties文件复制到两个新的配置文件中，并将其重命名为server-one.properties和server-two.properties。然后编辑两个新文件并分配以下更改-</span><br>broker.id=1<br>port=9093<br>log.dirs=/tmp/kafka-logs-1<br><span class="hljs-comment">#启动服务器：在三台服务器上完成所有更改后，然后打开三个新终端以逐个启动每个代理。</span><br>Broker1<br>bin/kafka-server-start.sh config/server.properties<br>Broker2<br>bin/kafka-server-start.sh config/server-one.properties<br>Broker3<br>bin/kafka-server-start.sh config/server-two.properties<br><span class="hljs-comment">#创建主题</span><br><span class="hljs-comment">#让我们为此主题分配复制因子值三个，因为我们正在运行三个不同的代理。如果您有两个代理，则分配的副本值将为两个。</span><br>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3  -partitions 1 --topic topic-name<br><span class="hljs-comment">#将describe命令用于检查哪个代理对当前创建的主题监听如下所示</span><br>bin/kafka-topics.sh --describe --zookeeper localhost:2181  --topic Multibrokerappli-cation<br><span class="hljs-comment">#从输出（此处未给）中，我们可以得出结论，第一行给出了所有分区的摘要，显示了主题名称、分区计数和我们已经选择的复制因子。在第二行中，每个节点将成为分区中随机选择Leader。</span><br><span class="hljs-comment">#启动生产者发送消息（同单代理）</span><br>bin/kafka-console-producer.sh --broker-list localhost:9092  --topic Multibrokerapplication<br><span class="hljs-comment">#启动消费者以接收消息（同单代理）</span><br>bin/kafka-console-consumer.sh --zookeeper localhost:2181  —topic Multibrokerapplica-tion --from-beginning<br><span class="hljs-comment">#基本主题操作</span><br><span class="hljs-comment">#修改主题</span><br>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3  -partitions 1 --topic topic-name<br><span class="hljs-comment">#删除主题</span><br>bin/kafka-topics.sh --zookeeper localhost:2181 --delete --topic topic_name<br></code></pre></td></tr></table></figure><h1 id="简单生产者-x2F-消费者-组-示例"><a href="#简单生产者-x2F-消费者-组-示例" class="headerlink" title="简单生产者&#x2F;消费者[组]示例"></a>简单生产者&#x2F;消费者[组]示例</h1><p>创建一个使用Java客户端发布和使用消息的应用程序。Kafka生产者客户端包含以下API。</p><p>见教程：</p><p><a href="https://www.jc2182.com/kafka/kafka-porducter-consumer.html">Kafka 简单生产者&#x2F;消费者示例 - 蝴蝶教程 (jc2182.com)</a></p><p><a href="https://www.jc2182.com/kafka/kafka-consumer-group.html">Kafka 消费者组示例 - 蝴蝶教程 (jc2182.com)</a></p><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>与Storm：<a href="https://www.jc2182.com/kafka/kafka-storm.html">Kafka 与Storm集成 - 蝴蝶教程 (jc2182.com)</a></p><p>与Spark：<a href="https://www.jc2182.com/kafka/kafka-spark.html">Kafka 与Spark集成 - 蝴蝶教程 (jc2182.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>2.数据采集、传输与同步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flume</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Flume/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Flume/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>用于将日志数据移入HDFS的框架。</p><p>针对流数据和批数据的分布式处理引擎。</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%81%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%90%8C%E6%AD%A5/Flume/1688841656444.jpg" alt="1688841656444"></p><h1 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用put命令将数据插入Hadoop</span><br>hadoop fs –put /所需文件的路径  /存放文件的HDFS路径<br></code></pre></td></tr></table></figure><ul><li>使用put命令，一次只能传输一个文件，而数据生成器以更高的速率生成数据。由于对较旧数据的分析准确性较差，因此我们需要一种解决方案来实时传输数据。</li><li>如果我们使用put命令，则需要打包数据，并且应准备好上传。由于网络服务器不断生成数据，因此这是一项非常困难的任务。</li></ul><p>配置：<a href="https://www.jc2182.com/flume/flume-conf.html">Flume 配置 - 蝴蝶教程 (jc2182.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>2.数据采集、传输与同步</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop-HDFS</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Hadoop-HDFS/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Hadoop-HDFS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>运行在通用硬件(commodity hardware)上的分布式文件系统（Distributed File System）</p><p>以分布式方式存储超大数据量文件，根据谷歌三驾马车中的GFS（分布式文件系统）论文原理简化实现</p><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Hadoop-HDFS/1688841180613.jpg" alt="1688841180613"></p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>*Hadoop是以主从结构的方式运行的，HDFS也是以同样的方式工作的，它也有有两种节点类型，分别是<strong>namenode节点</strong>和<strong>datanode节点</strong>。</p><p>*Namenode（Master 节点）会规范客户端对文件的访问，它维护和管理Slave节点，并把读写任务分配给Slave节点。Namenode执行文件系统的名字空间操作，比如打开，关闭，重命名文件和目录，应该把Namenode部署在高可靠的硬件上面。</p><p>*Datanode（Slave节点）在HDFS集群，Datanode节点的数量可以扩展到1000。Datanode负责数据存储，它是真正干活的节点，比如响应客户端的数据读写请求，根据Namenode的指令创建和删除block。而且还会根据副本因子把block复制到其他节点。Datanode可以部署在价格低廉的商用机器上，没必要部署在昂贵的高可用机器上。</p><p>*同时支持行存储和列存储</p><p>*（缺点）Hadoop只能执行批量处理，并且只以顺序方式访问数据。这意味着必须搜索整个数据集，即使是最简单的搜索工作。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a href="https://www.runoob.com/w3cnote/hdfs-cluster.html">5.0 HDFS 集群 | 菜鸟教程 (runoob.com)</a></p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="读"><a href="#读" class="headerlink" title="读"></a>读</h2><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Hadoop-HDFS/1688841244202.jpg" alt="1688841244202"></p><h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Hadoop-HDFS/1688841307402.jpg" alt="1688841307402"></p><p>常用语句与命令行相同~</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>3.数据存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HBase</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/HBase/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/HBase/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>*当处理结果在另一个庞大的数据集，也是按顺序处理一个巨大的数据集。在这一点上，一个新的解决方案，需要访问数据中的任何点（随机访问）单元。</p><p>*是一个数据模型，类似于谷歌的Big Table设计，可以提供快速实时随机读写、访问海量结构化数据。</p><p>*是建立在Hadoop文件系统之上的分布式面向列的数据库，也是Hadoop文件系统的一部分。</p><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/HBase/1688840608258.jpg" alt="1688840608258"></p><p>*与HDFS的区分：</p><table><thead><tr><th align="center">HDFS</th><th align="center">HBase</th></tr></thead><tbody><tr><td align="center">HDFS是适用于存储大文件的分布式文件系统。</td><td align="center">HBase是建立在HDFS之上的数据库。</td></tr><tr><td align="center">HDFS不支持快速的单个记录查找。</td><td align="center">HBase为大型表提供仜速查找。</td></tr><tr><td align="center">它提供高延迟的批处理；没有批处理的概念。</td><td align="center">$\begin{array}{l}\text { 它提供了数十亿条记录对单行的低延迟访问 } \\text { (随机访问)。 }\end{array}$</td></tr><tr><td align="center">它仅提供数据的順痰访问。</td><td align="center">$\begin{array}{l}\text { HBase 在内部使用哈希表并提供随机访问, } \\text { 并且将数据存储在索引的 HDFS 文件中, } \\text { 以加快查找速度。 }\end{array}$</td></tr></tbody></table><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>*NoSQL，列式数据库管理系统。</p><p>*在表中它由行排序。表模式定义只能列族，也就是键值对。一个表有多个列族以及每一个列族可以有任意数量的列。</p><p>*在一个HBase中：</p><ul><li>表是行的集合。</li><li>行是列族的集合。</li><li>列族是列的集合。</li><li>列是键值对的集合。</li></ul><p>*具有非规范化的数据，适用于[半]结构化的数据</p><table><thead><tr><th align="center">Rowide</th><th align="center">Column Family</th><th align="center"></th><th align="center"></th><th align="center">Column Family</th><th align="center"></th><th align="center"></th><th align="center">Column Family</th><th align="center"></th><th align="center"></th><th align="center">Column Family</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"></td><td align="center">coll</td><td align="center">$\mathrm{col} 2$</td><td align="center">$\mathrm{Col3}$</td><td align="center">coll</td><td align="center">col2</td><td align="center">$\mathrm{col}_3$</td><td align="center">coll</td><td align="center">col2</td><td align="center">$\mathrm{col} 3$</td><td align="center">coll</td><td align="center">$\operatorname{col} 2$</td><td align="center">$\mathrm{col} 3$</td></tr><tr><td align="center">1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="③常用命令"><a href="#③常用命令" class="headerlink" title="③常用命令"></a>③常用命令</h1><h2 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h2><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">status #提供的HBase的状态，例如，服务器的数量<br>version #提供正在使用的HBase的版本<br>table_help #提供有关表引用命令的帮助<br>whoami #提供有关用户的信息<br><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash">grant &lt;user&gt; &lt;permissions&gt; [&lt;table&gt; [&lt;column family&gt; [&lt;column; qualifier&gt;]]</span> <br>        #授予特定的权限，例如读取，写入，执行和管理上的表给某个用户<br>        #可以从RWXCA集中为用户授予零个或多个特权（permission），其中：<br>                R-表示读取特权。<br>                W-表示写特权。<br>                X-代表执行特权。<br>                C-表示创建特权。<br>                A-表示管理员特权。<br><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash">revoke &lt;user&gt; <span class="hljs-comment">#撤销表的用户的访问权限</span></span><br><span class="hljs-meta prompt_">hbase&gt;</span><span class="language-bash">user_permission <span class="hljs-string">&#x27;tablename&#x27;</span> <span class="hljs-comment">#列出特定表的所有权限</span></span><br></code></pre></td></tr></table></figure><h3 id="整个表操作命令"><a href="#整个表操作命令" class="headerlink" title="整个表操作命令"></a>整个表操作命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">都为在命令后面加表名~<br>create table_name <span class="hljs-comment">#创建表</span><br>list table_name <span class="hljs-comment">#列出HBase中所有的表</span><br><span class="hljs-built_in">enable</span> table_name <span class="hljs-comment">#启用表</span><br>is_enabled table_name <span class="hljs-comment">#验证表是否被启用</span><br><span class="hljs-built_in">disable</span> table_name <span class="hljs-comment">#禁用表</span><br>disable_all table_name <span class="hljs-string">&#x27;regex&#x27;</span> <span class="hljs-comment">#禁用所有与给定正则表达式匹配的表</span><br>is_disabled table_name <span class="hljs-comment">#验证表是否被禁用</span><br>exists table_name <span class="hljs-comment">#验证表是否存在</span><br>describe table_name [READONLY]<span class="hljs-comment">#表的描述信息。</span><br>alter table_name [, METHOD=&gt;method_name, NAME=&gt;setting-item_name, VERSIONS=&gt;setting_value,READONLY(option)] <span class="hljs-comment">#修改一张表</span><br>drop table_name <span class="hljs-comment">#从HBase删除表</span><br>drop_all <span class="hljs-string">&#x27;regex&#x27;</span> table_name <span class="hljs-comment">#删除命令中匹配’regex’的表</span><br><span class="hljs-built_in">exit</span> <span class="hljs-comment">#退出shell程序</span><br>./bin/stop-hbase.sh <span class="hljs-comment">#停止HBase（在HBase主文件夹中键入）</span><br></code></pre></td></tr></table></figure><h3 id="表中数据操作命令"><a href="#表中数据操作命令" class="headerlink" title="表中数据操作命令"></a>表中数据操作命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">put table name, row1, colfamily:colname, value <span class="hljs-comment">#将单元格值放在特定表中指定行中的指定列</span><br>get table name,row1 <span class="hljs-comment">#从HBase中的表读取数据</span><br>put <span class="hljs-string">&#x27;table name&#x27;</span>,<span class="hljs-string">&#x27;row&#x27;</span>,<span class="hljs-string">&#x27;Column family:column name&#x27;</span>,<span class="hljs-string">&#x27;new value&#x27;</span> <span class="hljs-comment">#更新现有的单元格值</span><br>delete table name, row, column name, time stamp <span class="hljs-comment">#删除表中的特定单元格</span><br>deleteall table name, row <span class="hljs-comment">#删除一行中的所有单元格</span><br>scan table_name <span class="hljs-comment">#扫描并返回表数据</span><br>count table_name <span class="hljs-comment">#计算并返回表中的行数</span><br><span class="hljs-built_in">truncate</span> table_name <span class="hljs-comment">#禁用删除并重新创建指定的表</span><br></code></pre></td></tr></table></figure><h2 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h2><h3 id="HTable类"><a href="#HTable类" class="headerlink" title="HTable类"></a>HTable类</h3><p>HTable是代表HBase表的HBase内部类。它是表的实现，用于与单个HBase表进行通信。该类属于org.apache.hadoop.hbase.client类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HTable(TableName tableName, ClusterConnection connection_name, ExecutorService pool) #使用此构造函数，您可以创建一个对象来访问HBase表。<br></code></pre></td></tr></table></figure><p>*操作命令：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/HBase/1688840844115.jpg" alt="1688840844115"></p><h3 id="Descriptor类"><a href="#Descriptor类" class="headerlink" title="Descriptor类"></a>Descriptor类</h3><p>此类包含有关HBase表的详细信息，例如：</p><p>*所有列族的描述符，</p><p>*如果该表是目录表，</p><p>*如果表是只读的，</p><p>*记忆库的最大大小，</p><p>*当应该发生区域分裂时，</p><p>*与之相关的协处理器，等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HTableDescriptor(TableName name) #构造函数，构造一个表描述符，指定一个TableName对象。<br>HTableDescriptor <span class="hljs-title function_">addFamily</span><span class="hljs-params">(HColumnDescriptor family)</span>         #将列族添加到给定的描述符<br></code></pre></td></tr></table></figure><h3 id="HBaseAdmin类"><a href="#HBaseAdmin类" class="headerlink" title="HBaseAdmin类"></a>HBaseAdmin类</h3><p>HBaseAdmin是代表Admin的类。此类属于org.apache.hadoop.hbase.client软件包。使用此类，您可以执行管理员的任务。您可以使用Connection.getAdmin() 方法获取Admin实例。</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">void createTable(HTableDescriptor desc)</td><td align="left">创建一个新表。</td></tr><tr><td align="left">$\begin{array}{l}\text { void createTable(HTableDescriptor desc, } \\text { byte[1] splitKeys) }\end{array}$</td><td align="left">用指定的分割键定义的初始空区域集创建一个新表。</td></tr><tr><td align="left">$\begin{array}{l}\text { void deleteColumn(byte] tableName, String } \\text { columnName) }\end{array}$</td><td align="left">从表中制除列。</td></tr><tr><td align="left">$\begin{array}{l}\text { void deleteColumn(String tableName, String } \\text { columnName) }\end{array}$</td><td align="left">从表中制除列。</td></tr><tr><td align="left">void deleteTable(String tableName)</td><td align="left">制除表格。</td></tr></tbody></table><h3 id="Put类"><a href="#Put类" class="headerlink" title="Put类"></a>Put类</h3><p>此类用于对单个行执行Put操作。它属于org.apache.hadoop.hbase.client软件包。</p><p>构造函数：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/HBase/1688840933279.jpg" alt="1688840933279"></p><p>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Put <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] family, <span class="hljs-type">byte</span>[] qualifier, <span class="hljs-type">byte</span>[] value)</span> #将指定的列和值添加到此Put操作。<br>Put <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] family, <span class="hljs-type">byte</span>[] qualifier, <span class="hljs-type">long</span> ts, <span class="hljs-type">byte</span>[] value)</span> #将指定列和值以及指定时间戳作为其版本添加到此Put操作。<br>Put <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] family, ByteBuffer qualifier, <span class="hljs-type">long</span> ts, ByteBuffer value)</span> #将指定列和值以及指定时间戳作为其版本添加到此Put操作。<br>Put <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] family, ByteBuffer qualifier, <span class="hljs-type">long</span> ts, ByteBuffer value)</span> #将指定列和值以及指定时间戳作为其版本添加到此Put操作。<br></code></pre></td></tr></table></figure><h3 id="Get类"><a href="#Get类" class="headerlink" title="Get类"></a>Get类</h3><p>此类用于在单行上执行Get操作。此类属于org.apache.hadoop.hbase.client软件包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Get(<span class="hljs-type">byte</span>[] row)  #使用此构造函数，可以为指定的行创建Get操作。<br></code></pre></td></tr></table></figure><p>操作命令：</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Get addColumn(byte[ family, byte[ qualifier)</td><td align="left">使用指定的限定词从特定族检索列。</td></tr><tr><td align="left">Get addFamily(byte[ family)</td><td align="left">检索指定族的所有列。</td></tr></tbody></table><h3 id="Result类"><a href="#Result类" class="headerlink" title="Result类"></a>Result类</h3><p>此类用于获取Get或Scan查询的单行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Result() #使用此构造函数，您可以创建一个没有KeyValue有效负载的空Result； 如果调用raw Cells（），则返回<span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">byte[ getValue(byte[ family, byte[ qualifier)</td><td align="left">此方法用于获取指定列的最新版本。</td></tr><tr><td align="left">byte[ getRow0</td><td align="left">此方法用于检索与创建此结果的行相对应的行键。</td></tr></tbody></table><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>此类用于在单行上执行Delete操作。要删除整行，请使用要删除的行实例化Delete对象。此类属于org.apache.hadoop.hbase.client软件包。</p><p>*构造方法：</p><table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Delete(byte[ row)</td><td align="left">为指定的行创建一个Delete操作。</td></tr><tr><td align="left">Delete(byte[ rowArray, int rowOffset, int rowLength)</td><td align="left">为指定的行和时间截创建一个Delete操作。</td></tr><tr><td align="left">$\begin{array}{l}\text { Delete(byte[ rowArray, int rowOffset, int rowLength, } \\text { long ts) }\end{array}$</td><td align="left">为指定的行和时间截创建一个Delete操作。</td></tr><tr><td align="left">Delete(byte[ row, long timestamp)</td><td align="left">为指定的行和时间截创建一个Delete操作。</td></tr></tbody></table><p>*操作命令：</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">$\begin{array}{l}\text { Delete addColumn(byte[ family, byte[] } \\text { qualifier) }\end{array}$</td><td align="center">删除指定列的最新版本。</td></tr><tr><td align="center">$\begin{array}{l}\text { Delete addColumns(byte[ family, byte[] } \\text { qualifier, long timestamp) }\end{array}$</td><td align="center">删除时间戳小于或等于指定时间戳的指定列的所有版本。</td></tr><tr><td align="center">Delete addFamily(byte[ family)</td><td align="center">删除指定族的所有列的所有版本。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Delete <span class="hljs-title function_">addFamily</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] family, <span class="hljs-type">long</span> timestamp)</span> #删除时间戳小于或等于指定时间戳的指定族的所有列<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>3.数据存储</category>
      
      <category>列存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cassandra</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Cassandra/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Cassandra/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*高度可扩展的高性能分布式列式数据库</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Cassandra/1688840243364.jpg" alt="1688840243364"></p><h1 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h1><p>cqlsh提示符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CQL">cqlsh -- 启动cqlsh<br></code></pre></td></tr></table></figure><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Cassandra/1688840302564.jpg" alt="1688840302564"></p><p>Shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">HELP -显示所有cqlsh命令的帮助主题。<br>CAPTURE -捕获命令的输出并将其添加到文件。<br>CONSISTENCY -显示当前一致性级别，或设置新的一致性级别。<br>COPY -将数据复制到Cassandra并从Cassandra复制数据。<br>DESCRIBE -描述Cassandra及其对象的当前集群。<br>EXPAND -纵向扩展查询的输出。<br>EXIT -使用此命令，可以终止cqlsh。<br>PAGING -启用或禁用查询分页。<br>SHOW -显示当前cqlsh会话的详细信息，如Cassandra版本，主机或数据类型假设。<br>SOURCE -执行包含CQL语句的文件。<br>TRACING -启用或禁用请求跟踪。<br></code></pre></td></tr></table></figure><p>具体用法： <a href="https://www.w3cschool.cn/cassandra/cassandra_shell_commands.html">https://www.w3cschool.cn/cassandra/cassandra_shell_commands.html</a></p><h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><h2 id="数据定义命令"><a href="#数据定义命令" class="headerlink" title="数据定义命令"></a>数据定义命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CQL">CREATE/ALTER KEYSPACE &lt;identifier&gt; WITH &lt;properties&gt; -创建/更改KeySpace，其中properties举例：replication = &#123;&#x27;class&#x27;: ‘Strategy name’, &#x27;replication_factor&#x27; : ‘No.Of  replicas’&#125;<br>CREATE (TABLE | COLUMNFAMILY) (&#x27;&lt;column-definition&gt;&#x27; , &#x27;&lt;column-definition&gt;&#x27;)(WITH  AND ) -创建表<br>ALTER (TABLE | COLUMNFAMILY) &lt;tablename&gt; &lt;instruction&gt; -修改表<br>DROP TABLE &lt;tablename&gt; -删除表<br>TRUNCATE &lt;tablename&gt; -截断表<br>CREATE INDEX &lt;identifier&gt; ON &lt;tablename&gt; -创建索引<br>DROP INDEX &lt;identifier&gt; -删除索引<br>-*批处理<br>BEGIN BATCH<br>&lt;insert-stmt&gt;/ &lt;update-stmt&gt;/ &lt;delete-stmt&gt;（可以有多个、多种的语句）<br>APPLY BATCH<br></code></pre></td></tr></table></figure><h2 id="数据操作命令"><a href="#数据操作命令" class="headerlink" title="数据操作命令"></a>数据操作命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CQL">-添加<br>INSERT INTO &lt;tablename&gt;<br>(&lt;column1 name&gt;, &lt;column2 name&gt;....)<br>VALUES (&lt;value1&gt;, &lt;value2&gt;....)<br>USING &lt;option&gt;<br>-更新<br>UPDATE &lt;tablename&gt;<br>SET &lt;column name&gt; = &lt;new value&gt;<br>&lt;column name&gt; = &lt;value&gt;....<br>WHERE &lt;condition&gt;<br>-读取<br>SELECT FROM  [WHERE…]<br>-删除<br>DELETE FROM &lt;identifier&gt; WHERE &lt;condition&gt;;<br></code></pre></td></tr></table></figure><h2 id="字句"><a href="#字句" class="headerlink" title="字句"></a>字句</h2><p>同MySQL<del>（SELECT、WHERE、ORDER BY</del>）</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CQL">List用于以下的情况：将保持元素的顺序，并且值将被多次存储。<br>CREATE TABLE data(name text PRIMARY KEY, email list&lt;text&gt;); -创建表<br>INSERT INTO data(name, email) VALUES (&#x27;ramu&#x27;,[&#x27;abc@gmail.com&#x27;,&#x27;cba@yahoo.com&#x27;]) -插入<br>-更新<br>UPDATE data<br>... SET email = email +[&#x27;xyz@tutorialspoint.com&#x27;]<br>... where name = &#x27;ramu&#x27;;<br></code></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>用于存储一组元素的数据类型。集合的元素将按排序顺序返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CQL">cqlsh:tutorialspoint&gt; CREATE TABLE data2 (name text PRIMARY KEY, phone set&lt;varint&gt;); -创建<br>cqlsh:tutorialspoint&gt; INSERT INTO data2(name, phone)VALUES (&#x27;rahman&#x27;,    &#123;9848022338,9848022339&#125;); -插入<br>-更新<br>cqlsh:tutorialspoint&gt; UPDATE data2<br>   ... SET phone = phone + &#123;9848022330&#125;<br>   ... where name = &#x27;rahman&#x27;;<br></code></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>地图是用于存储元素的键值对的数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cql">cqlsh:tutorialspoint&gt; CREATE TABLE data3 (name text PRIMARY KEY, address map&lt;timestamp, text&gt;); -创建<br>cqlsh:tutorialspoint&gt; INSERT INTO data3 (name, address) VALUES (&#x27;robin&#x27;, &#123;&#x27;home&#x27; : &#x27;hyderabad&#x27; , &#x27;office&#x27; : &#x27;Delhi&#x27; &#125; ); -插入<br>-更新<br>cqlsh:tutorialspoint&gt; UPDATE data3<br>   ... SET address = address+&#123;&#x27;office&#x27;:&#x27;mumbai&#x27;&#125;<br>   ... WHERE name = &#x27;robin&#x27;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>3.数据存储</category>
      
      <category>列存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clickhouse</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Clickhouse/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Clickhouse/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*一个真正的列式数据库管理系统</p><p>*用于在线分析处理查询（OLAP）的列式数据库管理系统</p><p>*能够使用SQL语句查询实时生成分析数据报告</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>3.数据存储</category>
      
      <category>列存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Redis/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（注释符号未必是&#x2F;&#x2F;，并没有没查到！）</p><h1 id="应用方向-amp-总体介绍"><a href="#应用方向-amp-总体介绍" class="headerlink" title="应用方向&amp;总体介绍"></a>应用方向&amp;总体介绍</h1><p>*性能极高的KV非关系型数据库（field（即key）-val对）</p><p>*各数据类型都能最多存储40亿数据</p><p>*不区分大小写</p><h1 id="连接-amp-事务"><a href="#连接-amp-事务" class="headerlink" title="连接&amp;事务"></a>连接&amp;事务</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><table><thead><tr><th><strong>序号</strong></th><th><strong>命令及描述</strong></th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/redis/connection-auth.html">AUTH password</a>  验证密码是否正确</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/redis/connection-echo.html">ECHO message</a>  打印字符串</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/connection-ping.html">PING</a>  查看服务是否运行</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/redis/connection-quit.html">QUIT</a>  关闭当前连接</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/redis/connection-select.html">SELECT index</a>  切换到指定的数据库</td></tr></tbody></table><p>*服务器命令大全：<a href="https://www.runoob.com/redis/redis-server.html">Redis 服务器 | 菜鸟教程 (runoob.com)</a></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>一个事务从开始到执行会经历以下三个阶段：</p><ol><li><p>开始事务。</p></li><li><p>命令入队。</p></li><li><p>执行事务。</p></li></ol><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，不会回滚且其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">MULTI <span class="hljs-comment">//开始一个事务</span><br>… <span class="hljs-comment">//多个命令</span><br>EXEC <span class="hljs-comment">//触发事务（一并执行事务中的所有命令）</span><br>DISCARD <span class="hljs-comment">//取消事务，放弃执行事务块内的所有命令。</span><br>WATCH ds1[,…dsN] <span class="hljs-comment">//监视一/多个key。如果在事务执行之前这个/些key被其他命令所改动，那么事务将被打断。</span><br>UNWATCH <span class="hljs-comment">//取消WATCH命令对所有key的监视</span><br></code></pre></td></tr></table></figure><h1 id="数据类型与操作命令"><a href="#数据类型与操作命令" class="headerlink" title="数据类型与操作命令"></a>数据类型与操作命令</h1><p>*以String为最基本类型，其他类型中存放的都是String！</p><p>*下标从0开始</p><ol><li>启动 redis 服务器，打开终端并输入命令 <strong>redis-cli</strong>，该命令会连接本地的 redis 服务</li></ol><p>PS:redis-cli -h host -p port -a password &#x2F;&#x2F;在远程 redis 服务上执行命令</p><ol start="2"><li>COMMAND KEY_NAME &#x2F;&#x2F;开始管理值（不止是键，其他都行！）</li></ol><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">EXISTS t_name <span class="hljs-comment">//是否存在</span><br>GET t_name <span class="hljs-comment">//获取</span><br>SET t_name elem <span class="hljs-comment">//创建、插入、修改</span><br>DEL t_name <span class="hljs-comment">//需先删除再把其他值赋给此变量名！</span><br></code></pre></td></tr></table></figure><h2 id="Hash（KV）"><a href="#Hash（KV）" class="headerlink" title="Hash（KV）"></a>Hash（KV）</h2><p>*键又称字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//多个键值对，即field_name1[…field_nameN]，中间空格隔开即可，无需逗号！</span><br>HLEN h <span class="hljs-comment">//获取键值对数量</span><br>HEXISTS h field_name <span class="hljs-comment">//是否存在</span><br>H[M]GET[ALL] h field_name1[,…N] <span class="hljs-comment">//根据键获取值（HM获取多个，HGETALL获取所有）</span><br>HKEYS/VALS h <span class="hljs-comment">//获取所有哈希表中的字段</span><br>H[M]SET field_name1 value_name1[,…N] <span class="hljs-comment">//创建、插入、修改键值对（HMSET创建多个）</span><br>HDEL key field_name1[,…N] <span class="hljs-comment">//删除，可同时删多个！</span><br></code></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">llen l <span class="hljs-comment">//获取长度</span><br>lindex l index <span class="hljs-comment">//通过索引获取值</span><br>lrange l left right<span class="hljs-comment">//返回指定区间的元素</span><br> bl/rpop l <span class="hljs-comment">//弹出并获取列表的第一个/最后一个元素</span><br>lset l index value <span class="hljs-comment">//创建、插入、修改</span><br>l/rpush l ele1[,…eleN] <span class="hljs-comment">//插入头/尾部</span><br>lrem l count value <span class="hljs-comment">//删除，count表示删除的数量，为正从左往右，为负从右往左，为0删除所有</span><br></code></pre></td></tr></table></figure><h2 id="Set（无序集合）"><a href="#Set（无序集合）" class="headerlink" title="Set（无序集合）"></a>Set（无序集合）</h2><p>通过哈希表实现，复杂度都为O(1)!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">scard s <span class="hljs-comment">//获取长度</span><br>sismember s elem <span class="hljs-comment">//是否存在</span><br>smembers s <span class="hljs-comment">//获取所有元素</span><br>sadd s elem1[,…elemN] <span class="hljs-comment">//创建、插入、修改（若已存在不会报错）</span><br>srem s elem1[,…elemN] <span class="hljs-comment">//删除</span><br></code></pre></td></tr></table></figure><h2 id="zset（有序集合）"><a href="#zset（有序集合）" class="headerlink" title="zset（有序集合）"></a>zset（有序集合）</h2><p>*每个元素都会关联一个double类型的分数，通过分数来为集合中的成员进行从小到大的排序。</p><p>*成员是唯一的,但分数(score)却可以重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">zcard zs <span class="hljs-comment">//获取长度</span><br>zcount zs min max <span class="hljs-comment">//计算在有序集合中指定区间分数的成员数</span><br>zscore zs elem <span class="hljs-comment">//返回有序集中成员的分数值</span><br>zrank zs elem <span class="hljs-comment">//返回有序集合中指定成员的索引</span><br>z[rev]range zs left right [withscores] <span class="hljs-comment">//通过索引返回有序集合指定区间内的成员（有rev则分数递减排序）</span><br>zrangebylex zs left right [limit] <span class="hljs-comment">//通过字典返回有序集合指定区间内的成员</span><br>z[rev]rangebyscore zs left right [withscores] [limit] <span class="hljs-comment">//通过分数返回有序集合指定区间内的成员（有rev则分数递减排序）</span><br>zadd zs score1 elem1[,… <span class="hljs-comment">//创建、插入、修改（若已存在不会报错）</span><br>zrem zs elem1[,…elemN] <span class="hljs-comment">//删除</span><br>zremrangebylex/rank/score zs left right <span class="hljs-comment">//删除指定字典/排名/分数区间内的成员</span><br></code></pre></td></tr></table></figure><h1 id="发布-订阅（类似于Kafka）"><a href="#发布-订阅（类似于Kafka）" class="headerlink" title="发布-订阅（类似于Kafka）"></a>发布-订阅（类似于Kafka）</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/Redis/1688840038662.jpg" alt="1688840038662"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">[UN]SUBSCRIBE channel_name1[,…N] <span class="hljs-comment">//客户端订阅频道（PUN则为退订）</span><br>[PUN]PSUBSCRIBE pattern1[,…N] <span class="hljs-comment">//客户端订阅负荷给定模式的频道</span><br>PUBSUB subcommand [argument1[…N]]]…] <span class="hljs-comment">//客户端查看订阅与发布系统状态</span><br>PUBLISH channel_name message <span class="hljs-comment">//频道端发布消息，此时在客户端可以看到频道发布的消息</span><br></code></pre></td></tr></table></figure><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SCRIPT EXISTS script1 [,…scriptN] <span class="hljs-comment">//查看指定的脚本是否已经被保存在缓存当中</span><br>SCRIPT LOAD script <span class="hljs-comment">//将脚本script添加到脚本缓存中，但并不立即执行这个脚本</span><br>EVAL[SHA] script numkeys key1[,…keyN] arg [,…argN] <span class="hljs-comment">//执行Lua脚本</span><br>SCRIPT KILL <span class="hljs-comment">//杀死当前正在运行的 Lua 脚本</span><br>SCIRPT FLUSH<span class="hljs-comment">//从脚本缓存中移除所有脚本</span><br></code></pre></td></tr></table></figure><h1 id="数据备份-amp-恢复"><a href="#数据备份-amp-恢复" class="headerlink" title="数据备份&amp;恢复"></a>数据备份&amp;恢复</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">[BG]SAVE <span class="hljs-comment">//备份</span><br><span class="hljs-comment">//如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</span><br>CONFIG GET dir <span class="hljs-comment">//获取redis目录</span><br></code></pre></td></tr></table></figure><h1 id="配置、修改密码"><a href="#配置、修改密码" class="headerlink" title="配置、修改密码"></a>配置、修改密码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">CONFIG get requirepass <span class="hljs-comment">//查看是否设置了密码验证（为空说明没设置）</span><br>CONFIG <span class="hljs-built_in">set</span> requirepass your_pwd <span class="hljs-comment">//设置密码验证（即修改requirepass参数）</span><br>AUTH your_pwd <span class="hljs-comment">//密码验证</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>3.数据存储</category>
      
      <category>键值存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MongoDB/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MongoDB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总体介绍、基本概念"><a href="#总体介绍、基本概念" class="headerlink" title="总体介绍、基本概念"></a>总体介绍、基本概念</h1><p>*NoSQL，文档型存储的数据库</p><p>*与MySQL对比：</p><table><thead><tr><th align="left">SQL术语&#x2F;概念</th><th align="left">MongoDB术语&#x2F;概念</th><th align="left">解释&#x2F;说明</th></tr></thead><tbody><tr><td align="left">database</td><td align="left">databaee</td><td align="left">数据库</td></tr><tr><td align="left">table</td><td align="left">collection</td><td align="left">数据库表&#x2F;集合</td></tr><tr><td align="left">row</td><td align="left">document</td><td align="left">数据记录行&#x2F;文档</td></tr><tr><td align="left">column</td><td align="left">field</td><td align="left">数据字段&#x2F;域</td></tr><tr><td align="left">index</td><td align="left">index</td><td align="left">索引</td></tr><tr><td align="left">table joins</td><td align="left"></td><td align="left">表连接，MongoDB不支持</td></tr><tr><td align="left">primary key</td><td align="left">primary key</td><td align="left">主键，MongoDB自动将_id字段设置为主键</td></tr></tbody></table><p>*都区分大小写</p><p>*集合：</p><ul><li>集合名不能是空字符串””。</li><li>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</li></ul><p>*文档：</p><ul><li><p>一组键值对，不能有重复的键，结构类似于JSON格式</p></li><li><p>键是字符串，值还可以是其他几种数据类型（甚至可以是整个嵌入的文档)</p></li><li><p>不需要设置相同的字段，并且相同的字段不需要相同的数据类型（但通常情况下插入集合的各条文档数据都会有一定的关联性）</p></li><li><p>命名：</p></li></ul><blockquote><p>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</p></blockquote><blockquote><p>.和$有特别的意义，只有在特定环境下才能使用。</p></blockquote><p>*管道：用于将当前命令的输出结果作为下一个命令的参数。管道操作是可以重复的。</p><p>*比较语句：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>格式</strong></th><th><strong>范例</strong></th><th><strong>RDBMS中的类似语句</strong></th></tr></thead><tbody><tr><td>等于</td><td>{<key>:<value>}</value></key></td><td>db.col.find({“by”:”菜鸟教程”}).pretty()</td><td>where by &#x3D; ‘菜鸟教程’</td></tr><tr><td>小于</td><td>{<key>:{$lt:<value>}}</value></key></td><td>db.col.find({“likes”:{$lt:50}}).pretty()</td><td>where likes &lt; 50</td></tr><tr><td>小于或等于</td><td>{<key>:{$lte:<value>}}</value></key></td><td>db.col.find({“likes”:{$lte:50}}).pretty()</td><td>where likes &lt;&#x3D; 50</td></tr><tr><td>大于</td><td>{<key>:{$gt:<value>}}</value></key></td><td>db.col.find({“likes”:{$gt:50}}).pretty()</td><td>where likes &gt; 50</td></tr><tr><td>大于或等于</td><td>{<key>:{$gte:<value>}}</value></key></td><td>db.col.find({“likes”:{$gte:50}}).pretty()</td><td>where likes &gt;&#x3D; 50</td></tr><tr><td>不等于</td><td>{<key>:{$ne:<value>}}</value></key></td><td>db.col.find({“likes”:{$ne:50}}).pretty()</td><td>where likes !&#x3D; 50</td></tr></tbody></table><p>*数据类型的筛选：$type:T</p><p>*聚合语句（sum等）:</p><blockquote><p>$+sql中对应语句</p></blockquote><blockquote><p>聚合框架中有关管道常用的几个操作：</p></blockquote><ul><li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li>match使用MongoDB的标准查询操作。</li><li>$limit：用来限制MongoDB聚合管道返回的文档数。</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li>$group：将集合中的文档分组，可用于统计结果。</li><li>$sort：将输入文档排序后输出。</li></ul><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]<br></code></pre></td></tr></table></figure><ul><li>mongodb:&#x2F;&#x2F; 这是固定的格式，必须要指定。</li><li>username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登录这个数据库</li><li>host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</li><li>portX 可选的指定端口，如果不填，默认为27017</li><li>&#x2F;database 如果指定username:password@，连接并验证登录指定数据库。若不指定，默认打开 test 数据库。</li><li>?options 是连接选项。如果不使用&#x2F;database，则前面需要加上&#x2F;。所有连接选项都是键值对name&#x3D;value，键值对之间通过&amp;或;（分号）隔开</li></ul><p>具体选项：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MongoDB/1688839017941.jpg" alt="1688839017941"></p><h1 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">show dbs <span class="hljs-comment">//显示所有数据库</span><br>db <span class="hljs-comment">//显示当前数据库对象或集合</span><br>use DATABASE_NAME<span class="hljs-comment">//连接到一个指定的数据库，如果不存在则创建</span><br>db.<span class="hljs-built_in">dropDatabase</span>() <span class="hljs-comment">//删除当前数据库</span><br></code></pre></td></tr></table></figure><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">show collections/tables <span class="hljs-comment">//显示所有集合</span><br>db.<span class="hljs-built_in">createCollection</span>(collection_name[options]) <span class="hljs-comment">//创建</span><br></code></pre></td></tr></table></figure><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MongoDB/1688839246064.jpg" alt="1688839246064"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">db.collection.<span class="hljs-built_in">drop</span>() <span class="hljs-comment">//删除</span><br></code></pre></td></tr></table></figure><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp">db.collection.<span class="hljs-built_in">find</span>(query, projection)[.<span class="hljs-built_in">sort</span>(&#123;KEY:<span class="hljs-number">1</span>&#125;)][.<span class="hljs-built_in">limit</span>(limit_num)][.<span class="hljs-built_in">skip</span>(skip_num)][.<span class="hljs-built_in">pretty</span>()] <span class="hljs-comment">//查询（pretty方法更易读取，以格式化的方式来显示所有文档）</span><br>        <span class="hljs-comment">//query ：可选，使用查询操作符指定查询条件</span><br>        <span class="hljs-comment">//projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</span><br>        <span class="hljs-comment">//KEY： 1 为升序排列，而 -1 是用于降序排列</span><br>        <span class="hljs-comment">//skip：跳过指定数量的数据</span><br><br>db.COLLECTION_NAME.<span class="hljs-built_in">aggregate</span>(AGGREGATE_OPERATION) <span class="hljs-comment">//聚合，主要用于处理数据(诸如统计平均值，求和等)，类似 SQL 语句中的 count(*)</span><br><br>db.col.<span class="hljs-built_in">find</span>(&#123;key1:value1, key2:value2&#125;).<span class="hljs-built_in">pretty</span>() <span class="hljs-comment">//传入多个，表示AND条件</span><br><br>db.col.<span class="hljs-built_in">find</span><br>( <span class="hljs-comment">//OR条件</span><br>   &#123;<br>      $<span class="hljs-keyword">or</span>: [<br>         &#123;key1: value1&#125;, &#123;key2:value2&#125;<br>      ]<br>   &#125;<br>).<span class="hljs-built_in">pretty</span>()<br><span class="hljs-comment">//AND和OR可以配合使用~</span><br><br>db.COLLECTION_NAME.<span class="hljs-built_in">insert</span>(document) <span class="hljs-comment">//插入，若已存在则更新数据</span><br><br>db.COLLECTION_NAME.insertOne/<span class="hljs-built_in">replaceOne</span>(document) <span class="hljs-comment">//插入，若已存在则抛异常</span><br><br><span class="hljs-comment">//3.2版本之后新增两个命令：</span><br>db.collection.insertOne/<span class="hljs-built_in">insertMany</span><br>( <span class="hljs-comment">//向集合插入一个新文档</span><br>   &lt;document1&gt;,[…&lt;documentN&gt;,]<br>   &#123;<br>      writeConcern: &lt;document&gt; <span class="hljs-comment">//写入策略，默认为 1，即要求确认写操作，0 是不要求</span><br>      [ordered: &lt;boolean&gt;] <span class="hljs-comment">//默认 true，按顺序写入</span><br>   &#125;<br>)<br>db.collection.<span class="hljs-built_in">update</span><br>( <span class="hljs-comment">//更新集合中的文档</span><br>   &lt;query&gt;, <span class="hljs-comment">// update的查询条件，类似sql update查询内where后面的，一般为_id</span><br>   &lt;update&gt;, <span class="hljs-comment">//update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的</span><br>   &#123;<br>     [upsert: &lt;boolean&gt;,] <span class="hljs-comment">//可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入</span><br>     [multi: &lt;boolean&gt;,] <span class="hljs-comment">//可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</span><br>     [writeConcern: &lt;document&gt;] <span class="hljs-comment">//可选，抛出异常的级别</span><br>   &#125;<br>)<br><br>db.collection.<span class="hljs-built_in">save</span><br>( 通过传入的文档来替换已有文档，_id 主键存在就更新，不存在就插入<br>   &lt;document&gt;,<br>   &#123;<br>     [writeConcern: &lt;document&gt;] <span class="hljs-comment">//可选，抛出异常的级别</span><br>   &#125;<br>)<br><br>db.collection.<span class="hljs-built_in">remove</span>(<br>   [&lt;query&gt;,] <span class="hljs-comment">//（可选）删除的文档的条件</span><br>   &#123;<br>     [justOne: &lt;boolean&gt;,] <span class="hljs-comment">//（可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档</span><br>     [writeConcern: &lt;document&gt;] <span class="hljs-comment">//（可选）抛出异常的级别</span><br>   &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">db.col.<span class="hljs-built_in">totalIndexSize</span>() <span class="hljs-comment">//查看集合索引大小</span><br>db.col.<span class="hljs-built_in">getIndexes</span>() <span class="hljs-comment">//查看集合索引db.collection.createIndex(keys, options) //创建</span><br>        <span class="hljs-comment">//Key 值为你要创建的索引字段，1为指定按升序创建索引</span><br>        <span class="hljs-comment">//options中的常用参数：unique:建立的索引是否唯一。指定为true创建唯一索引。默认值为false</span><br>        <span class="hljs-comment">//没太看懂这个实例：db.col.createIndex(&#123;&quot;title&quot;:1&#125;) ？</span><br>db.col.<span class="hljs-built_in">dropIndex</span>(<span class="hljs-string">&quot;索引名称&quot;</span>) <span class="hljs-comment">//删除集合指定索引</span><br>db.col.<span class="hljs-built_in">dropIndexes</span>() <span class="hljs-comment">//删除集合所有索引</span><br></code></pre></td></tr></table></figure><h1 id="分片、备份恢复、监控"><a href="#分片、备份恢复、监控" class="headerlink" title="分片、备份恢复、监控"></a>分片、备份恢复、监控</h1><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p><a href="https://www.runoob.com/mongodb/mongodb-sharding.html">MongoDB 分片 | 菜鸟教程 (runoob.com)</a></p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mongodump -h dbhost -d dbname -o dbdirectory<br></code></pre></td></tr></table></figure><ul><li><p>-h：MongoDB 所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p></li><li><p>-d：需要备份的数据库实例，例如：test</p></li><li><p>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p></li><li><p>mongodump 命令可选参数列表如下所示：</p></li></ul><table><thead><tr><th><strong>语法</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td>mongodump –host HOST_NAME –port PORT_NUMBER</td><td>该命令将备份所有MongoDB数据</td><td>mongodump –host runoob.com –port 27017</td></tr><tr><td>mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY</td><td></td><td>mongodump –dbpath &#x2F;data&#x2F;db&#x2F; –out &#x2F;data&#x2F;backup&#x2F;</td></tr><tr><td>mongodump –collection COLLECTION –db DB_NAME</td><td>该命令将备份指定数据库的集合。</td><td>mongodump –collection mycol –db test</td></tr></tbody></table><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mongorestore -h &lt;:port&gt; -d dbname <br></code></pre></td></tr></table></figure><ul><li>-host &lt;:port&gt;, -h &lt;:port&gt;：</li></ul><p>MongoDB所在服务器地址，默认为： localhost:27017</p><ul><li><p>–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2</p></li><li><p>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！</p></li><li><p>–dbname：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定–dbname和 –dir 选项，–dir也可以设置备份目录。</p></li><li><p>–dir：指定备份的目录。你不能同时指定 和 –dir 选项。</p></li></ul><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>在大流量得情况下可以很好的应对并保证MongoDB正常运作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">mongostat <span class="hljs-comment">#隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态</span><br>mongotop <br><span class="hljs-comment">#提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据</span><br><span class="hljs-comment">#默认情况下，mongotop返回值的每一秒</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>3.数据存储</category>
      
      <category>键值存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine-Learning</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/Machine-Learning/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/Machine-Learning/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mahout库"><a href="#Mahout库" class="headerlink" title="Mahout库"></a>Mahout库</h1><p><a href="http://vue5.com/mahout/mahout.html">http://vue5.com/mahout/mahout.html</a></p><h1 id="Spark-MLlib、Spark-ML库"><a href="#Spark-MLlib、Spark-ML库" class="headerlink" title="Spark.MLlib、Spark.ML库"></a>Spark.MLlib、Spark.ML库</h1><p>略~（用的时候直接现查 <a href="http://mocom.xmu.edu.cn/article/show/5858ab782b2730e00d70fa08/0/1%E5%8D%B3%E5%8F%AF%EF%BC%89">http://mocom.xmu.edu.cn/article/show/5858ab782b2730e00d70fa08/0/1即可）</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ELK</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/ELK/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/ELK/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>针对日志数据提供解决方案</p><p>Elasticsearch、Logstash 和 Kibana:分别是高度可扩展的搜索引擎（文档存储式NoSQL）、数据收集管道工具、开源的可视化和分析工具</p><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><p>高度可扩展的搜索引擎（文档存储式NoSQL）</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>添加数据 Elasticsearch 的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">PUT name/type[/id] <br>&#123;<br>        …<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>设置索引模式的过程。通过映射，您可以告诉 Elasticsearch 你的模式中属性的数据类型。如果在预索引时未针对特定对象进行映射，则 Elasticsearch 将动态地将泛型类型添加到该字段。但是这些泛型类型是非常基本的，大多数时候都不能满足查询的期望。</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/ELK/1688837581829.jpg" alt="1688837581829"></p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ol><li><p>一般搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">POST index/type/_search <span class="hljs-comment">//具有特定索引和类型的一般搜索查询</span><br></code></pre></td></tr></table></figure></li><li><p>特定搜索</p></li></ol><p>*使用查询：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/ELK/1688837718109.jpg" alt="1688837718109"></p><p>*使用过滤器：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/ELK/1688837742444.jpg" alt="1688837742444"></p><p>*使用聚合：</p><ul><li>检查索引中有多少类型的客户：</li></ul><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/ELK/1688837765941.jpg" alt="1688837765941"></p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GET index/type/id<br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">DELETE index/type/id<br></code></pre></td></tr></table></figure><h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><p>数据收集管道工具</p><p>*一个开源数据收集引擎，可以动态集成来自各种来源的数据并将其标准化到指定的目标位置</p><p>*Logstash 配置文件分为三个部分，每个部分都包含一个或多个插件的配置选项：</p><ol><li>input（输入）</li><li>filter （过滤）</li><li>output （输出）</li></ol><p>下图为配置 CSV 文件格式的美国客户数据集文件：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/ELK/1688837858090.jpg" alt="1688837858090"></p><p>要将这个 CSV 文件数据插入 elasticsearch 中，必须通知 Logstash 服务器：</p><ol><li>打开命令提示符</li><li>进入 Logstash 的     bin 目录</li><li>输入：logstash–f X:&#x2F;foldername&#x2F;config_filename.config 然后按回车。一旦logstash 服务器启动并运行，它将开始将文件中的数据传输到Elasticsearch 中。</li><li>如果要检查是否成功插入了数据，转到 Sense 插件并键入：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GET /customers/<br></code></pre></td></tr></table></figure><p>它会为您提供已创建的文档数。</p><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><p>*一个开源的可视化和分析工具</p><p>*有助于可视化 Logstash 管道传输并存储到 Elasticsearch 中的数据</p><p>就当一般软件一样各种点击即可~</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OLAP</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/OLAP/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/OLAP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*联机分析处理（OnLine Analytical Processing）</p><p>*和OLTP（在线事务处理）的对比：</p><p>OLAP面向顾客，实时性要求高，数据量小；</p><p>OLTP面向市场，用于数据分析，实时性要求低，数据量大</p><p>*操作：</p><p>钻取（Drill-down）、上卷（Roll-up）、切片（Slice）、切块（Dice）以及旋转（Pivot）、钻过（drill-across）、钻透（drill-through）</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/OLAP/1688837452769.jpg" alt="1688837452769"></p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hive</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Hive/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Hive/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*基于Hadoop的一个数据仓库工具，功能类似于MySQL</p><p>*语句作为hql语句，类似SQL，主要区别为前者面向对象（要区分大小写）</p><p>具体笔记基本同数据库MySQL笔记本中的sql语句，此处仅列出不同之处：</p><p>*不支持INSERT,UPDATE,DELETE操作（即只能SELELCT！！）</p><p>*GROUP BY→CLUSTER BY</p><p>*不支持等值连接</p><p>*空字符串不为NULL</p><p>**同为分号结尾，但有时识别不出来，需转义为\073</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
      <category>离线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spark</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Spark/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Spark/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*对MapReduce的优化：能更好地适用于数据挖掘与机器学习等需要迭代的MapReduce的算法。</p><p>*中间输出结果可以保存在内存中，从而不再需要读写HDFS。</p><p>*与Hadoop MapReduce计算框架相比，Spark所采用的Executor有两个优点：</p><ul><li><p>利用多线程来执行具体的任务减少任务的启动开销。</p></li><li><p>Executor中有一个BlockManager存储模块，会将内存和磁盘共同作为存储设备，有效减少IO开销。</p></li></ul><h2 id="运行架构"><a href="#运行架构" class="headerlink" title="运行架构"></a>运行架构</h2><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Spark/1688836594121.jpg" alt="1688836594121"></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>*RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。</p><p>*SparkContext：应用启动时创建的Spark上下文对象，是进行Spark应用开发的主要接口，是Spark上层应用与底层实现的中转站。</p><p>*DAG：有向无环图，反映RDD之间的依赖关系。</p><p>*Job：一个Job包含多个RDD及作用于相应RDD上的各种操作，它包含很多task的并行计算，可以认为是SparkRDD里面的action，每个action的触发会生成一个job。用户提交的Job会提交给DAGScheduler，Job会被分解成Stage，Stage会被细化成Task，Task简单的说就是在一个数据partition上的单个数据处理流程。</p><p>*Stage：Job中Stage之间会有依赖关系。可以利用这些依赖关系把Job所有stage串连起来形成一个有向无环图。在单个job内是根据shuffle算子来拆分stage的，shuffle之前是一个stage，shuffle之后是另一个stage，如果一个job中有多个shuffle，那么每个shuffle之前都是一个stage。一个job被提交运行之后，将会触发stage及其父stage的执行。</p><p>*Task：在Spark中有两类task，一类是shuffleMapTask，一类是resultTask，第一类task的输出是shuffle（涉及到reduce，即合并等操作）所需数据，第二类task的输出是result，stage的划分也以此为依据。</p><p>*依赖（宽、窄两种依赖）：</p><ul><li><p>窄依赖：指父RDD的每一个分区最多被一个子RDD的分区所用。</p></li><li><p>宽依赖：指子RDD的分区依赖于父RDD的所有分区。</p></li><li><p>窄依赖不需要对分区数据进行 shuffle ，而宽依赖需要。所以窄依赖都会在一个 stage 中， 而宽依赖会作为 stage 的交界处。</p></li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Spark/1688836681602.jpg" alt="1688836681602"></p><ol><li>为应用构建起基本的运行环境，即由Driver创建一个SparkContext进行资源的申请、任务的分配和监控。</li><li>资源管理器为Executor分配资源，并启动Executor进程</li><li>SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给DAGScheduler解析成Stage，然后把一个个TaskSet提交给底层调度器TaskScheduler处理。</li><li>Executor向SparkContext申请Task，TaskScheduler将Task发放给Executor运行并提供应用程序代码。</li><li>Task在Executor上运行把执行结果反馈给TaskScheduler，然后反馈给DAGScheduler，运行完毕后写入数据并释放所有资源。</li></ol><h2 id="常用操作（键值对RDD（Pair）除外）"><a href="#常用操作（键值对RDD（Pair）除外）" class="headerlink" title="常用操作（键值对RDD（Pair）除外）"></a>常用操作（键值对RDD（Pair）除外）</h2><p>*Bash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/spark-shell <span class="hljs-comment">#启动 Spark Shell</span><br></code></pre></td></tr></table></figure><p>*Spark Shell（Scala语句）：</p><h3 id="转换操作（Transformation）"><a href="#转换操作（Transformation）" class="headerlink" title="转换操作（Transformation）"></a>转换操作（Transformation）</h3><p>*以RDD做为输入参数，然后输出一个或者多个RDD。Map()、Filter()这些都属于转换操作。</p><p>*转换操作是惰性求值操作，只有在碰到行动操作的时候，转换操作才会真正实行。某些操作支持管道化，这是一种比较有效的性能优化手段。</p><p>*转换操作分两种：窄转换和宽转换。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-comment">//以下的func一般为para_name=&gt;func(para_name)格式</span><br><span class="hljs-comment">//1.单个操作</span><br><span class="hljs-type">RDD</span>.map(func) <span class="hljs-comment">//作用于RDD中的每个对象，并将返回结果作为结果RDD中对应的元素的值</span><br><span class="hljs-type">RDD</span>.flatMap(func) <br>    <span class="hljs-comment">//和map类似，只不过map返回的是一个个元素，而flatMap返回的则是一个返回值序列的迭代器（详细区别见IV~）</span><br><span class="hljs-type">RDD</span>.filter(func) <span class="hljs-comment">//将RDD中满足该函数的元素放入新的RDD中返回</span><br><span class="hljs-type">RDD</span>.distinct() <span class="hljs-comment">//去重</span><br><span class="hljs-type">RDD</span>.sample(withReplacement,traction,[send]) <span class="hljs-comment">//对RDD采样以及是否转换</span><br>    <span class="hljs-comment">//withReplacement：表示抽出样本后是否在放回去，true表示会放回去，这也就意味着抽出的样本可能有重复</span><br>    <span class="hljs-comment">//fraction ：抽出多少，这是一个double类型的参数,0-1之间，eg:0.3表示抽出30%</span><br>    <span class="hljs-comment">//send：表示一个种子，根据这个seed随机抽取，用于调试，有时候不知道是程序出问题还是数据出了问题，就可以将这个参数设置为定值</span><br><span class="hljs-comment">//2.双个操作</span><br><span class="hljs-type">RDD1</span>.intersection(<span class="hljs-type">RDD2</span>) <span class="hljs-comment">//返回两个RDD中都有的元素，类似于集合中的交集</span><br><span class="hljs-type">RDD1</span>.subtract(<span class="hljs-type">RDD2</span>) <span class="hljs-comment">//返回一个由只存在第一个RDD1而不存在与第二个RDD2中的所有元素组成的RDD</span><br><span class="hljs-type">RDD1</span>.cartesian(<span class="hljs-type">RDD2</span>) <span class="hljs-comment">//求笛卡尔积，求出所有可能的(a,b)对</span><br></code></pre></td></tr></table></figure><h3 id="行动操作（Actions）"><a href="#行动操作（Actions）" class="headerlink" title="行动操作（Actions）"></a>行动操作（Actions）</h3><p>数据执行部分，其通过执行count，reduce，collect等方法真正执行数据的计算部分。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-type">RDD</span>.count() <span class="hljs-comment">//统计RDD中元素的个数</span><br><span class="hljs-type">RDD</span>.collect() <br>    <span class="hljs-comment">//收集数据，保存在一个新的数据结构中，用来持久化，需要注意的是collect不能用在大规模数据集上</span><br><span class="hljs-type">RDD</span>.first() <span class="hljs-comment">//从文件读取第一个记录</span><br><span class="hljs-type">RDD</span>.take(num) <span class="hljs-comment">//用于取回num个value，在这里结合map使用，方便查看值</span><br><span class="hljs-type">RDD</span>.reduce(func) <br>    <span class="hljs-comment">//操作两个RDD的元素类型的数据并返回一个同样类型的新元素（fold功能与其相同，但带有初始值）</span><br><span class="hljs-type">RDD</span>.aggregate() <br>    <span class="hljs-comment">//设置返回类型的初始值，然后通过第一个函数把RDD中的元素合并起来放入累加器，通过第二个函数把累加器两两合并</span><br>    <span class="hljs-comment">//示例：</span><br>    <span class="hljs-keyword">val</span> num1 = sc.parallelize(<span class="hljs-type">List</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br>    <span class="hljs-keyword">val</span> result = num1.aggregate((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))(<br>    | (acc,value) =&gt; (acc._1 + value,acc._2+<span class="hljs-number">1</span>),<br>    | (acc1,acc2) =&gt;(acc1._1+acc2._1,acc1._2+acc2._2)<br>    | )<br>    result: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) = (<span class="hljs-number">10</span>,<span class="hljs-number">4</span>)<br>        <span class="hljs-type">RDD</span>.foreach(func) <span class="hljs-comment">//对RDD中的每个元素使用给定的函数</span><br>        <span class="hljs-type">RDD</span>.top(num) <span class="hljs-comment">//从RDD中返回前边的num个元素</span><br>        <span class="hljs-type">RDD</span>.takeSample(withReplacement,num,[send]) <span class="hljs-comment">//从RDD中返回任意一些元素</span><br></code></pre></td></tr></table></figure><h3 id="其他操作（主要为创建、I-x2F-O）"><a href="#其他操作（主要为创建、I-x2F-O）" class="headerlink" title="其他操作（主要为创建、I&#x2F;O）"></a>其他操作（主要为创建、I&#x2F;O）</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-comment">//1.创建RDD</span><br><span class="hljs-keyword">val</span> data = sc.textFile(<span class="hljs-string">&quot;data.txt&quot;</span>) <br>    <span class="hljs-comment">//从本地文件系统创建 data.txt，其中，sc 是 SparkContext 对象，在启动 Spark Shell 的时候自动生成的</span><br>    <span class="hljs-comment">//如果数据已经存在外部文件系统，例如本地文件系统，HDFS，HBase等，可使用此方式，即调用 SparkContext 的 textFile 方法，并把文件目录或者路径作为参数。</span><br>    <span class="hljs-comment">//用 Parallelize 函数创建 RDD，这种方法可以用于数据集已经存在的情况</span><br><span class="hljs-keyword">val</span> no = <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">val</span> noData = sc.parallelize(no) <br>spark.read.csv(<span class="hljs-string">&quot;path/of/csv/file&quot;</span>).rdd <span class="hljs-comment">//从CSV文件生成RDD（这里的.rdd方法把DataSet&lt;Row&gt;转换成RDD&lt;Row&gt;类型）</span><br><span class="hljs-keyword">val</span> dataRDD = spark.read.json(<span class="hljs-string">&quot;path/of/json/file&quot;</span>).rdd <span class="hljs-comment">//从文本文件生成RDD</span><br><span class="hljs-comment">//2.操作RDD</span><br>data.cache/persist(<span class="hljs-type">StorageLevel</span>.<span class="hljs-type">MEMORY_ONLY</span>[_SER]/<span class="hljs-type">MEMORY_AND_DISK</span>[_SER]) <br>    <span class="hljs-comment">//缓存RDD（命令执行完不会立即被缓存，而是直到执行操作后才会），四种参数按顺序（从无_SER到有_SER）持久化程度递增</span><br>data.unpersist() <span class="hljs-comment">//清除RDD缓存</span><br><span class="hljs-keyword">val</span> <span class="hljs-type">DFData</span> = data.filter(line =&gt; line.contains(<span class="hljs-string">&quot;Elephant&quot;</span>)) <br><span class="hljs-comment">//过滤操作可以使用 RDD 的 filter 操作，即从已经存在的 RDD 中按条件过滤并创建新 RDD</span><br>data.partitions.length <span class="hljs-comment">//查看RDD分区数</span><br><span class="hljs-keyword">var</span> hFile = sc.textFile(<span class="hljs-string">&quot;hdfs://localhost:9000/inp&quot;</span>) <span class="hljs-comment">//从HDFS读取数据</span><br>wc.saveAsTextFile(<span class="hljs-string">&quot;hdfs://localhost:9000/out&quot;</span>) <span class="hljs-comment">//把计算结果写入HDFS文件</span><br>stop():<span class="hljs-type">Unit</span> <br><span class="hljs-comment">//关闭SparkContext（一个JVM只能运行一个SparkContext，如果想新建SparkContext，必须把旧的停掉）</span><br></code></pre></td></tr></table></figure><h3 id="概念深入辨析"><a href="#概念深入辨析" class="headerlink" title="概念深入辨析"></a>概念深入辨析</h3><p>map(func)函数会对每一条输入进行指定的func操作，然后为每一条输入返回一个对象；而flatMap(func)也会对每一条输入进行执行的func操作，然后每一条输入返回一个相对，但是最后会将所有的对象再合成为一个对象；从返回的结果的数量上来讲，map返回的数据对象的个数和原来的输入数据是相同的，而flatMap返回的个数则是不同的。</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Spark/1688837245488.jpg" alt="1688837245488"></p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
      <category>离线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop MapReduce</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Hadoop%20MapReduce/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Hadoop%20MapReduce/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*缺点：较慢</p><p>*把任务分割成小任务并分发到集群的机器上并行执行</p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Hadoop%20MapReduce/1688835975445.jpg" alt="1688835975445"></p><p>*InputFormat：是 MapReduce 框架的一个类，它对输入文件进行分割和读取，并创建数据分片 InputSplit。</p><p>*InputSplit：此对象即数据分片对象，由 InputFormat 生成的，一个数据分片由一个 Mapper 来处理。并不真正存储输入数据，它只是数据的一种引用，即一种数据的逻辑表示。每一个分片都会相应创建一个 map 任务。分片会被划分成记录，并且每个记录都会被对应 mapper 处理。InputSplit 会为 mapper 将 HDFS 块转换成逻辑分片。比如，要读取的文件是 200MB，那么就需要 2 个 InputSplit，因为这个有文件有 2 个block（默认块大小为 128MB）<br>$$<br>map 任务数量 &#x3D; {( 数据总容量 ) &#x2F; ( 分片大小 )}<br>$$<br>*RecordReader：跟 InputSplit 交互，并把数据转换成适合 mapper 读取的键值对（key-value pair）记录。默认情况下，它用的是 TextInputFormat 类来做转换。</p><p>*Mapper：主要负责过滤数据，操作对象是键值对。MapReduce 的工作基于 key-value （键值对）原则，map 输入默认把数据文件的行数作为键（key），数据行对应的内容作为值。</p><p>*Combiner：其实是种reduce操作。它对 mapper 的输出数据本地聚合，也就是说它是在输出数据的 mapper 所在的机器上执行的。主要为了减少 mapper 和 reducer 之间的数据传输。</p><p>*Partitioner：如果一个 MapReduce 作业在 reduce 阶段有多个 reducer 任务参与，才会有 Partitioner 这一步，即数据分区。它对来自 combiner 的输出数据分区并排序，其实就是对数据的 key 做哈希运算，具有相同 key 的记录会被分到相同的分区，然后每个分区会被发送给 reducer。</p><p>图解：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Hadoop%20MapReduce/1688836025669.jpg" alt="1688836025669"></p><p>![1688836060269](.&#x2F;Hadoop MapReduce&#x2F;1688836060269.jpg)</p><p>*Reducer：Mapper 生成中间数据，Reducer 以这些中间数据作为输入，进行聚合或求和计算。只有在所有的 mapper 处理完所有数据之后，reducer 才能开始处理数据。一般合适的 reduce 任务数量可以通过下面公式计算：<br>$$<br>(0.95&#x2F;1.75)∗ ( 节点数 ∗ 每个节点最大的容器数量)<br>$$<br>使用 0.95 的时候，当 map 任务完成后，reducer 会立即执行并开始传输 map 的输出数据。</p><p>使用 1.75 的时候，第一批 reducer 任务将在运行速度更快的节点上执行完成，而第二批 reducer 任务的执行在负载平衡方面做得更好。</p><p>*Mapper&amp;Reducer功能的形象表示：</p><p>Mapper：(K1, V1) —&gt; list(K2, V2)</p><p>Reducer：(K2, list(V2)) —&gt; list(K3, V3)</p><p>*Shuffle：输出的数据从 mapper 节点传输到 reducer 节点，数据会被按 key 合并和排序（value不会被排序）</p><p>*RecordWriter（图中未标出）：负责把 Reducer 输出的键值对数据写到输出文件。</p><p>*OutputFormat：RecordWriter 将 Reducer 输出的键值对写入输出文件的方式由 OutputFormat 决定。OutputFormat 是由 Hadoop 提供的用于把数据写到 HDFS 或者本地磁盘的接口。因  此，reducer 的最终输出数据是由 Outputformat 实例负责写入到 HDFS 的。</p><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">mapred.max/min.split.size(val); <span class="hljs-comment">//为文件指定分片的数量</span><br>conf.setInt(<span class="hljs-string">&quot;mapred.linerecordreader.maxlength&quot;</span>, Integer.MAX_VALUE); <span class="hljs-comment">//设置单个记录的最大值</span><br>JobConf.setNumReduceTasks(val) <span class="hljs-comment">//设置一个MapReduce job最多的Partitioner数量</span><br>hashCode() <span class="hljs-comment">//均匀地把其他 key 的数据分发到分区，使数据被均匀地发送到 reducer 任务</span><br>FileOutputformat.setOutputPath() <span class="hljs-comment">//设置输出目录</span><br></code></pre></td></tr></table></figure><h1 id="概念辨析"><a href="#概念辨析" class="headerlink" title="概念辨析"></a>概念辨析</h1><p>*InputSplit和块</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E7%A6%BB%E7%BA%BF/Hadoop%20MapReduce/1688836384803.jpg" alt="1688836384803"></p><p>假如我们需要把文件存储到 HDFS。HDFS 以块的形式存储文件，块是数据读取和存储的最小单位，并且块的默认大小是 128MB 。HDFS 把文件切分成块，并把块存储在集群的不同机器节点上，假如我们有一个 130MB 的文件，那么 HDFS 会把这个文件切割成 2 个块，如上第一个图所示。</p><p>现在，如果我们想对这些块执行 MapReduce 程序，那么它是不会被处理的，因为第二个块并不是完整的块。但是这个问题 InputSplit 可以解决。InputSplit 可以把一组 block 作为一个单独的块，因为 InputSplit 里面包含下一个块的位置以及完整的块所需的数据的字节偏移量。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
      <category>离线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spark-SQL</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Spark-SQL/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Spark-SQL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开发Spark SQL时，必须先创建一个SparkSession类，SparkSession是与集群交互的基础，也是SparkSQL的编码入口。所有的操作都要用到SparkSession提供的API。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">import org.apache.spark.sql.SparkSession<br>val spark <span class="hljs-operator">=</span> SparkSession<br>  .builder()<br>  .appName(&quot;Spark SQL basic example&quot;)<br>  .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;)<br>  .getOrCreate()<br></code></pre></td></tr></table></figure><h1 id="DataFrame基本操作"><a href="#DataFrame基本操作" class="headerlink" title="DataFrame基本操作"></a>DataFrame基本操作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">df<span class="hljs-operator">=</span>SQLContext.read.json(url) <span class="hljs-comment">-- 读取json文件并创建DataFrame</span><br>df[.<span class="hljs-keyword">select</span>(row_name)].<span class="hljs-keyword">show</span>() <span class="hljs-comment">-- 查看[某一列的]df数据</span><br>df.printSchema() <span class="hljs-comment">-- 查看df的数据模式</span><br>df.filter(df(row_name)<span class="hljs-operator">&gt;</span>val).<span class="hljs-keyword">show</span>() <span class="hljs-comment">-- 过滤搜索</span><br>df.groupBy(row_name).<span class="hljs-built_in">count</span>().<span class="hljs-keyword">show</span>() <span class="hljs-comment">-- 类似SQL语句~</span><br></code></pre></td></tr></table></figure><h1 id="I-x2F-O操作"><a href="#I-x2F-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">val file_name<span class="hljs-operator">=</span>spark.read.format(format_name).load(url) <br>  <span class="hljs-comment">-- 导入（支持parquet、orc、json等多个数据格式，默认的是parquet）</span><br>  <span class="hljs-comment">-- 也可以直接用file_name=spark.read.file_name(url)</span><br>file_name.write.mode(mode_name).format_name(url) <br>  <span class="hljs-comment">-- 选择一种编辑模式（append、overwrite）写入</span><br>file_name.select(row_name1,…n).write.format(fornat_name).save(url) <span class="hljs-comment">-- 保存</span><br>  <span class="hljs-comment">-- JDBC的读写操作</span><br>df.repartition(<span class="hljs-number">1</span>).write.mode(mode_name).option(&quot;user&quot;, &quot;root&quot;) <span class="hljs-comment">-- 写入MySQL</span><br>val mysql_name<span class="hljs-operator">=</span>spark.read.option(&quot;user&quot;, &quot;root&quot;) <span class="hljs-comment">-- 从MySQL里读数据</span><br></code></pre></td></tr></table></figure><h1 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h1><p>*Dataset是特定域对象中的强类型集合，它可以使用函数或者相关操作并行地进行转换等操作。每个Dataset都有一个称为DataFrame的非类型化的视图，这个视图是行的数据集。</p><p>*DataSet和RDD主要的区别是：DataSet是特定域的对象集合；然而RDD是任何对象的集合。DataSet的API总是强类型的；而且可以利用这些模式进行优化，然而RDD却不行。</p><p>*DataFrame是特殊的Dataset，它在编译时不会对模式进行检测。</p><p>常用操作（<strong>创建</strong>等）：<img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Spark-SQL/1688835490280.jpg" alt="1688835490280"></p><h1 id="RDD、DataFrame、DataSet的区别-amp-相互转化"><a href="#RDD、DataFrame、DataSet的区别-amp-相互转化" class="headerlink" title="RDD、DataFrame、DataSet的区别&amp;相互转化"></a>RDD、DataFrame、DataSet的区别&amp;相互转化</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><p>Spark RDD：RDD是一种弹性分布式数据集，是一种只读分区数据。它是spark的基础数据结构，具有内存计算能力、数据容错性以及数据不可修改特性。</p></li><li><p>Spark Dataframe：Dataframe也是一种不可修改的分布式数据集合，它可以按列查询数据，类似于关系数据库里面的表结构。可以对数据指定数据模式（schema）。</p></li><li><p>Spark Dataset：Dataset是DataFrame的扩展，它提供了类型安全，面向对象的编程接口。也就是说DataFrame是Dataset的一种特殊形式。</p></li></ul><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Spark-SQL/1688835595854.jpg" alt="1688835595854"></p><p>*左侧的RDD[Person]虽然以Person为类型参数，但Spark框架本身不了解 Person类的内部结构。而右侧的DataFrame却提供了详细的结构信息，使得Spark SQL可以清楚地知道该数据集中包含哪些列，每列的名称和类型各是什么。DataFrame多了数据的结构信息，即schema。RDD是分布式的 Java对象的集合。DataFrame是分布式的Row对象的集合。Dataset可以认为是DataFrame的一个特例，主要区别是Dataset每一个record存储的是一个强类型值而不是一个Row。</p><p>*Dataset和DataFrame拥有完全相同的成员函数，区别只是每一行的数据类型不同。</p><h2 id="相互转化"><a href="#相互转化" class="headerlink" title="相互转化"></a>相互转化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 在使用一些特殊的操作时，一定要加上 import spark.implicits._ 不然toDF、toDS无法使用。</span><br><span class="hljs-comment">-- DataFrame/DataSet转RDD</span><br>rdd_name<span class="hljs-operator">=</span>df<span class="hljs-operator">/</span>ds_name.rdd<br><span class="hljs-comment">-- RDD转DataFrame</span><br>import spark.implicits._<br>val testDF <span class="hljs-operator">=</span> rdd.map &#123;line<span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span><br>(line._1,line._2)<br>&#125;.toDF(&quot;col1&quot;,&quot;col2&quot;)<br><span class="hljs-comment">-- RDD转DataSet</span><br>import spark.implicits._<br><span class="hljs-keyword">case</span> class Coltest(col1:String,col2:<span class="hljs-type">Int</span>)extends Serializable <span class="hljs-comment">-- 定义字段名和类型</span><br>val testDS <span class="hljs-operator">=</span> rdd.map &#123;line<span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span><br>      Coltest(line._1,line._2)<br>&#125;.toDS<br><span class="hljs-comment">-- Dataset转DataFrame（把case class封装成Row即可）</span><br>import spark.implicits._<br>val testDF <span class="hljs-operator">=</span> testDS.toDF<br><span class="hljs-comment">-- DataFrame转Dataset</span><br>import spark.implicits._<br><span class="hljs-keyword">case</span> class Coltest(col1:String,col2:<span class="hljs-type">Int</span>)extends Serializable <span class="hljs-comment">-- 定义字段名和类型</span><br>val testDS <span class="hljs-operator">=</span> testDF.as[Coltest]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
      <category>流式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Flink</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Flink/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Flink/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*针对数据流的分布式计算提供了数据分布、数据通信以及容错机制等功能</p><p>*基于流执行引擎，Flink提供了诸多更高抽象层的API以便用户编写分布式任务</p><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>Apache Flink生态系统的不同层：</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Flink/1688834965687.jpg" alt="1688834965687"></p><h1 id="API概念"><a href="#API概念" class="headerlink" title="API概念"></a>API概念</h1><p>*用于在一段时间内对流中的数据执行批处理操作</p><p>*可在Java，Scala和Python中使用</p><p>**Wordcount案例：<a href="https://www.jc2182.com/flink/flink-api.html">Flink API 概念 - 蝴蝶教程 (jc2182.com)</a></p><h1 id="表API"><a href="#表API" class="headerlink" title="表API"></a>表API</h1><p>*可以执行批处理和流处理</p><p>*具有类似表达式语言SQL的关系API</p><p>*可以与Java和Scala数据集以及数据流API一起嵌入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 对于批处理程序，使用ExecutionEnvironment而不是StreamExecutionEnvironment<br>val env = StreamExecutionEnvironment.getExecutionEnvironment<br><br>-- 创建一个TableEnvironment<br>val tableEnv = TableEnvironment.getTableEnvironment(env)<br><br>-- 注册表<br>tableEnv.registerTable(&quot;table1&quot;, ...) -- or<br>tableEnv.registerTableSource(&quot;table2&quot;, ...) -- or<br>tableEnv.registerExternalCatalog(&quot;extCat&quot;, ...)<br>-- 注册一个输出表<br>tableEnv.registerTableSink(&quot;outputTable&quot;, ...);<br>-- 从表API查询创建一个表<br>val tapiResult = tableEnv.scan(&quot;table1&quot;).select(...)<br>-- 根据SQL查询创建一个表<br>val sqlResult = tableEnv.sqlQuery(&quot;SELECT ... FROM table2 ...&quot;)<br><br>-- 将表API结果表发送到 TableSink , SQL结果也是如此<br>tapiResult.insertInto(&quot;outputTable&quot;)<br><br>-- 执行<br>env.execute()<br></code></pre></td></tr></table></figure><h1 id="创建、运行应用程序"><a href="#创建、运行应用程序" class="headerlink" title="创建、运行应用程序"></a>创建、运行应用程序</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>具体步骤、详细图文见<a href="https://www.jc2182.com/flink/flink-create-app.html">Flink 创建Flink应用程序 - 蝴蝶教程 (jc2182.com)</a></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ol><li>转到Flink的主目录，然后在终端中运行以下命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bin/flink run /mnt/…/program_name.jar --input README.txt --output output<br></code></pre></td></tr></table></figure><ol start="2"><li>检查程序输出：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> output<br></code></pre></td></tr></table></figure><h1 id="Flink库"><a href="#Flink库" class="headerlink" title="Flink库"></a>Flink库</h1><p><a href="https://www.jc2182.com/flink/flink-lib.html">Flink 库 - 蝴蝶教程 (jc2182.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
      <category>流式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pig</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Pig/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Pig/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以处理[半&#x2F;非]结构化数据，为嵌套数据类型</p><p>可以轻松地执行MapReduce作业，而无需在Java中键入复杂的代码（大大缩短开发时间），拯救不太擅长Java的程序员</p><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Pig/1688834127966.jpg" alt="1688834127966"></p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>*注释同SQL~</p><p>*大小写：内置关键字不区分，其他区分</p><p><em>Pig数据模型是完全嵌套的（自认为实际上还是<strong>和</strong></em><em>MySQL</em>*<strong>差不多</strong>）。Relation是Pig Latin数据模型的最外层结构。它是一个包，其中:</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Pig/1688834167422.jpg" alt="1688834167422"></p><ul><li><p>包（bag）：一个包是一组无序的元组。换句话说，元组（非唯一）的集合被称为包。每个元组可以有任意数量的字段（灵活模式）。包由“{}”表示。例:{（Raja，30），（Mohammad，45）}。用户需要映射bag字段的时候，可以通过创建一个包含用户需要字段的bag。</p></li><li><p>元组（tuple）：由有序字段（映射的key）集合形成的记录称为元组，字段可以是任何类型。例:（Raja，30）。tuple的映射操作是用 .（点操作符）。可以通过字段名引用，也可以通过位置引用:t.x，t.$1。</p></li><li><p>映射（map）：k-v对。k是chararray类型，v可以是任何类型，由[]表示。例:[name＃Raja，age＃30]</p></li><li><p>关系（relation）：一个关系是一个元组的包，pig Latin中的关系是无序的。</p></li></ul><p>*Pig Latin是用于使用Apache Pig分析Hadoop中数据的语言，在使用Pig Latin处理数据时，语句是基本结构。</p><ul><li>这些语句使用关系（relation），它们包括表达式（expression）和模式（schema）。</li><li>每个语句以分号（;）结尾。</li><li>所有这些脚本都在内部转换为Map和Reduce任务。</li></ul><h1 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h1><h2 id="诊断运算符"><a href="#诊断运算符" class="headerlink" title="诊断运算符"></a>诊断运算符</h2><ul><li>Dump运算符：Dump Relation_Name –用于运行Pig Latin语句，并在屏幕上显示结果，它通常用于调试目的</li><li>Describe运算符：<strong>Describe</strong>     Relation_name –用于查看关系的模式</li><li>ExplanationExplanation运算符：<strong>explain</strong> Relation_name**;**–用于显示关系的逻辑，物理和MapReduce执行计划</li><li>Illustration运算符：illustrate     Relation_name–为你提供了一系列语句的逐步执行</li></ul><h2 id="合并-amp-拆分、连接、分组"><a href="#合并-amp-拆分、连接、分组" class="headerlink" title="合并&amp;拆分、连接、分组"></a>合并&amp;拆分、连接、分组</h2><h3 id="合并（Union）：Relation-name3-x3D-UNION-Relation-name1-Relation-name2"><a href="#合并（Union）：Relation-name3-x3D-UNION-Relation-name1-Relation-name2" class="headerlink" title="合并（Union）：Relation_name3 &#x3D; UNION Relation_name1**,** Relation_name2**;**"></a>合并（Union）：Relation_name3 <strong>&#x3D; UNION</strong> Relation_name1**,** Relation_name2**;**</h3><h3 id="拆分（SPLIT）：SPLIT-Relation1-name-INTO-Relation2-name-IF-condition1-Relation2-name-condition2-；"><a href="#拆分（SPLIT）：SPLIT-Relation1-name-INTO-Relation2-name-IF-condition1-Relation2-name-condition2-；" class="headerlink" title="拆分（SPLIT）：SPLIT Relation1_name INTO Relation2_name IF (condition1), Relation2_name **(condition2)**；"></a>拆分（SPLIT）：SPLIT Relation1_name <strong>INTO</strong> Relation2_name <strong>IF (<strong>condition1</strong>),</strong> Relation2_name **(<strong>condition2</strong>)**<strong>；</strong></h3><h3 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h3><p>可以同时使用多个key，即(key1,…keyN)，以下均用单个key[i]代替~</p><p>Self-join：Relation3_name <strong>&#x3D; JOIN</strong> Relation1_name <strong>BY key,</strong> Relation2_name <strong>BY key ;</strong></p><p>Inner Join（等值连接）Relation3_name <strong>&#x3D; JOIN</strong> Relation1_name <strong>BY</strong> key1 Relation2_name <strong>BY</strong> key2**;**</p><p>Left&#x2F;Right Outer Join（左&#x2F;右外连接）：Relation3_name <strong>&#x3D; JOIN</strong> Relation1_name <strong>BY</strong> key1 <strong>LEFT&#x2F;RIGHT OUTER,</strong> Relation2_name <strong>BY</strong> key2**;**</p><p>​       –返回左&#x2F;右表中的所有行，即使右&#x2F;左边的关系中没有匹配项（Relation1_name为左&#x2F;右表！）</p><p>Full Outer Join（全连接）：outer_full <strong>&#x3D; JOIN</strong> Relation1_name <strong>BY</strong> key1 <strong>FULL OUTER,</strong> Relation2_name <strong>BY</strong> key2**;**</p><p>Cross（向量积）：Relation3_name <strong>&#x3D; CROSS</strong> Relation1_name**,** Relation2_name**;**</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>[CO]GROUP运算符：Group_data <strong>&#x3D; GROUP</strong> Relation_name <strong>BY</strong> age**;**–收集具有相同key的数据（group通常用于一个关系，cogroup用于多个关系）</p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>FILTER（筛选）：Relation2_name <strong>&#x3D; FILTER</strong> Relation1_name <strong>BY (condition);</strong>–用于根据条件从关系中选择所需的元组</p><p>DSTINCT（去重）：Relation_name2 <strong>&#x3D; DISTINCT</strong> Relatin_name1**;**</p><p>FOREACH（数据转换）：Relation_name2 <strong>&#x3D;</strong> FOREACH Relatin_name1 GENERATE key1**[,<strong>…keyN</strong>];**–基于列数据生成指定的数据转换</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>ORDER BY：Relation_name2 <strong>&#x3D; ORDER</strong> Relatin_name1 <strong>BY (ASC</strong>|<strong>DESC);</strong></p><p>LIMIT：Result &#x3D; <strong>LIMIT</strong> Relation_name N**;**</p><h2 id="Eval函数（即聚合函数）：同SQL"><a href="#Eval函数（即聚合函数）：同SQL" class="headerlink" title="Eval函数（即聚合函数）：同SQL~"></a>Eval函数（即聚合函数）：同SQL~</h2><h2 id="包和元组函数"><a href="#包和元组函数" class="headerlink" title="包和元组函数"></a>包和元组函数</h2><table><thead><tr><th><strong>S.N.</strong></th><th><strong>函数 ＆ 描述</strong></th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.w3cschool.cn/apache_pig/apache_pig_tobag.html">TOBAG()</a>  将两个或多个表达式转换为包。</td></tr><tr><td>2</td><td><a href="https://www.w3cschool.cn/apache_pig/apache_pig_top.html">TOP()</a>  获取关系的顶部 <strong>N</strong> 个元组。</td></tr><tr><td>3</td><td><a href="https://www.w3cschool.cn/apache_pig/apache_pig_totuple.html">TOTUPLE()</a>  将一个或多个表达式转换为元组。</td></tr><tr><td>4</td><td><a href="https://www.w3cschool.cn/apache_pig/apache_pig_tomap.html">TOMAP()</a>  将key-value对转换为Map。</td></tr></tbody></table><h2 id="字符串、日期、数学函数"><a href="#字符串、日期、数学函数" class="headerlink" title="字符串、日期、数学函数"></a>字符串、日期、数学函数</h2><p><a href="https://www.w3cschool.cn/apache_pig/apache_pig_string_functions.html">Apache Pig 字符串函数_w3cschool</a></p><p><a href="https://www.w3cschool.cn/apache_pig/apache_pig_date_time_functions.html">Apache Pig 日期时间函数_w3cschool</a></p><p><a href="https://www.w3cschool.cn/apache_pig/apache_pig_math_functions.html">Apache Pig 数学函数_w3cschool</a></p><h1 id="加载-amp-存储"><a href="#加载-amp-存储" class="headerlink" title="加载&amp;存储"></a>加载&amp;存储</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ol><li><p>启动HDFS：浏览Hadoop的 sbin 目录，并启动 yarn 和Hadoop dfs</p></li><li><p>在HDFS中创建目录</p></li><li><p>将数据放在HDFS中</p></li></ol><p>Pig的输入文件包含单个行中的每个元组&#x2F;记录。记录的实体由分隔符分隔</p><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Pig/1688834686232.jpg" alt="1688834686232"></p><p>*使用 put 命令将文件从本地文件系统移动到HDFS：hdfs dfs **-**put **&#x2F;<strong>home</strong>&#x2F;<strong>Hadoop</strong>&#x2F;<strong>Pig</strong>&#x2F;<strong>Pig_Data</strong>&#x2F;<strong>student_data</strong>.**txt</p><p><em>验证文件：使用 <strong>cat</strong> 命令验证文件是否已移入HDFS：hdfs dfs <strong>-cat</strong> hdfs</em>*:–<strong>localhost</strong>:9000&#x2F;<strong>pig_data</strong>&#x2F;<strong>student_data</strong>.**txt</p><ol start="4"><li>从文件系统（HDFS &#x2F; Local）将数据加载到Apache Pig中（Load运算符）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Relation_name = LOAD <span class="hljs-string">&#x27;Input file path&#x27;</span> USING function as schema;<br></code></pre></td></tr></table></figure><p>在左侧，需要提到我们想要存储数据的关系的名称；而在右侧，我们需要定义如何存储数据。</p><ul><li>relation_name - 我们必须提到要存储数据的关系。</li><li>Input file path - 我们必须提到存储文件的HDFS目录。（在MapReduce模式下）</li><li>function - 我们必须从Apache Pig提供的一组加载函数中选择一个函数（ BinStorage，JsonLoader，PigStorage，TextLoader ）。</li><li>Schema - 我们必须定义数据的模式，可以定义所需的模式：**(<strong>column1 <strong>:</strong> <strong>data type</strong></strong>,** column2 <strong>:</strong> <strong>data type</strong><strong>,</strong> column3 <strong>:</strong> <strong>data type</strong><strong>);</strong></li></ul><p>*存储：STORE Relation_name <strong>INTO</strong> ‘ required_directory_path ‘ <strong>[USING function];</strong></p><h1 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h1><ol><li><p>将所有需要的Pig Latin语句写在单个文件中。我们可以将所有Pig Latin语句和命令写入单个文件，并将其另存为 .pig 文件。</p></li><li><p>执行脚本</p></li></ol><table><thead><tr><th><strong>Local模式</strong></th><th><strong>MapReduce模式</strong></th></tr></thead><tbody><tr><td>$ pig -x local <strong>Sample_script.pig</strong></td><td>$ pig -x mapreduce <strong>Sample_script.pig</strong></td></tr></tbody></table><p>从HDFS执行脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">pig **-**x mapreduce hdfs**:<span class="hljs-comment">/**…**/</span>**pig_name.pig<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
      <category>流式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spark-Streaming</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Spark-Streaming/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Spark-Streaming/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不要求纯实时，不要求强大可靠的事务机制，不要求动态调整并行度，那么可以考虑使用Spark Streaming。</p><p>PS：考虑使用Spark Streaming最主要的一个因素，应该要针对整个项目进行宏观的考虑，如果一个项目除了实时计算之外，还包括了其他业务功能.就要考虑使用Sparkstreaming。</p><p>所有笔记详见<a href="https://www.w3cschool.cn/spark/xb7e5ozt.html">Spark Streaming关联_w3cschool</a>中Spark Streaming相关的完整教程~</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
      <category>流式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Storm</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Storm/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Storm/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*需要纯实时的环境，不能忍受1秒以上的延迟环境，比如银行类的金融系统。如果在实时计算中要保证事务性的话，同样还是银行，数据要非常精准，需要最大限度的利用集群资源，也可以考虑Storm。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Storm/1688833160113.jpg" alt="1688833160113"></p><table><thead><tr><th align="center">组件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Tuple</td><td align="center">元组是Storm中的主要数据结构。它是有序元素的列表。影认情况下,Tuple支持所有数据类型。通常<br>它被建模为一组逗号分隔值并传递给Storm集群。</td></tr><tr><td align="center">Stream</td><td align="center">Stream是一个无序的元组序列。</td></tr><tr><td align="center">Spouts</td><td align="center">流的来源。通常，Storm接受来自原始数据源 (如Twitter Streaming API，Apache Kafka队列，Kestrel队列等)的输入数据。否则，您可以编写spout来从数据源读取数据。“ISpout”是实现spouts的核心接口。一些特定的接口是IRichSpout，BaseRichSpout,KafkaSpout等</td></tr><tr><td align="center">Bolts</td><td align="center">Bolts是逻辑处理单元。Spouts将数据传递给Bolts和Bolts进程并生成新的输出流。Bolts可以执行过滤聚合，连接，与数据源和数据库交互的操作。Bolt接收数据并发射到一个或多个Bolts。“TBolt”是实施Bolts的核心接口。一些常见的接口是IRichBolt,IBasicBolt等。</td></tr></tbody></table><ul><li>拓扑：</li></ul><p>*Spouts和Bolts连接在一起，形成拓扑结构。实时应用程序逻辑在Storm拓扑结构中指定。简而言之，拓扑是一个有向图，其顶点是计算，边是数据流。</p><p>*一个简单的拓扑开始于Spouts。Spout将数据发送到一个或多个Bolts。Bolts表示拓扑中具有最小处理逻辑的节点，并且Bolts的输出可以作为输入发射到另一Bolts中。</p><p>*Storm将始终运行拓扑，直到您终止拓扑。Apache Storm的主要工作是运行拓扑，并在给定的时间运行任意数量的拓扑。</p><ul><li>流分组：</li></ul><p>*数据流从Spouts流向Bolts或从一个Bolts流向另一个Bolts。流分组控制如何在拓扑中路由元组，并帮助我们理解拓扑中的元组流。</p><p>*四个内置分组方式：洗牌分组、字段分组、全球分组（所有的流可以分组并转发给一个Bolts。此分组将源的所有实例生成的元组发送到单个目标实例）、所有分组（将每个元组的单个副本发送到接收Bolts的所有实例）</p><ul><li>Trident：</li></ul><p>*Trident是Storm的延伸。像Storm一样，Trident也是由Twitter开发的。开发Trident的主要原因是在Storm之上提供高级抽象以及有状态流处理和低延迟分布式查询。</p><p>*Trident使用喷嘴和螺栓，但这些底层组件在执行前由Trident自动生成。Trident具有功能，过滤器，连接，分组和聚合。</p><p>*Trident处理流作为一系列被称为交易的批次。通常，这些小批量的大小将取决于数千或数百万个元组，取决于输入流。这样，Trident不同于Storm，它执行元组处理。</p><p>*Trident元组是一个已命名的值列表。TridentTuple接口是Trident拓扑的数据模型。TridentTuple接口是可以由Trident拓扑处理的基本数据单元。</p><ul><li>Trident操作：</li></ul><p>*过滤、分组（groupBy）、合并和加入、状态维护、分布式RPC（查询和检索Trident拓扑的结果）</p><p>*聚合：</p><ul><li><p>聚集 - 孤立地聚集每批Trident元组。 在聚合过程中，元组最初使用全局分组重新分区，以将同一批次的所有分区合并到一个分区中。</p></li><li><p>partitionAggregate - 聚合每个分区，而不是整个批次的Trident元组。 分区聚合的输出完全替换了输入元组。分区聚合的输出包含单个字段元组。</p></li><li><p>persistentaggregate - 在所有批次的所有Trident元组上聚合并将结果存储在内存或数据库中。</p></li></ul><h3 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h3><p><img src="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2/%E6%B5%81%E5%BC%8F/Storm/1688833576759.jpg" alt="1688833576759"></p><p>​Apache Storm有两种类型的节点： Nimbus （主节点）和 Supervisor （工作节点）。Nimbus是Apache Storm的核心组件。Nimbus的主要工作是运行Storm拓扑。Nimbus分析拓扑并收集要执行的任务。然后，它会将任务分配给可用的主管。</p><table><thead><tr><th align="center">组件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Nimbus</td><td align="center">$\begin{array}{l}\text { Nimbus是Storm集群的主节点。群集中的所有其他节点都称为工作节点。主节 } \\text { 点负责在所有工作节点之间分配数据，将任务分配给工作节点并监视故障。 }\end{array}$</td></tr><tr><td align="center">Supervisor</td><td align="center">$\begin{array}{l}\text { 遵循nimbus给出的指令的节点称为Supervisor。主管具有多个工作进程, 它管 } \\text { 理工作进程以完成由nimbus分配的任务。 }\end{array}$</td></tr></tbody></table><ul><li>分布式消息系统：</li></ul><p>Apache Storm 处理实时数据，并且输入通常来自消息排队系统。外部分布式消息系统将提供实时计算所需的输入。</p><p>Spout 将从消息系统读取数据，并将其转换为元组并输入到 Apache Storm 中。</p><p>Apache Storm 在内部使用其自己的分布式消息传递系统，用于其 nimbus 和 supervisors 之间的通信。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li><p>最初，nimbus 将等待 Storm 拓扑提交给它。</p></li><li><p>一旦提交拓扑，它将处理拓扑并收集要执行的所有任务和任务将被执行的顺序。</p></li><li><p>然后，nimbus 将任务均匀分配给所有可用的 supervisors。</p></li><li><p>在特定的时间间隔，所有 supervisor 将向 nimbus 发送心跳以通知它们仍然运行着.</p></li><li><p>当 supervisor终止并且不向心跳发送心跳时，则 nimbus 将任务分配给另一个 supervisor。</p></li><li><p>当nimbus 本身终止时，supervisor 将在没有任何问题的情况下对已经分配的任务进行工作</p></li><li><p>一旦所有的任务都完成后，supervisor 将等待新的任务进去。</p></li><li><p>同时，终止 nimbus 将由服务监控工具自动重新启动。</p></li><li><p>重新启动的网络将从停止的地方继续。同样，终止 supervisor 也可以自动重新启动。由于网络管理程序和 supervisor 都可以自动重新启动，并且两者将像以前一样继续，因此 Storm 保证至少处理所有任务一次。</p></li><li><p>一旦处理了所有拓扑，则网络管理器等待新的拓扑到达，并且类似地，，管理器等待新的任务</p></li></ol><h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>默认情况下，Storm 集群有两种模式。</p><ul><li>本地模式</li></ul><p>此模式用于开发，测试和调试，因为它是查看所有拓扑组件协同工作的最简单方法。在这种模式下，我们可以调整参数，使我们能够看到我们的拓扑如何在不同的 Storm 配置环境中运行。在本地模式下，Storm 拓扑在本地机器上在单个 JVM 中运行。</p><ul><li>生产模式</li></ul><p>在这种模式下，我们将拓扑提交到工作 Storm 集群，该集群由许多进程组成，通常运行在不同的机器上。如在 Storm 的工作流中所讨论的，工作集群将无限地运行，直到它被关闭。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>4.数据分析&amp;查询</category>
      
      <category>流式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Win-R/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Win-R/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Win+R</p><h1 id="软件工具"><a href="#软件工具" class="headerlink" title="软件工具"></a>软件工具</h1><p>notepad:记事本</p><p>mspaint:系统画图</p><p>explorer:资源管理器</p><p>*clipbrd:剪切板查看器</p><p>cleanmgr:磁盘清理</p><p>control:控制面板</p><h1 id="修复工具"><a href="#修复工具" class="headerlink" title="修复工具"></a>修复工具</h1><p>sfc &#x2F;scannow:扫描错误并复原</p><p>perfmon:资源和性能监视器</p><p>devmgmt.msc:设备管理器</p><p>compmgmt.msc:计算机管理器</p><p>dcomcnfg:系统组件服务（由此可打开控制台、其他组件服务）</p><p>services.msc:本地服务设置</p><p>*regedit:注册表</p><p>gpedit.msc:组策略</p><p>msconfig:系统配置</p><p>向日葵远程控制CtrlCV失效：进入远程界面，打开任务管理，找到rdpclip.exe进程，结束进程。在使用win+R调出运行框，输入rdpclip回车。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件IO</title>
    <link href="/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E6%96%87%E4%BB%B6IO/"/>
    <url>/2023/07/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E6%96%87%E4%BB%B6IO/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>同Java：</p><ul><li>三种File相关类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">File(File parent, String child);<br> <span class="hljs-comment">//通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。</span><br>FileReader(File file); <span class="hljs-comment">//在给定从中读取数据的 File 的情况下创建一个新 FileReader</span><br>FileWriter(File file, <span class="hljs-type">boolean</span> append); <br> <span class="hljs-comment">//在给出 File 对象的情况下构造一个 FileWriter 对象。（append为false则写入开始处否则追加）</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>每个Exception类型也需要import！</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-keyword">try</span> &#123;<br>        …<br>     &#125; <br><span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> ex: <span class="hljs-type">Exception1</span> =&gt;&#123;<br>       …<br>    &#125;<br>    <span class="hljs-keyword">case</span> ex: <span class="hljs-type">Exception2</span> =&gt; &#123;<br>       …<br>    &#125;<br><span class="hljs-keyword">finally</span>&#123;<br>    …<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/OOP/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/OOP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>保护成员（Protected）只允许保护成员在定义了该成员的的类的子类中被访问。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>*与Java很相似,详见下面~</p><p>*有几点不同：</p><ul><li><p>重写一个非抽象方法必须使用override修饰符。</p></li><li><p>只有主构造函数才可以往基类的构造函数里写参数。</p></li><li><p>在子类中重写超类的抽象方法时，你不需要使用override关键字。</p></li><li><p>单例对象：</p></li></ul><p>*Scala 中，是没有 static 这个东西的，但是它也为我们提供了单例模式的实现方法，那就是使用关键字 object。</p><p>*Scala 中使用单例模式时，除了定义的类之外，还要定义一个同名的 object 对象，它和类的区别是，object对象不能带参数。</p><p>*当单例对象与某个类共享同一个名称时，他被称作是这个类的伴生对象：companion object。你必须在同一个源文件里定义类和它的伴生对象。类被称为是这个单例对象的伴生类：companion class。类和它的伴生对象可以互相访问其私有成员。</p><p>*相似之处：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">父类</span> </span>&#123;<br>&#125;<br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>*子类拥有父类非 private 的属性、方法。</p><p>*子类可以用自己的方式实现父类的方法（即重载）。</p><p>*使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-title">implements</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span> </span>&#123; &#125;;<br></code></pre></td></tr></table></figure><p>*super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p><p>*this关键字：指向自己的引用。（同时可解决实例变量和局部变量之间可能的同名冲突）</p><p>*final声明的东西（变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类）不能被继承</p><p>*构造器：</p><ul><li><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</p></li><li><p>如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。</p></li><li><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统+会自动调用父类的无参构造器。</p></li></ul><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p>Scala Trait(特征) 相当于 Java 的接口，也支持多继承。实际上它比接口还功能强大，它还可以定义属性和方法的实现。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据类型</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Scala">itrator_name.next()<br>itrator_name.hasNext()<span class="hljs-comment">//判空</span><br></code></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>*可以进行数据类型的转换（同Python中的list(…)）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> site = <span class="hljs-string">&quot;Runoob&quot;</span> :: (<span class="hljs-string">&quot;Google&quot;</span> :: (<span class="hljs-string">&quot;Baidu&quot;</span> :: <span class="hljs-type">Nil</span>))<span class="hljs-comment">//[&quot;Runoob&quot;, &quot;Google&quot;, &quot;Baidu&quot;] </span><br><span class="hljs-keyword">val</span> table = <span class="hljs-type">List</span>.tabulate(…[,…])[(n/_=&gt;func(n/_)]<br><span class="hljs-comment">//指定维度，可以指定元素（通过下标计算，func要具体化，_为不具体指代，类似Python循环里的_）</span><br></code></pre></td></tr></table></figure><p>*方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-type">List</span>.fill(num)(elem) <span class="hljs-comment">//创建一个指定重复数量的元素列表</span><br><span class="hljs-type">List_name</span>.head <span class="hljs-comment">//获取头</span><br><span class="hljs-type">List_name</span>.tail <span class="hljs-comment">//返回一个列表，包含除了第一元素之外的其他元素</span><br><span class="hljs-type">List_name</span>.isEmpty <span class="hljs-comment">//在列表为空时返回true</span><br>elem +: <span class="hljs-type">List_name</span> <span class="hljs-comment">//添加元素（没有中间插入的函数！）</span><br><span class="hljs-type">List1</span>:::<span class="hljs-type">List2</span>/<span class="hljs-type">List1</span>.:::(<span class="hljs-type">List2</span>)/<span class="hljs-type">List</span>.concat(<span class="hljs-type">List1</span>,<span class="hljs-type">List2</span>) <span class="hljs-comment">//连接</span><br><span class="hljs-type">List_name</span>.reverse() <span class="hljs-comment">//反转</span><br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>集合、映射（Map）、元组的操作均同上~</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串与正则</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>*String不可变，String Builder类可变：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-keyword">val</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>;<br>buf += &#x27;a&#x27;<br></code></pre></td></tr></table></figure><p>*库函数同Java~</p><h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><p>略，同Python：</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数与闭包</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]) &#123;  <br>       …      <br>  &#125;  <br></code></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>在函数中有变量并未声明具体值但又没有出现在形参变量列表中，在调用时可以在外部给此变量赋值后调用，此时此变量就已成功传进函数中。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E6%95%B0%E7%BB%84/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>*合并数组：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> list3=concat(list1,list2);<br></code></pre></td></tr></table></figure><p>*创建区间数组：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> list=range(…,…,…)/(…,…)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流程控制</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>同Java~</p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>*类似Java~，就多了个模式匹配：</p><ul><li><p>match 对应 Java 里的 switch，但是写在选择器表达式之后。即： 选择器 match {备选项}：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">ele_name <span class="hljs-keyword">match</span> <br>&#123; <span class="hljs-comment">//给ele_name赋值</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-type">C1</span>=&gt; <span class="hljs-type">E1</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-type">C2</span>=&gt; <span class="hljs-type">E2</span><br>      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">E3</span> <span class="hljs-comment">//其他情况</span><br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>match 表达式通过以代码编写的先后次序尝试每个模式来完成计算，只要发现有一个匹配的case，剩下的case不会继续匹配。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本语法</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Scala/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>行末分号可写可不写</p><p>注释：同Java~</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>分为变量（var）跟常量（val）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> name(:<span class="hljs-class"><span class="hljs-keyword">type</span>)<span class="hljs-title">=…</span> </span><br><span class="hljs-keyword">val</span> xmax, ymax = <span class="hljs-number">100</span>  <span class="hljs-comment">//xmax、ymax都声明为100</span><br><span class="hljs-keyword">var</span> z:<span class="hljs-type">Array</span>[<span class="hljs-type">String</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>](<span class="hljs-number">3</span>)(<span class="hljs-number">3</span>) <span class="hljs-comment">//数组</span><br></code></pre></td></tr></table></figure><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-type">StdIn</span>.readLine()/readInt()/readDouble()/… <br></code></pre></td></tr></table></figure><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Scala">printIn(…) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-3.Scala</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/7%E6%B3%9B%E5%9E%8B/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/7%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用方向"><a href="#应用方向" class="headerlink" title="应用方向"></a>应用方向</h1><p>适用于多种数据类型的方法、类等</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>*在函数类型声明前使用泛型标记符（只能也只可能用一个），标记符可跟extends&#x2F;super+标记符对应的部分数据类型表示允许的上&#x2F;下限</p><p>（上下限即为数据类型的父子关系，如Number为String父亲，此处不具体列出所有关系）</p><p>*泛型标记符：</p><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)</li><li>T - Type（Java     类）</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>？ -     表示不确定的 java 类型</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>*泛指→特指：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名&lt;数据类型&gt; 变量名=<span class="hljs-keyword">new</span> 类名&lt;数据类型&gt;();<br></code></pre></td></tr></table></figure><p>*泛指</p><p>用？代替具体数据类型，如List&lt;?&gt;</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-2.JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1688824773037.jpg" alt="1688824773037"></p><h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类似于Python里的try-except</span><br><span class="hljs-keyword">try</span>&#123;<br>   <span class="hljs-comment">// 程序代码</span><br>&#125;<br><span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 异常的变量名<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<br><span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> 异常的变量名<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<br><span class="hljs-comment">//finally可有可无</span><br><span class="hljs-keyword">finally</span>&#123;<br> <span class="hljs-comment">// 程序代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>*throw(s):</p><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用throws关键字来声明。throws关键字放在方法的尾部。一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-2.JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流、文件I/O、目录</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/5%E6%B5%81%E3%80%81%E6%96%87%E4%BB%B6IO%E3%80%81%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/5%E6%B5%81%E3%80%81%E6%96%87%E4%BB%B6IO%E3%80%81%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;绝对路径&quot;</span>); <br>  <span class="hljs-comment">//使用字符串类型的文件名来创建一个输入流对象来读取文件（输出就把In改为Out）</span><br>  <span class="hljs-comment">//使用一个文件对象来创建一个输入流对象来读取文件：</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f); <br>  <span class="hljs-comment">//首先使用 File() 方法来创建一个文件对象（输出就把In改为Out）</span><br><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;绝对路径&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="文件I-x2F-O"><a href="#文件I-x2F-O" class="headerlink" title="文件I&#x2F;O"></a>文件I&#x2F;O</h1><p>三种File相关类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">File(File parent, String child);<br> <span class="hljs-comment">//通过给定的父抽象路径名和子路径名字符串创建一个新的File实例。</span><br>FileReader(File file); <span class="hljs-comment">//在给定从中读取数据的 File 的情况下创建一个新 FileReader</span><br>FileWriter(File file, <span class="hljs-type">boolean</span> append); <br> <span class="hljs-comment">//在给出 File 对象的情况下构造一个 FileWriter 对象。（append为false则写入开始处否则追加）</span><br></code></pre></td></tr></table></figure><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.File; <span class="hljs-comment">//勿忘！</span><br></code></pre></td></tr></table></figure><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>**mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">file_name.isDirectory(); <span class="hljs-comment">//是目录（文件夹）返回 true,文件则为false！</span><br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">file_name.delete();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-2.JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/4OOP/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/4OOP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/4OOP/1688823269050.jpg" alt="1688823269050"></p><h1 id="类-amp-方法"><a href="#类-amp-方法" class="headerlink" title="类&amp;方法"></a>类&amp;方法</h1><h2 id="修饰"><a href="#修饰" class="headerlink" title="修饰"></a>修饰</h2><table><thead><tr><th>修饰符</th><th>内部类</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr><td>default（缺省）</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><p>继承时若用protected，原为public的降为protected，其他则保持。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>继承方法的可变参数的声明如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">typeName... parameterName；<br></code></pre></td></tr></table></figure><p>*在方法声明中，在指定参数类型后加一个省略号(…) 。</p><p>*一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><p>*finalize()方法</p><ul><li><p>在对象被垃圾收集器析构(回收)之前调用，它用来清除回收对象。</p></li><li><p>方法里，你必须指定在对象销毁时候要执行的操作。</p></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类 &#123;<br>&#125;<br> class 子类 extends 父类 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>*子类拥有父类非 private 的属性、方法。</p><p>*子类可以用自己的方式实现父类的方法（即重载）。</p><p>*使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123; &#125;<br></code></pre></td></tr></table></figure><p>*super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p><p>*this关键字：指向自己的引用。（同时可解决实例变量和局部变量之间可能的同名冲突）</p><p>*final声明的东西（变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类）不能被继承</p><p>*构造器：</p><ul><li><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</p></li><li><p>如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。</p></li><li><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p></li></ul><h1 id="重写-amp-重载"><a href="#重写-amp-重载" class="headerlink" title="重写&amp;重载"></a>重写&amp;重载</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table><thead><tr><th><strong>区别点</strong></th><th><strong>重载方法</strong></th><th><strong>重写方法</strong></th></tr></thead><tbody><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>一定不能修改</td></tr><tr><td>异常</td><td>可以修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><p><img src="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/4OOP/1688823464418.jpg" alt="1688823464418"></p><h2 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h2><ul><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>构造方法不能被重写。</li></ul><h2 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h2><p>*重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p><p>*每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p><p>*最常用的地方就是构造器的重载。</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态&#x3D;继承+重写</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>*抽象方法：一个类包含一个特别的成员方法，该方法的具体实现由它的子类确定。</p><p>*Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体（即方法名后面直接跟一个分号，而不是花括号）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">computePay</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>*抽象类不能被实例化！只有抽象类的非抽象子类可以创建对象！</p><p>*构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p><p>*如果一个类包含抽象方法，那么该类必须是抽象类。</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>隐藏→安全、好维护</p><p>private对属性设为私有，可提供公共方法对外访问&#x2F;修改（getter&#x2F;setter）</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>*一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><p>*除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[可见度] interface 接口名称 [extends 其他的接口名]<br> &#123; <br><span class="hljs-comment">// 声明变量</span><br> <span class="hljs-comment">// 抽象方法</span><br> &#125;<br></code></pre></td></tr></table></figure><ul><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承，且一个接口能支持另一个接口。</li><li>接口不能用于实例化对象。</li><li>接口没有构造方法，且只有抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static     final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li></ul><ul><li><p>标记接口：</p><p>  最常用的继承接口是没有包含任何方法肯属性的接口，即标记接口，它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>  简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p></li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>*是一个特殊的类，一般表示一组常量。</p><p>*使用 enum 关键字来定义，各个常量使用逗号 , 来分割。</p><p>*方法（类似Python键值对）</p><ul><li>values() 返回枚举类中所有的值。</li><li>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</li><li>valueOf()方法返回指定字符串值的枚举常量。</li></ul><p>*构造函数只能使用 private 访问修饰符，所以外部无法调用。</p><p>*枚举既可以包含具体方法，也可以包含抽象方法。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-2.JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串与正则</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/3%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/3%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h2><p>*String类字符串：不可修改！</p><p>*StringBuffer和StringBuilder类可修改，二者函数基本一样，后者更快更常用但不是线程安全的（不能同步访问）</p><p>*不同类之间方法不通用！</p><h2 id="String类方法"><a href="#String类方法" class="headerlink" title="String类方法"></a>String类方法</h2><table><thead><tr><th><strong>序号</strong></th><th><strong>方法与描述</strong></th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/java/character-isletter.html">isLetter()</a>  是否是一个字母</td></tr><tr><td>2</td><td><a href="https://www.runoob.com/java/character-isdigit.html">isDigit()</a>  是否是一个数字字符</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/java/character-iswhitespace.html">isWhitespace()</a>  是否是一个空白字符</td></tr><tr><td>4</td><td><a href="https://www.runoob.com/java/character-isuppercase.html">isUpperCase()</a>  是否是大写字母</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/java/character-islowercase.html">isLowerCase()</a>  是否是小写字母</td></tr><tr><td>6</td><td><a href="https://www.runoob.com/java/character-touppercase.html">toUpperCase()</a>  指定字母的大写形式</td></tr><tr><td>7</td><td><a href="https://www.runoob.com/java/character-tolowercase.html">toLowerCase</a>()  指定字母的小写形式</td></tr><tr><td>8</td><td><a href="https://www.runoob.com/java/character-tostring.html">toString</a>()  返回字符的字符串形式，字符串的长度仅为1</td></tr></tbody></table><p>构造：~&#x3D;StringBuilder(“…”);</p><p>是否为空：isEmpty(…);</p><p>获取长度：string1.length()&#x2F;length(string1);</p><p>连接：string1.concat(string2);</p><p>比较：int compareTo(String1 String2)；</p><p>是否相等：String1 equals String2;</p><p>查找（返回第一次索引）：int indexOf(String str);</p><p>替换：String replace(char oldChar, char newChar)；</p><h2 id="StringBuilder-x2F-StringBuffer类方法："><a href="#StringBuilder-x2F-StringBuffer类方法：" class="headerlink" title="StringBuilder&#x2F;StringBuffer类方法："></a>StringBuilder&#x2F;StringBuffer类方法：</h2><table><thead><tr><th><strong>序号</strong></th><th><strong>方法描述</strong></th></tr></thead><tbody><tr><td>1</td><td>public StringBuffer append(String s)  将指定的字符串追加到此字符序列。</td></tr><tr><td>2</td><td>public StringBuffer reverse()   将此字符序列用其反转形式取代。</td></tr><tr><td>3</td><td>public delete(int start, int end)  移除此序列的子字符串中的字符。</td></tr><tr><td>4</td><td>public insert(int offset, int i)  将 int 参数的字符串表示形式插入此序列中。</td></tr><tr><td>5</td><td>insert(int offset, String str)  将 str 参数的字符串插入此序列中。</td></tr><tr><td>6</td><td>replace(int start, int end, String str)  使用给定 String 中的字符替换此序列的子字符串中的字符。</td></tr></tbody></table><h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>*详见网络爬虫分区：</p><p><a href="../../../../10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/%E7%88%AC%E8%99%AB/%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></p><p>*捕获组：</p><p>是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。捕获组是通过从左至右计算其开括号来编号。</p><p>例如，正则表达式 (dog) 创建了单一分组，组里包含”d”，”o”，和”g”。</p><p>例如，在表达式（（A）（B（C））），有四个这样的组：</p><ul><li>((A)(B(C)))</li><li>(A)</li><li>(B(C))</li><li>(C)</li></ul><p>可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。</p><p>还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。</p><h2 id="Matcher类方法"><a href="#Matcher类方法" class="headerlink" title="Matcher类方法"></a>Matcher类方法</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><table><thead><tr><th><strong>序号</strong></th><th><strong>方法及说明</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>public int start()</strong>  返回以前匹配的初始索引。</td></tr><tr><td>2</td><td><strong>public int start(int group)</strong>   返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td></tr><tr><td>3</td><td><strong>public int end()</strong>  返回最后匹配字符之后的偏移量。</td></tr><tr><td>4</td><td><strong>public int end(int group)</strong>  返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr></tbody></table><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><table><thead><tr><th>序号</th><th align="left"><strong>方法及说明</strong></th></tr></thead><tbody><tr><td>1</td><td align="left"><strong>public boolean lookingAt()</strong>   尝试将从区域开头开始的输入序列与该模式匹配。</td></tr><tr><td>2</td><td align="left"><strong>public boolean find()</strong>  尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td>3</td><td align="left"><strong>public boolean find(int start）</strong>  重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr><tr><td>4</td><td align="left"><strong>public boolean matches()</strong>  尝试将整个区域与模式匹配。</td></tr></tbody></table><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><table><thead><tr><th><strong>序号</strong></th><th><strong>方法及说明</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>public Matcher  appendReplacement(StringBuffer sb, String replacement)</strong>  实现非终端添加和替换步骤。</td></tr><tr><td>2</td><td><strong>public StringBuffer  appendTail(StringBuffer sb)</strong>  实现终端添加和替换步骤。</td></tr><tr><td>3</td><td><strong>public String replaceAll(String  replacement)</strong>   替换模式与给定替换字符串相匹配的输入序列的每个子序列。</td></tr><tr><td>4</td><td><strong>public String  replaceFirst(String replacement)</strong>   替换模式与给定替换字符串匹配的输入序列的第一个子序列。</td></tr><tr><td>5</td><td><strong>public static String  quoteReplacement(String s)</strong>  返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement  方法一个字面字符串一样工作。</td></tr></tbody></table><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>*matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。</p><p>*lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。</p><p>*replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。</p><p>*Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-2.JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Array</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/2Array/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/2Array/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>*可用于迭代ArrayList 和 HashSet等集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br>iterator_name=Set_name.iterator(); <span class="hljs-comment">//获取集合（某数据类型）对应的迭代器</span><br>itrator_name.next();<br>itrator_name.hasNext(); <span class="hljs-comment">//判空</span><br>itrator_name.remove(); <span class="hljs-comment">//删除</span><br></code></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>*一般数组：略~</p><p>*动态数组队列ArrayList的常用操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br>array_name.get(index) <span class="hljs-comment">//读取</span><br>array_name.add() <span class="hljs-comment">//追加</span><br>array.name.set(index,reset) <span class="hljs-comment">//修改</span><br>array_name.remove(index) <span class="hljs-comment">//删除</span><br>array_name.sort() <span class="hljs-comment">//排序</span><br></code></pre></td></tr></table></figure><h1 id="Array类方法"><a href="#Array类方法" class="headerlink" title="Array类方法"></a>Array类方法</h1><p>调用：Arrays.方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(Object[] a, Object key)</span>；<br>    <span class="hljs-comment">//二分查找（有则返回索引无则返回-1）：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> val)</span>; <span class="hljs-comment">//填充</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Object[] a)</span>; <span class="hljs-comment">//排序</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-2.JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本语句-Java</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/1%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5-Java/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/JavaSE/1%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5-Java/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>导入包：import …;</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>*全局&#x2F;成员变量分为静态变量和实例变量，其中静态变量可以先在类体中声明，然后再方法中赋值；实例变量则不行。</p><p>*各个类型有默认值（0&#x2F;空&#x2F;null）</p><p>*Character对象：Character ch&#x3D;…;</p><p>*字符串：String …&#x3D;new String(“…”);</p><p>*数组声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">dataType[] name;<span class="hljs-comment">//首选</span><br>dataType name[];<span class="hljs-comment">//效果相同</span><br>dataType[][] name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">dataType</span>[m][n];<br></code></pre></td></tr></table></figure><p>*注释:同C~</p><p>*修饰符:修饰类中方法和属性</p><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><p>*变量类型:</p><p>*一个类可以包含以下类型变量：</p><ul><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><p>*常量：不能修改，用final声明</p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>*字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">u…=System.in.read();<span class="hljs-comment">//读取一个字符，字符串为readline</span><br></code></pre></td></tr></table></figure><p>*数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.scanner;<br>Scanner scanner=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>();<br>n=scanner.nextInt/nextFloat/nextDouble();<br></code></pre></td></tr></table></figure><h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><p>Math类的计算：Math.名称</p><p>运算符（与或等）同C语言</p><p>min、max函数</p><p>A instance of typeB 判断A是否typeB类型</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(…); <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-2.JavaSE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Git/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Git/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><p>工作区：就是你在电脑里能看到的目录。</p></li><li><p>暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</p></li><li><p>版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</p></li></ul><p><img src="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Git/1688821081542.jpg" alt="1688821081542"></p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><ol><li><p>克隆 Git 资源作为工作目录。</p></li><li><p>在克隆的资源上添加或修改文件。</p></li><li><p>如果其他人修改了，你可以更新资源。</p></li><li><p>在提交前查看修改。</p></li><li><p>提交修改。</p></li><li><p>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</p></li></ol><p><img src="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Git/1688821200276.jpg" alt="1688821200276"></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p><img src="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Git/1688821235686.jpg" alt="1688821235686"></p><ul><li><p>说明：</p><p>  workspace：工作区</p><p>  staging area：暂存区&#x2F;缓存区</p><p>  local repository：版本库或本地仓库</p><p>  remote repository：远程仓库</p><p>  其他命令：</p></li></ul><p>*其他命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init //初始化由当前目录作为的仓库<br>git branch(brahchname) //创建分支<br>git checout [-b] (branchname) //切换分支（有-b则为创建分支并立即切换到该分支下）<br>git branch -d (branchname) //删除分支<br>//查看提交历史(git <span class="hljs-built_in">log</span>为基本语句，以下语句可在同一句中一块使用<br>git <span class="hljs-built_in">log</span> --oneline //查看历史记录的简洁的版本<br>git <span class="hljs-built_in">log</span> --graph //查看历史中什么时候出现了分支、合并<br>git <span class="hljs-built_in">log</span> --reverse //逆向显示所有日志<br>git <span class="hljs-built_in">log</span> --author //查找指定用户的提交日志<br>git <span class="hljs-built_in">log</span> –since/until=&#123;yy-mm-dd&#125; -before/after=&#123;yy-mm-dd&#125; //指定日期<br>git blame //查看指定文件的修改记录<br>//标签命令<br>git tag -a v1.0 //给最新一次提交打上（HEAD）<span class="hljs-string">&quot;v1.0&quot;</span>的标签<br>git tag //查看所有标签<br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;runoob.com标签&quot;</span>  //指定标签信息<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/CentOS/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/CentOS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>与Ubuntu的区别：</li></ul><p>*centos中新建的非root用户是没有sudo的权限的，如果需要使用sudo权限必须在&#x2F;etc&#x2F;sudoers 中加入账户和权限，所以切换到root账号的时候只需要输入：su,加入root账号的密码即可。</p><p>*安装命令为yum…</p><p>*centos是来自于redhat，所以centos支持rpm格式的安装。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-1.Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bash</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Bash/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Bash/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>*批量执行命令：新建名为Name.sh的Shell脚本文件，用vim输入命令组后（若为需要回答Y&#x2F;n的安装命令，可在对于命令后面加上-y），在其目录运行命令bash Name.sh</p><ul><li>root身份运行：<br>暂时（5min）：sudo<br>长久：su（之后就不需要再加sudo了，想退出按exit）</li></ul><p>*进入图形化root文件夹(直接打开资源管理器,左栏底部”其他位置”就是~): nautilus &#x2F;</p><ul><li>运行文件：<br>shell文件：bash name.sh<br>其他：.&#x2F;name</li></ul><p>*login：用户名&#x2F;n密码，用户名为zuoyerumeng<br>**翻墙（暂无效）：proxy_on<br>*测试网速：speedtest-cli</p><p>*逻辑符号：</p><ul><li>|：在linux中是作为管道符的，将‘|’前面命令的输出作为’|’后面的输入。</li><li>||：双竖线‘||’分割的多条命令，执行的时候遵循如下规则，如果前一条命令为真，则后面的命令不会执行，如果前一条命令为假，则继续执行后面的命令</li><li>&amp;：同时执行多条命令，不管命令是否执行成功</li><li>&amp;&amp; ：可同时执行多条命令，当碰到执行错误的命令时，将不再执行后面的命令。如果一直没有错误的，则执行完毕</li></ul><p>*列出所有占用端口的进程服务：sudo netstat -tanlp<br>*查找占用某端口的进程服务：ps ef | grep 端口号</p><h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><p>依赖问题：换成sudo aptitude install …</p><h2 id="软件商店"><a href="#软件商店" class="headerlink" title="软件商店"></a>软件商店</h2><h2 id="apt-官网上一般也有命令行安装方式"><a href="#apt-官网上一般也有命令行安装方式" class="headerlink" title="apt(官网上一般也有命令行安装方式!)"></a>apt(官网上一般也有命令行安装方式!)</h2><p>在Ubuntu 16 之前要使用apt-get install 软件包来安装，在Ubuntu 16 之后可以直接使用apt install 软件包来安装。</p><p>列出所有已安装的包：apt list –installed</p><ul><li>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：sudo apt show <package_name></package_name></li></ul><p>更新软件列表：apt update [-y]</p><p>搜索软件: apt search 关键字</p><p>显示软件包详情：apt show 软件包名</p><p>安装软件：apt install 软件包名</p><p>升级指定软件：apt upgrade 软件包名</p><p>升级所有可以升级的软件：apt upgrade</p><p>卸载软件：apt remove 软件包名</p><p>卸载软件并移除软件依赖：apt autoremove 软件包名</p><p>卸载软件并删除配置文件：apt remove 软件包名 –purge</p><h2 id="snap"><a href="#snap" class="headerlink" title="snap"></a>snap</h2><p>snap是在Ubuntu 16 新添加的一种软件包格式。这种格式把软件运行所需的依赖全部打包到软件包里面， 运行的时候持载到一个虚拟的环境里面运行。所有这种格式的软件包安装时不会破坏系统现有的软件包依赖。</p><p>搜索软件包：snap find 关键字</p><p>显示软件包详情：snap info 软件包名</p><p>安装软件包：snap install 软件包名</p><p>升级指定软件：snap refresh 软件包名</p><p>升级所有可以升级的软件：snap refresh</p><p>卸载软件：snap remove 软件包名</p><h2 id="下载→-解-压缩安装包-都得先cd到安装包目录-即”下载”"><a href="#下载→-解-压缩安装包-都得先cd到安装包目录-即”下载”" class="headerlink" title="下载→[解]压缩安装包(都得先cd到安装包目录,即”下载”!)"></a>下载→[解]压缩安装包(都得先cd到安装包目录,即”下载”!)</h2><ol><li><p>下载：wget url</p></li><li><p>解压缩：tar -cvf newtarFile_name file1_name … fileN_name</p></li></ol><p>*deb格式:sudo dpkg -i deb_name 解压缩安装包</p><p>*tar格式</p><p>*解压缩：</p><p>对于 tar.gz ，使用 tar xvzf 安装包名称.tar.gz 命令解压</p><p>对于 tar.bz2&#x2F;xz ，使用 tar xvjf&#x2F;xvJf 安装包名称.tar.bz2&#x2F;xz 命令解压</p><ol start="3"><li><p>如果解压出的文件夹中有 \bin\脚本名称.sh 文件，则使用 cd命令导航到 bin 文件夹，然后使用 sudo bash 脚本名称.sh 命令即可安装。</p></li><li><p>若没有相应的 shell 文件，则使用下列命令安装:</p></li></ol><p>  .&#x2F;configure  make  sudo make install  </p><p>*flatpak格式</p><p>  sudo flatpak install xxx.flatpak   </p><p>*APPImage格式</p><p>直接.&#x2F;name.AppImage即可~</p><h1 id="文件-amp-目录处理"><a href="#文件-amp-目录处理" class="headerlink" title="文件&amp;目录处理"></a>文件&amp;目录处理</h1><p>pwd（英文全拼：print work directory）：显示目前的目录</p><p>ls（英文全拼：list files）: 列出目录及文件名</p><p>cd（英文全拼：change directory）：切换目录（~为home&#x2F;zuoyerumeng，.为当前目录）</p><p>cp（英文全拼：copy file）: 复制文件&#x2F;目录</p><p>mv（英文全拼：move file）: 移动文件&#x2F;目录，或修改文件&#x2F;目录的名称</p><p>mkdir（英文全拼：make directory）：新建一个的目录</p><p>rmdir（英文全拼：remove directory）：删除一个空的目录</p><p>touch：新建一个文件</p><p>rm（英文全拼：remove）: 删除文件&#x2F;目录（若非空文件夹无法删除，则换成命令rm -rf）</p><p>sudo chown -R username file_name：解除文件夹上的锁</p><h1 id="vi-m"><a href="#vi-m" class="headerlink" title="vi[m]"></a>vi[m]</h1><p><img src="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Bash/image-20230708150722897.png" alt="image-20230708150722897"></p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>用户刚刚启动 vi&#x2F;vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li>i 切换到输入模式，以输入字符。</li><li>x 删除当前光标所在处的字符。</li><li>: 切换到底线命令模式，以在最底一行输入命令。（<strong>一般直接</strong><strong>:wq**<strong>保存</strong></strong>+**<strong>退出！</strong>）</li></ul><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>可以各种移位、删除，输入字符（Insert亦可），ESC切换到命令模式</p><p><strong>全部删除：按<strong><strong>esc</strong></strong>键后，先按<strong><strong>gg</strong></strong>（到达顶部），然后****dG</strong></p><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>w 保存，q 退出</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>*l-r行另存为file_name名称的文件：:l,r w file_name</p><p>*字符串操作：</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Iword</td><td align="center">$\begin{array}{l}\text { 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird } \\text { 这个字符串, 就输入 &#x2F; vbird 即可。 }\end{array}$</td></tr><tr><td align="center">?word</td><td align="center">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="center">$\mathrm{n}$</td><td align="center">$\begin{array}{l}\text { 这个 } n \text { 是英文字母。代表重复前一个搜寻的动作。举例来说, } \\text { 如果刚刚我们执行 &#x2F; vbird 去向下搜寻 vbird 这个字符串, 则按下 } n \text { 后, } \\text { 会向下继续搜寻下一个名称为 vbird 的字符串。 }\end{array}$</td></tr><tr><td align="center">$\mathrm{N}$</td><td align="center">$\begin{array}{l}\text { 这个 } \mathrm{N} \text { 是英文按键。与 } \mathrm{n} \text { 刚好相反，为『反向』 } \\text { 进行前一个搜寻动作。例如 } &#x2F; v b i r d \text { 后，按下 } \mathrm{N} \text { 则表示『向上』搜寻 } \\text { vbird。 }\end{array}$</td></tr><tr><td align="center">[:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">$\begin{array}{l}\mathrm{n} 1 \text { 与 } \mathrm{n} 2 \text { 为数字。在第 } \mathrm{n} 1 \text { 与 } \mathrm{n} 2 \text { 行之间寻找 word } 1 \text { 这个字符串, } \\text { 并将该字符串取代为 word } 2 \text { 。 }\end{array}$</td></tr><tr><td align="center">:1$s&#x2F;word1&#x2F;word2&#x2F;g</td><td align="center">从第一行到最后一行寻找 word1 字符串, 并将该字符串取代为 word2。</td></tr><tr><td align="center">:1$s&#x2F;word1&#x2F;word2&#x2F;gc</td><td align="center">$\begin{array}{l}\text { 从第一行到最后一行寻找 word1 字符串, 并将该字符串取代为 word } 2 \\text { ! 且在取代前显示提示字符给用户确认 (confirm) 是否需要取代。 }\end{array}$</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-1.Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vmware &amp; Ubuntu</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Vmware%20and%20Ubuntu/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/Linux/Vmware%20and%20Ubuntu/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="刚安装后…"><a href="#刚安装后…" class="headerlink" title="刚安装后…"></a>刚安装后…</h1><ul><li>VM-tools（从主机复制到虚拟机）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get autoremove open-vm-tools<br>sudo apt-get install open-vm-tools<br>sudo apt-get install open-vm-tools-desktop<br></code></pre></td></tr></table></figure></li><li>更改软件源（得事先安装vim）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install vim<br>sudo <span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bat <span class="hljs-comment">#备份原文件</span><br>sudo vim /etc/apt/sources.list<br>deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse<br></code></pre></td></tr></table></figure></li></ul><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>*更改密码时出现su: Authentication failure：sudo passwd root修改密码然后su<br>*ubuntu左上角“执行文件操作需要认证”关闭：Alt+F2后输入r<br>*共享文件夹找不到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vmhgfs-fuse .host:/ /mnt/hgfs<br></code></pre></td></tr></table></figure><p>*该虚拟机似乎正在使用中”：进入虚拟机目录（F盘zuoyerumeng_Ubuntu目录），删除~.lck文件<br>*无法定位软件包位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt upgrade<br></code></pre></td></tr></table></figure><p>*无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系：sudo apt autoremove<br>*root模式下（su）仍然权限不够：chmod 755 文件名 #更改</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>(备用)Ctrl + Insert复制,Shift + Delete剪切<br>Ctrl + Alt 回到Windows里，Ctrl + G 进入vmware<br>Ctrl + Shift 原替换Win键功能（锁屏、显示桌面等等）<br>Ctrl + 空格 切换输入法；Win + 空格&#x2F;Shift 中英切换<br>Alt + F9&#x2F;10 最小&#x2F;大化窗口<br>shift + 鼠标滚轮 可以后退页面<br>Win + 鼠标滚轮 – 放大&#x2F;缩小屏幕<br>Ctrl + Alt + T 打开终端（bash命令行，类似于CMD）<br>Alt + F2 类似Windows下的Win + R组合键，在GNOME中运行应用程序<br>Shift+printscreen 自定义截图&#x2F;录屏<br>Win + A 显示应用程序菜单(九宫格图案那个)<br>进不去图形化界面（ubuntu smbus host controller not enabled）时：Ctrl+Alt+F2进入命令行<br>Ctrl +H +. :显示隐藏的.开头的文件<br>Ctrl + l:复制所选文件[夹]路径<br>Win + E：资源管理器（同Win~）<br>Win + S：设置<br>Win + C：启动计算器<br>Ctrl + Alt + F2：不小心按了F5进入纯命令行界面时，用来重新进入原图形化界面</p><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><ul><li>主分区-最多5个:<br>  须有一个激活分区(类似C盘),即boot分区,400MB或1GB<br>  &#x2F;分区:根目录,10G<br>  &#x2F;usr分区:默认装软件且大部分软件安装不能修改此路径,50G<br>  &#x2F;home分区:我电脑账户的各种文件(其中各多媒体,下载等都为不能删除的默认文件夹),尽量用掉剩余所有空间(考虑到可能存放大数据,100G较为合适)<br>  swap分区:将磁盘部分空间用于(临时)扩大内存从而加速运行,2G</li><li>扩展分区(条件):<br>  0&#x2F;1个<br>  主分区和扩展分区加起来最多4个(?)<br>  又分为了许多逻辑分区,其中主分区和逻辑分区加起来最多16个</li></ul>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>0-1.Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总体架构</title>
    <link href="/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/07/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E6%9E%B6%E6%9E%84/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h1><h2 id="关系型数据库（RDBMS）："><a href="#关系型数据库（RDBMS）：" class="headerlink" title="关系型数据库（RDBMS）："></a>关系型数据库（RDBMS）：</h2><p>*行存储，如MySQL、Oracle、Access、SQL Server</p><p>*适用于在线事务处理（OLTP），用于少量的行和列</p><h2 id="非关系型数据库：NoSQL（Not-only-SQL）"><a href="#非关系型数据库：NoSQL（Not-only-SQL）" class="headerlink" title="非关系型数据库：NoSQL（Not only SQL）"></a>非关系型数据库：NoSQL（Not <em>only</em> SQL）</h2><h3 id="列存储的数据库："><a href="#列存储的数据库：" class="headerlink" title="列存储的数据库："></a>列存储的数据库：</h3><p><em>Hbase、Cassandra、</em>Clickhouse</p><p>*适用于在线分析处理（OLAP），为大型表设计</p><h3 id="键值数据库：Redis"><a href="#键值数据库：Redis" class="headerlink" title="键值数据库：Redis"></a>键值数据库：Redis</h3><p>文档型数据库（键值数据库升级版，允许嵌套键值，查询效率更高）：MongoDB</p><h3 id="图形数据库：Neo4J"><a href="#图形数据库：Neo4J" class="headerlink" title="图形数据库：Neo4J"></a>图形数据库：Neo4J</h3><h1 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h1><h2 id="行存储VS列存储"><a href="#行存储VS列存储" class="headerlink" title="行存储VS列存储"></a>行存储VS列存储</h2><p>行存储：</p><ul><li><p>优点：写入是一次性完成，消耗的时间比列存储少，并且能够保证数据的完整性；</p></li><li><p>缺点：数据读取过程中会产生冗余数据，如果只有少量数据，此影响可以忽略；数量大可能会影响到数据的处理效率。</p></li></ul><p>列存储：</p><ul><li><p>优点：它的优势是在读取过程，不会产生冗余数据，这对数据完整性要求不高的大数据处理领域，比如互联网，犹为重要。</p></li><li><p>缺点：在写入效率、保证数据完整性上都不如行存储。</p></li></ul><h2 id="行存储VS键值存储"><a href="#行存储VS键值存储" class="headerlink" title="行存储VS键值存储"></a>行存储VS键值存储</h2><p>键值磁盘开销很小，但时间（修改等）效率较低，不能实现较大规模存储和分布式。</p>]]></content>
    
    
    <categories>
      
      <category>大数据开发&amp;架构</category>
      
      <category>3.数据存储</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
